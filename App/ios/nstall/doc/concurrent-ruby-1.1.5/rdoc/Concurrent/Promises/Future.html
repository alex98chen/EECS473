<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class Concurrent::Promises::Future - concurrent-ruby-1.1.5 Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
  var index_rel_prefix = "../../";
</script>

<script src="../../js/navigation.js" defer></script>
<script src="../../js/search.js" defer></script>
<script src="../../js/search_index.js" defer></script>
<script src="../../js/searcher.js" defer></script>
<script src="../../js/darkfish.js" defer></script>

<link href="../../css/fonts.css" rel="stylesheet">
<link href="../../css/rdoc.css" rel="stylesheet">




<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link"><a href="AbstractEventFuture.html">Concurrent::Promises::AbstractEventFuture</a>
  
</div>

    
    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-i-26">#&amp;</a>
    
    <li ><a href="#method-i-any">#any</a>
    
    <li ><a href="#method-i-apply">#apply</a>
    
    <li ><a href="#method-i-async_callback_on_fulfillment">#async_callback_on_fulfillment</a>
    
    <li ><a href="#method-i-async_callback_on_rejection">#async_callback_on_rejection</a>
    
    <li ><a href="#method-i-callback_on_fulfillment">#callback_on_fulfillment</a>
    
    <li ><a href="#method-i-callback_on_rejection">#callback_on_rejection</a>
    
    <li ><a href="#method-i-callback_on_resolution">#callback_on_resolution</a>
    
    <li ><a href="#method-i-delay">#delay</a>
    
    <li ><a href="#method-i-exception">#exception</a>
    
    <li ><a href="#method-i-flat">#flat</a>
    
    <li ><a href="#method-i-flat_event">#flat_event</a>
    
    <li ><a href="#method-i-flat_future">#flat_future</a>
    
    <li ><a href="#method-i-fulfilled-3F">#fulfilled?</a>
    
    <li ><a href="#method-i-inspect">#inspect</a>
    
    <li ><a href="#method-i-on_fulfillment">#on_fulfillment</a>
    
    <li ><a href="#method-i-on_fulfillment-21">#on_fulfillment!</a>
    
    <li ><a href="#method-i-on_fulfillment_using">#on_fulfillment_using</a>
    
    <li ><a href="#method-i-on_rejection">#on_rejection</a>
    
    <li ><a href="#method-i-on_rejection-21">#on_rejection!</a>
    
    <li ><a href="#method-i-on_rejection_using">#on_rejection_using</a>
    
    <li ><a href="#method-i-reason">#reason</a>
    
    <li ><a href="#method-i-rejected-3F">#rejected?</a>
    
    <li ><a href="#method-i-rejected_resolution">#rejected_resolution</a>
    
    <li ><a href="#method-i-rescue">#rescue</a>
    
    <li ><a href="#method-i-rescue_on">#rescue_on</a>
    
    <li ><a href="#method-i-result">#result</a>
    
    <li ><a href="#method-i-run">#run</a>
    
    <li ><a href="#method-i-run_test">#run_test</a>
    
    <li ><a href="#method-i-schedule">#schedule</a>
    
    <li ><a href="#method-i-then">#then</a>
    
    <li ><a href="#method-i-then_on">#then_on</a>
    
    <li ><a href="#method-i-to_event">#to_event</a>
    
    <li ><a href="#method-i-to_future">#to_future</a>
    
    <li class="calls-super" ><a href="#method-i-to_s">#to_s</a>
    
    <li ><a href="#method-i-value">#value</a>
    
    <li ><a href="#method-i-value-21">#value!</a>
    
    <li ><a href="#method-i-wait-21">#wait!</a>
    
    <li ><a href="#method-i-wait_until_resolved-21">#wait_until_resolved!</a>
    
    <li ><a href="#method-i-with_default_executor">#with_default_executor</a>
    
    <li ><a href="#method-i-zip">#zip</a>
    
    <li ><a href="#method-i-7C">#|</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-Concurrent::Promises::Future">
  <h1 id="class-Concurrent::Promises::Future" class="class">
    class Concurrent::Promises::Future
  </h1>

  <section class="description">
    
<p>Represents a value which will become available in future. May reject with a reason instead, e.g. when the tasks raises an exception.</p>

  </section>

  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-26" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">&amp;</span><span
            class="method-args">(other)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Future.html#method-i-zip">zip</a>
        </div>
        
      </div>

    
      <div id="method-i-any" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">any</span><span
            class="method-args">(event_or_future)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Creates a new event which will be resolved when the first of receiver, `event_or_future` resolves. Returning future will have value nil if event_or_future is event and resolves first.</p>

<p>@return [Future]</p>
          
          

          
          <div class="method-source-code" id="any-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1074</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any</span>(<span class="ruby-identifier">event_or_future</span>)
  <span class="ruby-constant">AnyResolvedFuturePromise</span>.<span class="ruby-identifier">new_blocked_by2</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">event_or_future</span>, <span class="ruby-ivar">@DefaultExecutor</span>).<span class="ruby-identifier">future</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Future.html#method-i-7C">|</a>
        </div>
        

        
      </div>

    
      <div id="method-i-apply" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">apply</span><span
            class="method-args">(args, block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!visibility private</p>
          
          

          
          <div class="method-source-code" id="apply-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1204</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">apply</span>(<span class="ruby-identifier">args</span>, <span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">internal_state</span>.<span class="ruby-identifier">apply</span> <span class="ruby-identifier">args</span>, <span class="ruby-identifier">block</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-delay" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">delay</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Creates new future dependent on receiver which will not evaluate until touched, see {#touch}. In other words, it inserts delay into the chain of Futures making rest of it lazy evaluated.</p>

<p>@return [Future]</p>
          
          

          
          <div class="method-source-code" id="delay-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1084</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delay</span>
  <span class="ruby-identifier">event</span> = <span class="ruby-constant">DelayPromise</span>.<span class="ruby-identifier">new</span>(<span class="ruby-ivar">@DefaultExecutor</span>).<span class="ruby-identifier">event</span>
  <span class="ruby-constant">ZipFutureEventPromise</span>.<span class="ruby-identifier">new_blocked_by2</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">event</span>, <span class="ruby-ivar">@DefaultExecutor</span>).<span class="ruby-identifier">future</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-exception" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">exception</span><span
            class="method-args">(*args)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Allows rejected <a href="Future.html"><code>Future</code></a> to be risen with `raise` method. If the reason is not an exception `Runtime.new(reason)` is returned.</p>

<p>@example</p>

<pre class="ruby"><span class="ruby-identifier">raise</span> <span class="ruby-constant">Promises</span>.<span class="ruby-identifier">rejected_future</span>(<span class="ruby-constant">StandardError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;boom&quot;</span>))
<span class="ruby-identifier">raise</span> <span class="ruby-constant">Promises</span>.<span class="ruby-identifier">rejected_future</span>(<span class="ruby-string">&quot;or just boom&quot;</span>)
</pre>

<p>@raise [Concurrent::Error] when raising not rejected future @return [Exception]</p>
          
          

          
          <div class="method-source-code" id="exception-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1002</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exception</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Error</span>, <span class="ruby-string">&#39;it is not rejected&#39;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">rejected?</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-value">1</span>
  <span class="ruby-identifier">reason</span> = <span class="ruby-constant">Array</span>(<span class="ruby-identifier">internal_state</span>.<span class="ruby-identifier">reason</span>).<span class="ruby-identifier">flatten</span>.<span class="ruby-identifier">compact</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">reason</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>
    <span class="ruby-identifier">ex</span> = <span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">MultipleErrors</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">reason</span>
    <span class="ruby-identifier">ex</span>.<span class="ruby-identifier">set_backtrace</span>(<span class="ruby-identifier">caller</span>)
    <span class="ruby-identifier">ex</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">ex</span> = <span class="ruby-keyword">if</span> <span class="ruby-identifier">reason</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">respond_to?</span> <span class="ruby-value">:exception</span>
           <span class="ruby-identifier">reason</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">exception</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
         <span class="ruby-keyword">else</span>
           <span class="ruby-constant">RuntimeError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">reason</span>[<span class="ruby-value">0</span>]).<span class="ruby-identifier">exception</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
         <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">ex</span>.<span class="ruby-identifier">set_backtrace</span> <span class="ruby-constant">Array</span>(<span class="ruby-identifier">ex</span>.<span class="ruby-identifier">backtrace</span>) <span class="ruby-operator">+</span> <span class="ruby-identifier">caller</span>
    <span class="ruby-identifier">ex</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-flat" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">flat</span><span
            class="method-args">(level = 1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Future.html#method-i-flat_future">flat_future</a>
        </div>
        
      </div>

    
      <div id="method-i-flat_event" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">flat_event</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Creates new event which will be resolved when the returned event by receiver is. Be careful if the receiver rejects it will just resolve since <a href="Event.html"><code>Event</code></a> does not hold reason.</p>

<p>@return [Event]</p>
          
          

          
          <div class="method-source-code" id="flat_event-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">flat_event</span>
  <span class="ruby-constant">FlatEventPromise</span>.<span class="ruby-identifier">new_blocked_by1</span>(<span class="ruby-keyword">self</span>, <span class="ruby-ivar">@DefaultExecutor</span>).<span class="ruby-identifier">event</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-flat_future" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">flat_future</span><span
            class="method-args">(level = 1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Creates new future which will have result of the future returned by receiver. If receiver rejects it will have its rejection.</p>

<p>@param [Integer] level how many levels of futures should flatten @return [Future]</p>
          
          

          
          <div class="method-source-code" id="flat_future-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">flat_future</span>(<span class="ruby-identifier">level</span> = <span class="ruby-value">1</span>)
  <span class="ruby-constant">FlatFuturePromise</span>.<span class="ruby-identifier">new_blocked_by1</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">level</span>, <span class="ruby-ivar">@DefaultExecutor</span>).<span class="ruby-identifier">future</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Future.html#method-i-flat">flat</a>
        </div>
        

        
      </div>

    
      <div id="method-i-fulfilled-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">fulfilled?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Is it in fulfilled state? @return [Boolean]</p>
          
          

          
          <div class="method-source-code" id="fulfilled-3F-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 910</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fulfilled?</span>
  <span class="ruby-identifier">state</span> = <span class="ruby-identifier">internal_state</span>
  <span class="ruby-identifier">state</span>.<span class="ruby-identifier">resolved?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">state</span>.<span class="ruby-identifier">fulfilled?</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-inspect" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">inspect</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Future.html#method-i-to_s">to_s</a>
        </div>
        
      </div>

    
      <div id="method-i-on_fulfillment" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">on_fulfillment</span><span
            class="method-args">(*args, &amp;callback)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!macro promises.shortcut.using @return [self]</p>
          
          

          
          <div class="method-source-code" id="on_fulfillment-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_fulfillment</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>)
  <span class="ruby-identifier">on_fulfillment_using</span> <span class="ruby-ivar">@DefaultExecutor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-on_fulfillment-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">on_fulfillment!</span><span
            class="method-args">(*args, &amp;callback)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Stores the callback to be executed synchronously on resolving thread after it is fulfilled. Does nothing on rejection.</p>

<p>@!macro promises.param.args @!macro promise.param.callback @return [self] @yield [value, *args] to the callback.</p>
          
          

          
          <div class="method-source-code" id="on_fulfillment-21-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_fulfillment!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>)
  <span class="ruby-identifier">add_callback</span> <span class="ruby-value">:callback_on_fulfillment</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">callback</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-on_fulfillment_using" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">on_fulfillment_using</span><span
            class="method-args">(executor, *args, &amp;callback)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Stores the callback to be executed asynchronously on executor after it is fulfilled. Does nothing on rejection.</p>

<p>@!macro promises.param.executor @!macro promises.param.args @!macro promise.param.callback @return [self] @yield [value, *args] to the callback.</p>
          
          

          
          <div class="method-source-code" id="on_fulfillment_using-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_fulfillment_using</span>(<span class="ruby-identifier">executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>)
  <span class="ruby-identifier">add_callback</span> <span class="ruby-value">:async_callback_on_fulfillment</span>, <span class="ruby-identifier">executor</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">callback</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-on_rejection" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">on_rejection</span><span
            class="method-args">(*args, &amp;callback)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!macro promises.shortcut.using @return [self]</p>
          
          

          
          <div class="method-source-code" id="on_rejection-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_rejection</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>)
  <span class="ruby-identifier">on_rejection_using</span> <span class="ruby-ivar">@DefaultExecutor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-on_rejection-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">on_rejection!</span><span
            class="method-args">(*args, &amp;callback)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Stores the callback to be executed synchronously on resolving thread after it is rejected. Does nothing on fulfillment.</p>

<p>@!macro promises.param.args @!macro promise.param.callback @return [self] @yield [reason, *args] to the callback.</p>
          
          

          
          <div class="method-source-code" id="on_rejection-21-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_rejection!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>)
  <span class="ruby-identifier">add_callback</span> <span class="ruby-value">:callback_on_rejection</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">callback</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-on_rejection_using" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">on_rejection_using</span><span
            class="method-args">(executor, *args, &amp;callback)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Stores the callback to be executed asynchronously on executor after it is rejected. Does nothing on fulfillment.</p>

<p>@!macro promises.param.executor @!macro promises.param.args @!macro promise.param.callback @return [self] @yield [reason, *args] to the callback.</p>
          
          

          
          <div class="method-source-code" id="on_rejection_using-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1177</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_rejection_using</span>(<span class="ruby-identifier">executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>)
  <span class="ruby-identifier">add_callback</span> <span class="ruby-value">:async_callback_on_rejection</span>, <span class="ruby-identifier">executor</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">callback</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reason" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">reason</span><span
            class="method-args">(timeout = nil, timeout_value = nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns reason of future&#39;s rejection. @!macro promises.touches</p>

<p>@!macro promises.warn.blocks @!macro promises.warn.nil @!macro promises.param.timeout @!macro promises.param.timeout_value @return [Object, timeout_value] the reason, or timeout_value on timeout, or nil on fulfillment.</p>
          
          

          
          <div class="method-source-code" id="reason-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 955</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reason</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">timeout_value</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">wait_until_resolved</span> <span class="ruby-identifier">timeout</span>
    <span class="ruby-identifier">internal_state</span>.<span class="ruby-identifier">reason</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">timeout_value</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-rejected-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">rejected?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Is it in rejected state? @return [Boolean]</p>
          
          

          
          <div class="method-source-code" id="rejected-3F-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 917</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rejected?</span>
  <span class="ruby-identifier">state</span> = <span class="ruby-identifier">internal_state</span>
  <span class="ruby-identifier">state</span>.<span class="ruby-identifier">resolved?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">state</span>.<span class="ruby-identifier">fulfilled?</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-rescue" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">rescue</span><span
            class="method-args">(*args, &amp;task)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!macro promises.shortcut.on @return [Future]</p>
          
          

          
          <div class="method-source-code" id="rescue-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1041</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">rescue</span>(<span class="ruby-operator">*</span><span class="ruby-identifier ruby-title">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>)
  <span class="ruby-identifier">rescue_on</span> <span class="ruby-ivar">@DefaultExecutor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-rescue_on" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">rescue_on</span><span
            class="method-args">(executor, *args, &amp;task)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Chains the task to be executed asynchronously on executor after it rejects. Does not run the task if it fulfills. It will resolve though, triggering any dependent futures.</p>

<p>@!macro promises.param.executor @!macro promises.param.args @!macro promise.param.task-future @return [Future] @yield [reason, *args] to the task.</p>
          
          

          
          <div class="method-source-code" id="rescue_on-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1053</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rescue_on</span>(<span class="ruby-identifier">executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>)
  <span class="ruby-constant">RescuePromise</span>.<span class="ruby-identifier">new_blocked_by1</span>(<span class="ruby-keyword">self</span>, <span class="ruby-ivar">@DefaultExecutor</span>, <span class="ruby-identifier">executor</span>, <span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>).<span class="ruby-identifier">future</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-result" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">result</span><span
            class="method-args">(timeout = nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns triplet fulfilled?, value, reason. @!macro promises.touches</p>

<p>@!macro promises.warn.blocks @!macro promises.param.timeout @return [Array(Boolean, Object, Object), nil] triplet of fulfilled?, value, reason, or nil</p>

<pre>on timeout.</pre>
          
          

          
          <div class="method-source-code" id="result-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 970</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">result</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">internal_state</span>.<span class="ruby-identifier">result</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">wait_until_resolved</span> <span class="ruby-identifier">timeout</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-run" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">run</span><span
            class="method-args">(run_test = method(:run_test))</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Allows to use futures as green threads. The receiver has to evaluate to a future which represents what should be done next. It basically flattens indefinitely until non <a href="Future.html"><code>Future</code></a> values is returned which becomes result of the returned future. Any encountered exception will become reason of the returned future.</p>

<p>@return [Future] @param [#call(value)] <a href="Future.html#method-i-run_test"><code>run_test</code></a></p>

<pre>an object which when called returns either Future to keep running with
or nil, then the run completes with the value.
The run_test can be used to extract the Future from deeper structure,
or to distinguish Future which is a resulting value from a future
which is suppose to continue running.</pre>

<p>@example</p>

<pre class="ruby"><span class="ruby-identifier">body</span> = <span class="ruby-identifier">lambda</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">v</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
  <span class="ruby-identifier">v</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">5</span> <span class="ruby-operator">?</span> <span class="ruby-constant">Promises</span>.<span class="ruby-identifier">future</span>(<span class="ruby-identifier">v</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">body</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">v</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">Promises</span>.<span class="ruby-identifier">future</span>(<span class="ruby-value">0</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">body</span>).<span class="ruby-identifier">run</span>.<span class="ruby-identifier">value!</span> <span class="ruby-comment"># =&gt; 5</span>
</pre>
          
          

          
          <div class="method-source-code" id="run-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1199</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">run</span>(<span class="ruby-identifier">run_test</span> = <span class="ruby-identifier">method</span>(<span class="ruby-value">:run_test</span>))
  <span class="ruby-constant">RunFuturePromise</span>.<span class="ruby-identifier">new_blocked_by1</span>(<span class="ruby-keyword">self</span>, <span class="ruby-ivar">@DefaultExecutor</span>, <span class="ruby-identifier">run_test</span>).<span class="ruby-identifier">future</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-schedule" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">schedule</span><span
            class="method-args">(intended_time)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!macro promise.method.schedule @return [Future]</p>
          
          

          
          <div class="method-source-code" id="schedule-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1091</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">schedule</span>(<span class="ruby-identifier">intended_time</span>)
  <span class="ruby-identifier">chain</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">event</span> = <span class="ruby-constant">ScheduledPromise</span>.<span class="ruby-identifier">new</span>(<span class="ruby-ivar">@DefaultExecutor</span>, <span class="ruby-identifier">intended_time</span>).<span class="ruby-identifier">event</span>
    <span class="ruby-constant">ZipFutureEventPromise</span>.<span class="ruby-identifier">new_blocked_by2</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">event</span>, <span class="ruby-ivar">@DefaultExecutor</span>).<span class="ruby-identifier">future</span>
  <span class="ruby-keyword">end</span>.<span class="ruby-identifier">flat</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-then" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">then</span><span
            class="method-args">(*args, &amp;task)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!macro promises.shortcut.on @return [Future]</p>
          
          

          
          <div class="method-source-code" id="then-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1023</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">then</span>(<span class="ruby-operator">*</span><span class="ruby-identifier ruby-title">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>)
  <span class="ruby-identifier">then_on</span> <span class="ruby-ivar">@DefaultExecutor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-then_on" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">then_on</span><span
            class="method-args">(executor, *args, &amp;task)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Chains the task to be executed asynchronously on executor after it fulfills. Does not run the task if it rejects. It will resolve though, triggering any dependent futures.</p>

<p>@!macro promises.param.executor @!macro promises.param.args @!macro promise.param.task-future @return [Future] @yield [value, *args] to the task.</p>
          
          

          
          <div class="method-source-code" id="then_on-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1035</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">then_on</span>(<span class="ruby-identifier">executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>)
  <span class="ruby-constant">ThenPromise</span>.<span class="ruby-identifier">new_blocked_by1</span>(<span class="ruby-keyword">self</span>, <span class="ruby-ivar">@DefaultExecutor</span>, <span class="ruby-identifier">executor</span>, <span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>).<span class="ruby-identifier">future</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_event" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">to_event</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Converts future to event which is resolved when future is resolved by fulfillment or rejection.</p>

<p>@return [Event]</p>
          
          

          
          <div class="method-source-code" id="to_event-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1211</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_event</span>
  <span class="ruby-identifier">event</span> = <span class="ruby-constant">Promises</span>.<span class="ruby-identifier">resolvable_event</span>
<span class="ruby-keyword">ensure</span>
  <span class="ruby-identifier">chain_resolvable</span>(<span class="ruby-identifier">event</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_future" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">to_future</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns self, since this is a future @return [Future]</p>
          
          

          
          <div class="method-source-code" id="to_future-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1219</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_future</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_s" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">to_s</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@return [String] Short string representation.</p>
          
          
            <div class="method-calls-super">
              Calls superclass method
              <a href="AbstractEventFuture.html#method-i-to_s"><code>Concurrent::Promises::AbstractEventFuture#to_s</code></a>
            </div>
          

          
          <div class="method-source-code" id="to_s-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1224</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">resolved?</span>
    <span class="ruby-identifier">format</span> <span class="ruby-string">&#39;%s with %s&gt;&#39;</span>, <span class="ruby-keyword">super</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>], (<span class="ruby-identifier">fulfilled?</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">reason</span>).<span class="ruby-identifier">inspect</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">super</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Future.html#method-i-inspect">inspect</a>
        </div>
        

        
      </div>

    
      <div id="method-i-value" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">value</span><span
            class="method-args">(timeout = nil, timeout_value = nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!macro promises.method.value</p>

<pre>Return value of the future.
@!macro promises.touches

@!macro promises.warn.blocks
@!macro promises.warn.nil
@!macro promises.param.timeout
@!macro promises.param.timeout_value
  @param [Object] timeout_value a value returned by the method when it times out</pre>

<p>@return [Object, nil, timeout_value] the value of the <a href="Future.html"><code>Future</code></a> when fulfilled,</p>

<pre>timeout_value on timeout,
nil on rejection.</pre>
          
          

          
          <div class="method-source-code" id="value-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 939</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">timeout_value</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">wait_until_resolved</span> <span class="ruby-identifier">timeout</span>
    <span class="ruby-identifier">internal_state</span>.<span class="ruby-identifier">value</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">timeout_value</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-value-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">value!</span><span
            class="method-args">(timeout = nil, timeout_value = nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!macro promises.method.value @return [Object, nil, timeout_value] the value of the <a href="Future.html"><code>Future</code></a> when fulfilled,</p>

<pre>or nil on rejection,
or timeout_value on timeout.</pre>

<p>@raise [Exception] {#reason} on rejection</p>
          
          

          
          <div class="method-source-code" id="value-21-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 986</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value!</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">timeout_value</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">wait_until_resolved!</span> <span class="ruby-identifier">timeout</span>
    <span class="ruby-identifier">internal_state</span>.<span class="ruby-identifier">value</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">timeout_value</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-wait-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">wait!</span><span
            class="method-args">(timeout = nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!macro promises.method.wait @raise [Exception] {#reason} on rejection</p>
          
          

          
          <div class="method-source-code" id="wait-21-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 976</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait!</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">result</span> = <span class="ruby-identifier">wait_until_resolved!</span>(<span class="ruby-identifier">timeout</span>)
  <span class="ruby-identifier">timeout</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">result</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-with_default_executor" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">with_default_executor</span><span
            class="method-args">(executor)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!macro promises.method.with_default_executor @return [Future]</p>
          
          

          
          <div class="method-source-code" id="with_default_executor-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_default_executor</span>(<span class="ruby-identifier">executor</span>)
  <span class="ruby-constant">FutureWrapperPromise</span>.<span class="ruby-identifier">new_blocked_by1</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">executor</span>).<span class="ruby-identifier">future</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-zip" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">zip</span><span
            class="method-args">(other)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!macro promises.method.zip @return [Future]</p>
          
          

          
          <div class="method-source-code" id="zip-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1059</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">zip</span>(<span class="ruby-identifier">other</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">other</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Future</span>)
    <span class="ruby-constant">ZipFuturesPromise</span>.<span class="ruby-identifier">new_blocked_by2</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">other</span>, <span class="ruby-ivar">@DefaultExecutor</span>).<span class="ruby-identifier">future</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-constant">ZipFutureEventPromise</span>.<span class="ruby-identifier">new_blocked_by2</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">other</span>, <span class="ruby-ivar">@DefaultExecutor</span>).<span class="ruby-identifier">future</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Future.html#method-i-26">&amp;</a>
        </div>
        

        
      </div>

    
      <div id="method-i-7C" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">|</span><span
            class="method-args">(event_or_future)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Future.html#method-i-any">any</a>
        </div>
        
      </div>

    
    </section>
  
     <section id="private-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Private Instance Methods</h3>
       </header>

    
      <div id="method-i-async_callback_on_fulfillment" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">async_callback_on_fulfillment</span><span
            class="method-args">(state, executor, args, callback)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="async_callback_on_fulfillment-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1261</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">async_callback_on_fulfillment</span>(<span class="ruby-identifier">state</span>, <span class="ruby-identifier">executor</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">callback</span>)
  <span class="ruby-identifier">with_async</span>(<span class="ruby-identifier">executor</span>, <span class="ruby-identifier">state</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">callback</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">st</span>, <span class="ruby-identifier">ar</span>, <span class="ruby-identifier">cb</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">callback_on_fulfillment</span> <span class="ruby-identifier">st</span>, <span class="ruby-identifier">ar</span>, <span class="ruby-identifier">cb</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-async_callback_on_rejection" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">async_callback_on_rejection</span><span
            class="method-args">(state, executor, args, callback)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="async_callback_on_rejection-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1267</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">async_callback_on_rejection</span>(<span class="ruby-identifier">state</span>, <span class="ruby-identifier">executor</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">callback</span>)
  <span class="ruby-identifier">with_async</span>(<span class="ruby-identifier">executor</span>, <span class="ruby-identifier">state</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">callback</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">st</span>, <span class="ruby-identifier">ar</span>, <span class="ruby-identifier">cb</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">callback_on_rejection</span> <span class="ruby-identifier">st</span>, <span class="ruby-identifier">ar</span>, <span class="ruby-identifier">cb</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-callback_on_fulfillment" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">callback_on_fulfillment</span><span
            class="method-args">(state, args, callback)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="callback_on_fulfillment-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1273</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">callback_on_fulfillment</span>(<span class="ruby-identifier">state</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">callback</span>)
  <span class="ruby-identifier">state</span>.<span class="ruby-identifier">apply</span> <span class="ruby-identifier">args</span>, <span class="ruby-identifier">callback</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">state</span>.<span class="ruby-identifier">fulfilled?</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-callback_on_rejection" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">callback_on_rejection</span><span
            class="method-args">(state, args, callback)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="callback_on_rejection-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1277</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">callback_on_rejection</span>(<span class="ruby-identifier">state</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">callback</span>)
  <span class="ruby-identifier">state</span>.<span class="ruby-identifier">apply</span> <span class="ruby-identifier">args</span>, <span class="ruby-identifier">callback</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">state</span>.<span class="ruby-identifier">fulfilled?</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-callback_on_resolution" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">callback_on_resolution</span><span
            class="method-args">(state, args, callback)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="callback_on_resolution-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1281</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">callback_on_resolution</span>(<span class="ruby-identifier">state</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">callback</span>)
  <span class="ruby-identifier">callback</span>.<span class="ruby-identifier">call</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">state</span>.<span class="ruby-identifier">result</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-rejected_resolution" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">rejected_resolution</span><span
            class="method-args">(raise_on_reassign, state)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="rejected_resolution-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1240</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rejected_resolution</span>(<span class="ruby-identifier">raise_on_reassign</span>, <span class="ruby-identifier">state</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">raise_on_reassign</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">internal_state</span> <span class="ruby-operator">==</span> <span class="ruby-constant">RESERVED</span>
      <span class="ruby-identifier">raise</span> <span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">MultipleAssignmentError</span>.<span class="ruby-identifier">new</span>(
          <span class="ruby-string">&quot;Future can be resolved only once. It is already reserved.&quot;</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">raise</span> <span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">MultipleAssignmentError</span>.<span class="ruby-identifier">new</span>(
          <span class="ruby-node">&quot;Future can be resolved only once. It&#39;s #{result}, trying to set #{state.result}.&quot;</span>,
          <span class="ruby-value">current_result:</span> <span class="ruby-identifier">result</span>,
          <span class="ruby-value">new_result:</span>     <span class="ruby-identifier">state</span>.<span class="ruby-identifier">result</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-run_test" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">run_test</span><span
            class="method-args">(v)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="run_test-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1236</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">run_test</span>(<span class="ruby-identifier">v</span>)
  <span class="ruby-identifier">v</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Future</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-wait_until_resolved-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">wait_until_resolved!</span><span
            class="method-args">(timeout = nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="wait_until_resolved-21-source">
            <pre><span class="ruby-comment"># File lib/concurrent/promises.rb, line 1255</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait_until_resolved!</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">result</span> = <span class="ruby-identifier">wait_until_resolved</span>(<span class="ruby-identifier">timeout</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-keyword">self</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">rejected?</span>
  <span class="ruby-identifier">result</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>

</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.1.2.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

