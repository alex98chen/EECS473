var search_data = {"index":{"searchIndex":["array","atomicreference","concurrent","abstractexchanger","abstractexecutorservice","abstractthreadlocalvar","agent","error","validationerror","async","asyncdelegator","awaitdelegator","classmethods","atexitimplementation","atom","atomicboolean","atomicdirectupdate","atomicfixnum","atomicmarkablereference","atomicnumericcompareandsetwrapper","cachedthreadpool","collection","atomicreferencemapbackend","node","table","copyonnotifyobserverset","copyonwriteobserverset","javanonconcurrentpriorityqueue","mrimapbackend","nonconcurrentmapbackend","nonconcurrentpriorityqueue","rubynonconcurrentpriorityqueue","synchronizedmapbackend","concern","deprecation","dereferenceable","logging","obligation","observable","concurrentupdateerror","countdownlatch","cyclicbarrier","delay","dependencycounter","event","exchanger","executorservice","fixedthreadpool","future","ivar","immediateexecutor","immutablestruct","indirectimmediateexecutor","javaatomicreference","javacountdownlatch","javaexchanger","javaexecutorservice","job","javasinglethreadexecutor","javathreadlocalvar","javathreadpoolexecutor","lockfreestack","node","mvar","map","maybe","multipleassignmenterror","multipleerrors","mutablestruct","mutexatomicboolean","mutexatomicfixnum","mutexatomicreference","mutexcountdownlatch","mutexsemaphore","options","promise","promises","abstractanypromise","abstracteventfuture","abstractflatpromise","abstractpromise","anyfulfilledfuturepromise","anyresolvedeventpromise","anyresolvedfuturepromise","blockedpromise","blockedtaskpromise","chainpromise","delaypromise","event","eventwrapperpromise","factorymethods","configuration","flateventpromise","flatfuturepromise","future","futurewrapperpromise","immediateeventpromise","immediatefuturepromise","innerpromise","internalstates","fulfilled","fulfilledarray","partiallyrejected","pending","rejected","reserved","resolvedwithresult","state","rescuepromise","resolvable","resolvableevent","resolvableeventpromise","resolvablefuture","resolvablefuturepromise","runfuturepromise","scheduledpromise","thenpromise","zipeventeventpromise","zipeventspromise","zipfutureeventpromise","zipfuturespromise","rbxarray","rbxatomicreference","rbxhash","rbxset","reinclude","readwritelock","reentrantreadwritelock","rubyexchanger","node","rubyexecutorservice","rubysinglethreadexecutor","rubythreadlocalvar","rubythreadpoolexecutor","worker","safetaskexecutor","scheduledtask","semaphore","serialexecutorservice","serializedexecution","serializedexecutiondelegator","settablestruct","simpleexecutorservice","singlethreadexecutor","synchronization","abstractlockableobject","abstractobject","abstractstruct","condition","conditionsignalling","jrubyattrvolatile","classmethods","jrubylockableobject","jrubyobject","lock","lockableobject","monitorlockableobject","mriattrvolatile","classmethods","mriobject","mutexlockableobject","object","rbxattrvolatile","classmethods","rbxlockableobject","rbxobject","trufflerubyattrvolatile","classmethods","trufflerubyobject","synchronizeddelegator","tvar","threadlocalvar","threadpoolexecutor","threadsafe","util","adder","cheaplockable","poweroftwotuple","striped64","cell","volatile","xorshiftrandom","timerset","timertask","transaction","trufflerubyarray","trufflerubyatomicreference","trufflerubyhash","trufflerubyset","tuple","utility","enginedetector","nativeextensionloader","nativeinteger","processorcounter","hash","set","truffleruby","&()","&()","<<()","<<()","<<()","<<()","<<()","<<()","<<()","<<()","<=>()","<=>()","==()","==()","==()","[]()","[]()","[]()","[]()","[]()","[]()","[]()","[]=()","[]=()","[]=()","[]=()","[]=()","[]=()","__initialize_atomic_fields__()","_compare_and_set()","_get()","_mon_initialize()","_set()","abort()","abort_transaction()","abort_transaction()","acquire()","acquire_read_lock()","acquire_read_lock()","acquire_write_lock()","acquire_write_lock()","add()","add()","add_callback()","add_callback_clear_delayed_node()","add_callback_notify_blocked()","add_delayed()","add_delayed_of()","add_observer()","add_observer()","add_observer()","add_observer()","aggregate()","all?()","allocate_storage()","allocate_storage()","allocate_storage()","allow_c_extensions?()","any()","any()","any()","any?()","any_event()","any_event_on()","any_fulfilled_future()","any_fulfilled_future_on()","any_resolved_future()","any_resolved_future_on()","apply()","apply()","apply()","apply()","apply()","apply()","apply_deref_options()","async()","async_callback_on_fulfillment()","async_callback_on_rejection()","async_callback_on_resolution()","atomic_attribute?()","atomic_attributes()","atomically()","atomically()","attempt_compute()","attempt_get_and_set()","attempt_internal_compute_if_absent()","attempt_internal_replace()","attr_atomic()","attr_volatile()","attr_volatile()","attr_volatile()","attr_volatile()","attr_volatile()","attr_volatile()","auto_terminate=()","auto_terminate?()","available_permits()","await()","await()","await()","await_for()","await_for()","await_for!()","await_for!()","bind()","blocked_by()","blocks()","borrow()","broadcast()","broadcast()","broken?()","c_extensions_loaded?()","call()","call_callback()","call_callbacks()","call_dataflow()","call_dataflow()","call_job()","callback_clear_delayed_node()","callback_notify_blocked()","callback_on_fulfillment()","callback_on_rejection()","callback_on_resolution()","callback_on_resolution()","callbacks()","can_overflow?()","can_overflow?()","can_overflow?()","cancel()","cancel()","cancelled?()","cancelled?()","cas()","cas_base_computed()","cas_computed()","cas_new_node()","cast()","catch()","chain()","chain_on()","chain_resolvable()","cheap_broadcast()","cheap_synchronize()","cheap_wait()","check_for_resize()","clear()","clear()","clear()","clear()","clear()","clear()","clear()","clear_and_propagate_touch()","clear_each()","clear_if()","clear_observers_and_return_old()","commit()","compare_and_clear()","compare_and_pop()","compare_and_push()","compare_and_set()","compare_and_set()","compare_and_set()","compare_and_set()","compare_and_set()","compare_and_set_state()","compare_and_swap()","complete()","complete()","complete?()","complete_without_notification()","completed_task_count()","completed_task_count()","compute()","compute()","compute()","compute()","compute_if_absent()","compute_if_absent()","compute_if_absent()","compute_if_absent()","compute_if_present()","compute_if_present()","compute_if_present()","compute_if_present()","compute_physical_processor_count()","compute_processor_count()","count()","count()","count_down()","count_down()","count_observers()","count_observers()","count_observers()","create_simple_logger()","create_stdlib_logger()","create_worker()","current()","current=()","dataflow()","dataflow()","dataflow!()","dataflow!()","dataflow_with()","dataflow_with()","dataflow_with!()","dataflow_with!()","decrement()","decrement()","decrement_size()","default()","default_executor()","default_executor()","default_executor()","default_for()","define_initialize_atomic_fields()","define_struct_class()","delay()","delay()","delay()","delay_on()","delayed_because()","delayed_because()","delayed_because()","delete()","delete()","delete()","delete()","delete()","delete()","delete()","delete_node_at()","delete_observer()","delete_observer()","delete_observer()","delete_observers()","delete_observers()","delete_observers()","delete_pair()","delete_pair()","delete_pair()","delete_pair()","deprecated()","deprecated_method()","deq()","deq()","deref()","deref()","disable_at_exit_handlers!()","do_exchange()","do_exchange()","do_exchange()","down()","drain_permits()","duplicate_and_clear_observers()","duplicate_observers()","dupped_backend()","dupped_backend()","each()","each()","each()","each()","each()","each()","each_key()","each_pair()","each_pair()","each_pair()","each_pair()","each_pair()","each_pair()","each_value()","empty?()","empty?()","empty?()","empty?()","empty?()","empty?()","enabled=()","enabled?()","enq()","enq()","enqueue_action_job()","enqueue_await_job()","ensure_integer()","ensure_integer_and_bounds()","ensure_lower_bound()","ensure_positive()","ensure_positive_and_no_zero()","ensure_safe_initialization_when_final_fields_are_present()","ensure_upper_bound()","error()","evaluate_to()","evaluate_to()","evaluate_to!()","event()","event()","exception()","exception()","exchange()","exchange!()","execute()","execute()","execute()","execute()","execute()","execute()","execute()","execute()","execute()","execute_next_job()","execute_task()","execution_interval()","execution_interval=()","executor()","executor()","executor()","expand_table_unless_stale()","extended()","fail()","fail()","failed?()","false?()","fetch()","fetch_or_store()","find_value_in_node_list()","flat()","flat_event()","flat_future()","flat_map()","force_acquire_lock()","free?()","from()","from_list()","from_list()","fulfill()","fulfill()","fulfilled?()","fulfilled?()","fulfilled?()","fulfilled?()","fulfilled?()","fulfilled?()","fulfilled?()","fulfilled_future()","full?()","full_memory_barrier()","full_memory_barrier()","full_memory_barrier()","full_memory_barrier()","future()","future()","future_on()","get()","get()","get()","get()","get()","get_and_set()","get_and_set()","get_and_set()","get_and_set()","get_and_set()","get_arguments_from()","get_or_default()","get_or_default()","get_or_default()","get_threadlocal_array()","get_time()","global_fast_executor()","global_immediate_executor()","global_io_executor()","global_logger()","global_logger=()","global_timer_set()","handle_error()","handle_fallback()","handler?()","handlers()","has_priority?()","has_priority?()","has_waiters?()","hash_code()","hash_code=()","hash_to_index()","idletime()","if_state()","immutable_array()","include()","include?()","include?()","included()","included()","included()","included()","included()","included()","included()","incomplete?()","increment()","increment()","increment_size()","index()","init_obligation()","init_synchronization()","initial_delay()","initialize_copy()","initialize_copy()","initialize_copy()","initialize_table()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","install()","intended_time()","internal_compute()","internal_replace()","internal_reset()","item()","java_extensions_loaded?()","just()","just?()","key()","key?()","key?()","key?()","key?()","key_hash()","keys()","kill()","kill()","kill()","kill()","kill()","kill()","kill()","largest_length()","largest_length()","latch()","leave_transaction()","leave_transaction()","length()","length()","length()","length()","length()","load_error_path()","load_native_extensions()","lock_and_clean_up_reverse_forwarders()","locked?()","locked_hash?()","log()","make_false()","make_future()","make_synchronized_on_rbx()","make_synchronized_on_truffleruby()","make_true()","mark()","marked?()","marshal_dump()","marshal_load()","matches?()","max_readers?()","max_readers?()","max_writers?()","max_writers?()","members()","merge()","merge()","merge()","merge_pair()","merge_pair()","merge_pair()","merge_pair()","method_missing()","method_missing()","method_missing()","min_length()","modify()","modify!()","monotonic_time()","monotonic_time()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new_blocked_by()","new_blocked_by1()","new_blocked_by2()","new_condition()","new_fast_executor()","new_io_executor()","next_in_size_table()","no_error!()","nothing()","nothing?()","notify_and_delete_observers()","notify_and_delete_observers()","notify_child()","notify_observers()","notify_observers()","notify_observers()","notify_to()","notify_to()","ns_add_busy_worker()","ns_assign_worker()","ns_auto_terminate=()","ns_auto_terminate?()","ns_broadcast()","ns_broadcast()","ns_broadcast()","ns_broadcast()","ns_check_state?()","ns_complete_without_notification()","ns_each()","ns_each_pair()","ns_enqueue()","ns_enqueue_job()","ns_equality()","ns_execute()","ns_execute()","ns_find_last_job_for_thread()","ns_generation_done()","ns_get()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_inspect()","ns_kill_execution()","ns_kill_execution()","ns_kill_execution()","ns_limited_queue?()","ns_make_value()","ns_merge()","ns_next_generation()","ns_post_next_job()","ns_post_task()","ns_prune_pool()","ns_ready_worker()","ns_remove_busy_worker()","ns_reschedule()","ns_reset_if_forked()","ns_reset_if_forked()","ns_running?()","ns_running?()","ns_schedule()","ns_select()","ns_set()","ns_set()","ns_set_deref_options()","ns_set_state()","ns_shutdown?()","ns_shutdown?()","ns_shutdown_execution()","ns_shutdown_execution()","ns_shutdown_execution()","ns_shutdown_execution()","ns_shutdown_execution()","ns_shuttingdown?()","ns_shuttingdown?()","ns_signal()","ns_signal()","ns_signal()","ns_signal()","ns_to_h()","ns_validate()","ns_values()","ns_values_at()","ns_wait()","ns_wait()","ns_wait()","ns_wait()","ns_wait()","ns_wait_until()","ns_wait_until()","ns_worker_died()","ns_worker_not_old_enough()","number_waiting()","observers()","observers=()","of1()","of2()","on_blocker_resolution()","on_cruby?()","on_error()","on_fulfill()","on_fulfillment()","on_fulfillment!()","on_fulfillment_using()","on_jruby?()","on_jruby_9000?()","on_linux?()","on_osx?()","on_rbx?()","on_reject()","on_rejection()","on_rejection!()","on_rejection_using()","on_resolution()","on_resolution!()","on_resolution_using()","on_resolvable()","on_resolvable()","on_resolvable()","on_resolvable()","on_resolvable()","on_resolvable()","on_resolvable()","on_resolvable()","on_resolvable()","on_resolvable()","on_resolvable()","on_resolvable()","on_resolvable()","on_success()","on_truffleruby?()","on_windows?()","or()","ordered?()","padding()","pair?()","parties()","peek()","peek()","peek()","pending?()","pending?()","perform()","physical_processor_count()","physical_processor_count()","pop()","pop()","pop()","populate_from()","post()","post()","post()","post()","post()","post()","post()","post()","post()","post()","post()","post_task()","posts()","pr_underscore()","process_on_blocker_resolution()","process_on_blocker_resolution()","process_on_blocker_resolution()","process_on_blocker_resolution()","process_on_blocker_resolution()","process_on_blocker_resolution()","process_task()","process_tasks()","processing?()","processor_count()","processor_count()","promise()","pure_hash()","push()","push()","push()","put()","put_if_absent()","queue_length()","queue_length()","raise_fetch_no_key()","read()","ready_worker()","realize()","realized?()","reason()","reason()","reason()","reason()","reason()","reason()","reason()","reason()","rebuild()","reconfigure()","reduce_permits()","reject()","reject()","rejected?()","rejected?()","rejected?()","rejected_future()","rejected_resolution()","rejected_resolution()","release()","release_read_lock()","release_read_lock()","release_write_lock()","release_write_lock()","remaining_capacity()","remaining_capacity()","remove_busy_worker()","remove_task()","replace_if()","replace_if_exists()","replace_if_exists()","replace_if_exists()","replace_if_exists()","replace_pair()","replace_pair()","replace_pair()","replace_pair()","reschedule()","rescue()","rescue()","rescue_on()","reset()","reset()","reset()","reset()","reset()","resolvable?()","resolvable?()","resolvable?()","resolvable?()","resolvable?()","resolvable_event()","resolvable_event_on()","resolvable_future()","resolvable_future_on()","resolve()","resolve()","resolve_with()","resolve_with()","resolved?()","resolved?()","resolved?()","resolved?()","resolved_event()","resolved_future()","respond_to_missing?()","respond_to_missing?()","restart()","result()","result()","result()","retry_update()","ruby_engine()","ruby_version()","run()","run()","run()","run_task()","run_test()","runner()","running?()","running?()","running?()","running?()","running?()","running_readers()","running_readers()","running_readers?()","running_readers?()","running_writer?()","running_writer?()","safe_execute()","safe_initialization!()","safe_initialization?()","schedule()","schedule()","schedule()","schedule_next_task()","schedule_on()","schedule_time()","scheduled_task_count()","scheduled_task_count()","select()","select()","select()","send()","send!()","send_off()","send_off!()","send_via()","send_via!()","serialized?()","serialized?()","set()","set()","set()","set()","set()","set()","set()","set!()","set?()","set_c_extensions_loaded()","set_deref_options()","set_java_extensions_loaded()","set_pending()","set_state()","set_state!()","set_threadlocal_array()","setup()","shift()","shift()","shutdown()","shutdown()","shutdown()","shutdown()","shutdown()","shutdown?()","shutdown?()","shutdown?()","shuttingdown?()","shuttingdown?()","shuttingdown?()","signal()","signal()","sink()","size()","size()","size()","size()","size()","size()","size()","split_bin()","split_old_bin()","state()","state()","state()","state=()","stop()","stop_event()","stopped?()","stopped_event()","store_computed_value()","sum()","swap()","swap()","swap()","swim()","synchronize()","synchronize()","synchronize()","synchronize()","synchronize()","synchronized()","synchronized_set_state!()","table_size_for()","take()","tangle()","teardown()","terminate_at_exit()","then()","then()","then_on()","thread_finalizer()","threadlocal_finalizer()","timeout_interval()","timeout_interval=()","timeout_task()","to_a()","to_a()","to_a()","to_event()","to_event()","to_future()","to_future()","to_h()","to_h()","to_h()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_sym()","to_sym()","to_sym()","to_sym()","to_sym()","to_sym()","touch()","touch()","touch()","touch()","touch()","touched?()","touched?()","true?()","try?()","try_acquire()","try_acquire_now()","try_acquire_timed()","try_await_lock()","try_await_lock()","try_exchange()","try_in_busy()","try_in_resize_lock()","try_initialize_cells()","try_load_c_extension()","try_lock_via_hash()","try_lock_via_hash()","try_put!()","try_read_lock()","try_set()","try_take!()","try_to_cas_in_computed()","try_to_install_new_cell()","try_update()","try_update()","try_update!()","try_update!()","try_write_lock()","unlock()","unlock_via_hash()","unlocked_empty?()","unlocked_full?()","unscheduled?()","up()","update()","update()","update()","use_simple_logger()","use_stdlib_logger()","valid?()","valid?()","validate_argc()","validate_options_hash!()","value()","value()","value()","value()","value()","value()","value()","value()","value()","value()","value()","value()","value()","value()","value()","value()","value()","value()","value!()","value!()","value!()","value!()","value=()","value=()","value=()","value=()","value=()","value=()","value=()","value=()","value?()","value_for()","values()","values()","values()","values()","values_at()","values_at()","values_at()","volatile_get()","volatile_get_by_hash()","volatile_set()","volatile_set_by_hash()","wait()","wait()","wait()","wait()","wait()","wait()","wait()","wait()","wait()","wait()","wait()","wait()","wait!()","wait!()","wait!()","wait_for_empty()","wait_for_full()","wait_for_termination()","wait_for_termination()","wait_for_termination()","wait_for_termination()","wait_for_termination()","wait_or_cancel()","wait_until()","wait_until()","wait_until_resolved()","wait_until_resolved!()","wait_while()","waiting_or_running_writer?()","waiting_threads()","waiting_writer?()","waiting_writers()","waiting_writers()","with_async()","with_default_executor()","with_default_executor()","with_default_executor()","with_hidden_resolvable()","with_hidden_resolvable()","with_hidden_resolvable()","with_observer()","with_read_lock()","with_read_lock()","with_write_lock()","with_write_lock()","work()","worker_died()","worker_not_old_enough()","worker_task_completed()","write()","write_locked?()","xorshift()","zip()","zip()","zip()","zip()","zip()","zip_events()","zip_events_on()","zip_futures()","zip_futures_on()","|()","|()","changelog","license","readme"],"longSearchIndex":["array","atomicreference","concurrent","concurrent::abstractexchanger","concurrent::abstractexecutorservice","concurrent::abstractthreadlocalvar","concurrent::agent","concurrent::agent::error","concurrent::agent::validationerror","concurrent::async","concurrent::async::asyncdelegator","concurrent::async::awaitdelegator","concurrent::async::classmethods","concurrent::atexitimplementation","concurrent::atom","concurrent::atomicboolean","concurrent::atomicdirectupdate","concurrent::atomicfixnum","concurrent::atomicmarkablereference","concurrent::atomicnumericcompareandsetwrapper","concurrent::cachedthreadpool","concurrent::collection","concurrent::collection::atomicreferencemapbackend","concurrent::collection::atomicreferencemapbackend::node","concurrent::collection::atomicreferencemapbackend::table","concurrent::collection::copyonnotifyobserverset","concurrent::collection::copyonwriteobserverset","concurrent::collection::javanonconcurrentpriorityqueue","concurrent::collection::mrimapbackend","concurrent::collection::nonconcurrentmapbackend","concurrent::collection::nonconcurrentpriorityqueue","concurrent::collection::rubynonconcurrentpriorityqueue","concurrent::collection::synchronizedmapbackend","concurrent::concern","concurrent::concern::deprecation","concurrent::concern::dereferenceable","concurrent::concern::logging","concurrent::concern::obligation","concurrent::concern::observable","concurrent::concurrentupdateerror","concurrent::countdownlatch","concurrent::cyclicbarrier","concurrent::delay","concurrent::dependencycounter","concurrent::event","concurrent::exchanger","concurrent::executorservice","concurrent::fixedthreadpool","concurrent::future","concurrent::ivar","concurrent::immediateexecutor","concurrent::immutablestruct","concurrent::indirectimmediateexecutor","concurrent::javaatomicreference","concurrent::javacountdownlatch","concurrent::javaexchanger","concurrent::javaexecutorservice","concurrent::javaexecutorservice::job","concurrent::javasinglethreadexecutor","concurrent::javathreadlocalvar","concurrent::javathreadpoolexecutor","concurrent::lockfreestack","concurrent::lockfreestack::node","concurrent::mvar","concurrent::map","concurrent::maybe","concurrent::multipleassignmenterror","concurrent::multipleerrors","concurrent::mutablestruct","concurrent::mutexatomicboolean","concurrent::mutexatomicfixnum","concurrent::mutexatomicreference","concurrent::mutexcountdownlatch","concurrent::mutexsemaphore","concurrent::options","concurrent::promise","concurrent::promises","concurrent::promises::abstractanypromise","concurrent::promises::abstracteventfuture","concurrent::promises::abstractflatpromise","concurrent::promises::abstractpromise","concurrent::promises::anyfulfilledfuturepromise","concurrent::promises::anyresolvedeventpromise","concurrent::promises::anyresolvedfuturepromise","concurrent::promises::blockedpromise","concurrent::promises::blockedtaskpromise","concurrent::promises::chainpromise","concurrent::promises::delaypromise","concurrent::promises::event","concurrent::promises::eventwrapperpromise","concurrent::promises::factorymethods","concurrent::promises::factorymethods::configuration","concurrent::promises::flateventpromise","concurrent::promises::flatfuturepromise","concurrent::promises::future","concurrent::promises::futurewrapperpromise","concurrent::promises::immediateeventpromise","concurrent::promises::immediatefuturepromise","concurrent::promises::innerpromise","concurrent::promises::internalstates","concurrent::promises::internalstates::fulfilled","concurrent::promises::internalstates::fulfilledarray","concurrent::promises::internalstates::partiallyrejected","concurrent::promises::internalstates::pending","concurrent::promises::internalstates::rejected","concurrent::promises::internalstates::reserved","concurrent::promises::internalstates::resolvedwithresult","concurrent::promises::internalstates::state","concurrent::promises::rescuepromise","concurrent::promises::resolvable","concurrent::promises::resolvableevent","concurrent::promises::resolvableeventpromise","concurrent::promises::resolvablefuture","concurrent::promises::resolvablefuturepromise","concurrent::promises::runfuturepromise","concurrent::promises::scheduledpromise","concurrent::promises::thenpromise","concurrent::promises::zipeventeventpromise","concurrent::promises::zipeventspromise","concurrent::promises::zipfutureeventpromise","concurrent::promises::zipfuturespromise","concurrent::rbxarray","concurrent::rbxatomicreference","concurrent::rbxhash","concurrent::rbxset","concurrent::reinclude","concurrent::readwritelock","concurrent::reentrantreadwritelock","concurrent::rubyexchanger","concurrent::rubyexchanger::node","concurrent::rubyexecutorservice","concurrent::rubysinglethreadexecutor","concurrent::rubythreadlocalvar","concurrent::rubythreadpoolexecutor","concurrent::rubythreadpoolexecutor::worker","concurrent::safetaskexecutor","concurrent::scheduledtask","concurrent::semaphore","concurrent::serialexecutorservice","concurrent::serializedexecution","concurrent::serializedexecutiondelegator","concurrent::settablestruct","concurrent::simpleexecutorservice","concurrent::singlethreadexecutor","concurrent::synchronization","concurrent::synchronization::abstractlockableobject","concurrent::synchronization::abstractobject","concurrent::synchronization::abstractstruct","concurrent::synchronization::condition","concurrent::synchronization::conditionsignalling","concurrent::synchronization::jrubyattrvolatile","concurrent::synchronization::jrubyattrvolatile::classmethods","concurrent::synchronization::jrubylockableobject","concurrent::synchronization::jrubyobject","concurrent::synchronization::lock","concurrent::synchronization::lockableobject","concurrent::synchronization::monitorlockableobject","concurrent::synchronization::mriattrvolatile","concurrent::synchronization::mriattrvolatile::classmethods","concurrent::synchronization::mriobject","concurrent::synchronization::mutexlockableobject","concurrent::synchronization::object","concurrent::synchronization::rbxattrvolatile","concurrent::synchronization::rbxattrvolatile::classmethods","concurrent::synchronization::rbxlockableobject","concurrent::synchronization::rbxobject","concurrent::synchronization::trufflerubyattrvolatile","concurrent::synchronization::trufflerubyattrvolatile::classmethods","concurrent::synchronization::trufflerubyobject","concurrent::synchronizeddelegator","concurrent::tvar","concurrent::threadlocalvar","concurrent::threadpoolexecutor","concurrent::threadsafe","concurrent::threadsafe::util","concurrent::threadsafe::util::adder","concurrent::threadsafe::util::cheaplockable","concurrent::threadsafe::util::poweroftwotuple","concurrent::threadsafe::util::striped64","concurrent::threadsafe::util::striped64::cell","concurrent::threadsafe::util::volatile","concurrent::threadsafe::util::xorshiftrandom","concurrent::timerset","concurrent::timertask","concurrent::transaction","concurrent::trufflerubyarray","concurrent::trufflerubyatomicreference","concurrent::trufflerubyhash","concurrent::trufflerubyset","concurrent::tuple","concurrent::utility","concurrent::utility::enginedetector","concurrent::utility::nativeextensionloader","concurrent::utility::nativeinteger","concurrent::utility::processorcounter","hash","set","truffleruby","concurrent::promises::event#&()","concurrent::promises::future#&()","concurrent::agent#<<()","concurrent::collection::javanonconcurrentpriorityqueue#<<()","concurrent::collection::rubynonconcurrentpriorityqueue#<<()","concurrent::executorservice#<<()","concurrent::immediateexecutor#<<()","concurrent::rubythreadpoolexecutor::worker#<<()","concurrent::simpleexecutorservice::<<()","concurrent::simpleexecutorservice#<<()","concurrent::maybe#<=>()","concurrent::scheduledtask#<=>()","concurrent::immutablestruct#==()","concurrent::mutablestruct#==()","concurrent::settablestruct#==()","concurrent::collection::atomicreferencemapbackend#[]()","concurrent::collection::nonconcurrentmapbackend#[]()","concurrent::collection::synchronizedmapbackend#[]()","concurrent::immutablestruct#[]()","concurrent::map#[]()","concurrent::mutablestruct#[]()","concurrent::settablestruct#[]()","concurrent::collection::atomicreferencemapbackend#[]=()","concurrent::collection::mrimapbackend#[]=()","concurrent::collection::nonconcurrentmapbackend#[]=()","concurrent::collection::synchronizedmapbackend#[]=()","concurrent::mutablestruct#[]=()","concurrent::settablestruct#[]=()","concurrent::synchronization::object#__initialize_atomic_fields__()","concurrent::mutexatomicreference#_compare_and_set()","concurrent::collection::nonconcurrentmapbackend#_get()","concurrent::threadsafe::util#_mon_initialize()","concurrent::collection::nonconcurrentmapbackend#_set()","concurrent::transaction#abort()","concurrent::abort_transaction()","concurrent#abort_transaction()","concurrent::mutexsemaphore#acquire()","concurrent::readwritelock#acquire_read_lock()","concurrent::reentrantreadwritelock#acquire_read_lock()","concurrent::readwritelock#acquire_write_lock()","concurrent::reentrantreadwritelock#acquire_write_lock()","concurrent::atexitimplementation#add()","concurrent::threadsafe::util::adder#add()","concurrent::promises::abstracteventfuture#add_callback()","concurrent::promises::abstracteventfuture#add_callback_clear_delayed_node()","concurrent::promises::abstracteventfuture#add_callback_notify_blocked()","concurrent::promises::blockedpromise::add_delayed()","concurrent::promises::abstractflatpromise#add_delayed_of()","concurrent::collection::copyonnotifyobserverset#add_observer()","concurrent::collection::copyonwriteobserverset#add_observer()","concurrent::concern::observable#add_observer()","concurrent::ivar#add_observer()","concurrent::promise::aggregate()","concurrent::promise::all?()","concurrent::abstractthreadlocalvar#allocate_storage()","concurrent::javathreadlocalvar#allocate_storage()","concurrent::rubythreadlocalvar#allocate_storage()","concurrent::utility::nativeextensionloader#allow_c_extensions?()","concurrent::promises::event#any()","concurrent::promises::factorymethods#any()","concurrent::promises::future#any()","concurrent::promise::any?()","concurrent::promises::factorymethods#any_event()","concurrent::promises::factorymethods#any_event_on()","concurrent::promises::factorymethods#any_fulfilled_future()","concurrent::promises::factorymethods#any_fulfilled_future_on()","concurrent::promises::factorymethods#any_resolved_future()","concurrent::promises::factorymethods#any_resolved_future_on()","concurrent::promises::future#apply()","concurrent::promises::internalstates::fulfilled#apply()","concurrent::promises::internalstates::fulfilledarray#apply()","concurrent::promises::internalstates::partiallyrejected#apply()","concurrent::promises::internalstates::rejected#apply()","concurrent::promises::internalstates::resolvedwithresult#apply()","concurrent::concern::dereferenceable#apply_deref_options()","concurrent::async#async()","concurrent::promises::future#async_callback_on_fulfillment()","concurrent::promises::future#async_callback_on_rejection()","concurrent::promises::abstracteventfuture#async_callback_on_resolution()","concurrent::synchronization::object::atomic_attribute?()","concurrent::synchronization::object::atomic_attributes()","concurrent::atomically()","concurrent#atomically()","concurrent::collection::atomicreferencemapbackend#attempt_compute()","concurrent::collection::atomicreferencemapbackend#attempt_get_and_set()","concurrent::collection::atomicreferencemapbackend#attempt_internal_compute_if_absent()","concurrent::collection::atomicreferencemapbackend#attempt_internal_replace()","concurrent::synchronization::object::attr_atomic()","concurrent::synchronization::abstractobject::attr_volatile()","concurrent::synchronization::jrubyattrvolatile::classmethods#attr_volatile()","concurrent::synchronization::mriattrvolatile::classmethods#attr_volatile()","concurrent::synchronization::rbxattrvolatile::classmethods#attr_volatile()","concurrent::synchronization::trufflerubyattrvolatile::classmethods#attr_volatile()","concurrent::threadsafe::util::volatile#attr_volatile()","concurrent::abstractexecutorservice#auto_terminate=()","concurrent::abstractexecutorservice#auto_terminate?()","concurrent::mutexsemaphore#available_permits()","concurrent::agent#await()","concurrent::agent::await()","concurrent::async#await()","concurrent::agent#await_for()","concurrent::agent::await_for()","concurrent::agent::await_for!()","concurrent::agent#await_for!()","concurrent::abstractthreadlocalvar#bind()","concurrent::promises::blockedpromise#blocked_by()","concurrent::promises::abstracteventfuture#blocks()","concurrent::mvar#borrow()","concurrent::synchronization::condition#broadcast()","concurrent::synchronization::lock#broadcast()","concurrent::cyclicbarrier#broken?()","concurrent::utility::nativeextensionloader#c_extensions_loaded?()","concurrent::async#call()","concurrent::promises::abstracteventfuture#call_callback()","concurrent::promises::abstracteventfuture#call_callbacks()","concurrent#call_dataflow()","concurrent::call_dataflow()","concurrent::serializedexecution#call_job()","concurrent::promises::abstracteventfuture#callback_clear_delayed_node()","concurrent::promises::abstracteventfuture#callback_notify_blocked()","concurrent::promises::future#callback_on_fulfillment()","concurrent::promises::future#callback_on_rejection()","concurrent::promises::event#callback_on_resolution()","concurrent::promises::future#callback_on_resolution()","concurrent::promises::abstracteventfuture#callbacks()","concurrent::executorservice#can_overflow?()","concurrent::javathreadpoolexecutor#can_overflow?()","concurrent::rubythreadpoolexecutor#can_overflow?()","concurrent::future#cancel()","concurrent::scheduledtask#cancel()","concurrent::future#cancelled?()","concurrent::scheduledtask#cancelled?()","concurrent::tuple#cas()","concurrent::threadsafe::util::striped64#cas_base_computed()","concurrent::threadsafe::util::striped64::cell#cas_computed()","concurrent::collection::atomicreferencemapbackend::table#cas_new_node()","concurrent::async#cast()","concurrent::promise#catch()","concurrent::promises::abstracteventfuture#chain()","concurrent::promises::abstracteventfuture#chain_on()","concurrent::promises::abstracteventfuture#chain_resolvable()","concurrent::threadsafe::util::cheaplockable#cheap_broadcast()","concurrent::threadsafe::util::cheaplockable#cheap_synchronize()","concurrent::threadsafe::util::cheaplockable#cheap_wait()","concurrent::collection::atomicreferencemapbackend#check_for_resize()","concurrent::collection::atomicreferencemapbackend#clear()","concurrent::collection::javanonconcurrentpriorityqueue#clear()","concurrent::collection::mrimapbackend#clear()","concurrent::collection::nonconcurrentmapbackend#clear()","concurrent::collection::rubynonconcurrentpriorityqueue#clear()","concurrent::collection::synchronizedmapbackend#clear()","concurrent::lockfreestack#clear()","concurrent::promises::blockedpromise#clear_and_propagate_touch()","concurrent::lockfreestack#clear_each()","concurrent::lockfreestack#clear_if()","concurrent::collection::copyonwriteobserverset#clear_observers_and_return_old()","concurrent::transaction#commit()","concurrent::lockfreestack#compare_and_clear()","concurrent::lockfreestack#compare_and_pop()","concurrent::lockfreestack#compare_and_push()","concurrent::atom#compare_and_set()","concurrent::atomicmarkablereference#compare_and_set()","concurrent::atomicnumericcompareandsetwrapper#compare_and_set()","concurrent::mutexatomicfixnum#compare_and_set()","concurrent::tuple#compare_and_set()","concurrent::concern::obligation#compare_and_set_state()","concurrent::atomicmarkablereference#compare_and_swap()","concurrent::ivar#complete()","concurrent::promise#complete()","concurrent::concern::obligation#complete?()","concurrent::ivar#complete_without_notification()","concurrent::javathreadpoolexecutor#completed_task_count()","concurrent::rubythreadpoolexecutor#completed_task_count()","concurrent::collection::atomicreferencemapbackend#compute()","concurrent::collection::mrimapbackend#compute()","concurrent::collection::nonconcurrentmapbackend#compute()","concurrent::collection::synchronizedmapbackend#compute()","concurrent::collection::atomicreferencemapbackend#compute_if_absent()","concurrent::collection::mrimapbackend#compute_if_absent()","concurrent::collection::nonconcurrentmapbackend#compute_if_absent()","concurrent::collection::synchronizedmapbackend#compute_if_absent()","concurrent::collection::atomicreferencemapbackend#compute_if_present()","concurrent::collection::mrimapbackend#compute_if_present()","concurrent::collection::nonconcurrentmapbackend#compute_if_present()","concurrent::collection::synchronizedmapbackend#compute_if_present()","concurrent::utility::processorcounter#compute_physical_processor_count()","concurrent::utility::processorcounter#compute_processor_count()","concurrent::javacountdownlatch#count()","concurrent::mutexcountdownlatch#count()","concurrent::javacountdownlatch#count_down()","concurrent::mutexcountdownlatch#count_down()","concurrent::collection::copyonnotifyobserverset#count_observers()","concurrent::collection::copyonwriteobserverset#count_observers()","concurrent::concern::observable#count_observers()","concurrent::create_simple_logger()","concurrent::create_stdlib_logger()","concurrent::rubythreadpoolexecutor::worker#create_worker()","concurrent::transaction::current()","concurrent::transaction::current=()","concurrent#dataflow()","concurrent::dataflow()","concurrent#dataflow!()","concurrent::dataflow!()","concurrent#dataflow_with()","concurrent::dataflow_with()","concurrent::dataflow_with!()","concurrent#dataflow_with!()","concurrent::mutexatomicfixnum#decrement()","concurrent::threadsafe::util::adder#decrement()","concurrent::collection::atomicreferencemapbackend#decrement_size()","concurrent::abstractthreadlocalvar#default()","concurrent::promises::abstracteventfuture#default_executor()","concurrent::promises::abstractpromise#default_executor()","concurrent::promises::factorymethods::configuration#default_executor()","concurrent::rubythreadlocalvar#default_for()","concurrent::synchronization::object::define_initialize_atomic_fields()","concurrent::synchronization::abstractstruct::define_struct_class()","concurrent::promises::event#delay()","concurrent::promises::factorymethods#delay()","concurrent::promises::future#delay()","concurrent::promises::factorymethods#delay_on()","concurrent::promises::abstractpromise#delayed_because()","concurrent::promises::blockedpromise#delayed_because()","concurrent::promises::delaypromise#delayed_because()","concurrent::atexitimplementation#delete()","concurrent::collection::atomicreferencemapbackend#delete()","concurrent::collection::javanonconcurrentpriorityqueue#delete()","concurrent::collection::mrimapbackend#delete()","concurrent::collection::nonconcurrentmapbackend#delete()","concurrent::collection::rubynonconcurrentpriorityqueue#delete()","concurrent::collection::synchronizedmapbackend#delete()","concurrent::collection::atomicreferencemapbackend::table#delete_node_at()","concurrent::collection::copyonnotifyobserverset#delete_observer()","concurrent::collection::copyonwriteobserverset#delete_observer()","concurrent::concern::observable#delete_observer()","concurrent::collection::copyonnotifyobserverset#delete_observers()","concurrent::collection::copyonwriteobserverset#delete_observers()","concurrent::concern::observable#delete_observers()","concurrent::collection::atomicreferencemapbackend#delete_pair()","concurrent::collection::mrimapbackend#delete_pair()","concurrent::collection::nonconcurrentmapbackend#delete_pair()","concurrent::collection::synchronizedmapbackend#delete_pair()","concurrent::concern::deprecation#deprecated()","concurrent::concern::deprecation#deprecated_method()","concurrent::collection::javanonconcurrentpriorityqueue#deq()","concurrent::collection::rubynonconcurrentpriorityqueue#deq()","concurrent::agent#deref()","concurrent::concern::dereferenceable#deref()","concurrent::disable_at_exit_handlers!()","concurrent::abstractexchanger#do_exchange()","concurrent::javaexchanger#do_exchange()","concurrent::rubyexchanger#do_exchange()","concurrent::mutexatomicfixnum#down()","concurrent::mutexsemaphore#drain_permits()","concurrent::collection::copyonnotifyobserverset#duplicate_and_clear_observers()","concurrent::collection::copyonnotifyobserverset#duplicate_observers()","concurrent::collection::nonconcurrentmapbackend#dupped_backend()","concurrent::collection::synchronizedmapbackend#dupped_backend()","concurrent::immutablestruct#each()","concurrent::lockfreestack#each()","concurrent::map#each()","concurrent::mutablestruct#each()","concurrent::settablestruct#each()","concurrent::tuple#each()","concurrent::map#each_key()","concurrent::collection::atomicreferencemapbackend#each_pair()","concurrent::collection::nonconcurrentmapbackend#each_pair()","concurrent::immutablestruct#each_pair()","concurrent::map#each_pair()","concurrent::mutablestruct#each_pair()","concurrent::settablestruct#each_pair()","concurrent::map#each_value()","concurrent::collection::atomicreferencemapbackend#empty?()","concurrent::collection::javanonconcurrentpriorityqueue#empty?()","concurrent::collection::rubynonconcurrentpriorityqueue#empty?()","concurrent::lockfreestack#empty?()","concurrent::mvar#empty?()","concurrent::map#empty?()","concurrent::atexitimplementation#enabled=()","concurrent::atexitimplementation#enabled?()","concurrent::collection::javanonconcurrentpriorityqueue#enq()","concurrent::collection::rubynonconcurrentpriorityqueue#enq()","concurrent::agent#enqueue_action_job()","concurrent::agent#enqueue_await_job()","concurrent::utility::nativeinteger#ensure_integer()","concurrent::utility::nativeinteger#ensure_integer_and_bounds()","concurrent::utility::nativeinteger#ensure_lower_bound()","concurrent::utility::nativeinteger#ensure_positive()","concurrent::utility::nativeinteger#ensure_positive_and_no_zero()","concurrent::synchronization::object::ensure_safe_initialization_when_final_fields_are_present()","concurrent::utility::nativeinteger#ensure_upper_bound()","concurrent::agent#error()","concurrent::promises::abstractpromise#evaluate_to()","concurrent::promises::resolvablefuture#evaluate_to()","concurrent::promises::resolvablefuture#evaluate_to!()","concurrent::concern::obligation#event()","concurrent::promises::abstractpromise#event()","concurrent::concern::obligation#exception()","concurrent::promises::future#exception()","concurrent::abstractexchanger#exchange()","concurrent::abstractexchanger#exchange!()","concurrent::future#execute()","concurrent::future::execute()","concurrent::promise::execute()","concurrent::promise#execute()","concurrent::safetaskexecutor#execute()","concurrent::scheduledtask#execute()","concurrent::scheduledtask::execute()","concurrent::timertask::execute()","concurrent::timertask#execute()","concurrent::agent#execute_next_job()","concurrent::timertask#execute_task()","concurrent::timertask#execution_interval()","concurrent::timertask#execution_interval=()","concurrent::executor()","concurrent::options::executor()","concurrent::promises::blockedtaskpromise#executor()","concurrent::threadsafe::util::striped64#expand_table_unless_stale()","concurrent::reinclude#extended()","concurrent::ivar#fail()","concurrent::promise#fail()","concurrent::agent#failed?()","concurrent::mutexatomicboolean#false?()","concurrent::map#fetch()","concurrent::map#fetch_or_store()","concurrent::collection::atomicreferencemapbackend#find_value_in_node_list()","concurrent::promises::future#flat()","concurrent::promises::future#flat_event()","concurrent::promises::future#flat_future()","concurrent::promise#flat_map()","concurrent::collection::atomicreferencemapbackend::node#force_acquire_lock()","concurrent::threadsafe::util::striped64#free?()","concurrent::maybe::from()","concurrent::collection::javanonconcurrentpriorityqueue::from_list()","concurrent::collection::rubynonconcurrentpriorityqueue::from_list()","concurrent::promise::fulfill()","concurrent::promises::resolvablefuture#fulfill()","concurrent::concern::obligation#fulfilled?()","concurrent::maybe#fulfilled?()","concurrent::promises::future#fulfilled?()","concurrent::promises::internalstates::fulfilled#fulfilled?()","concurrent::promises::internalstates::partiallyrejected#fulfilled?()","concurrent::promises::internalstates::rejected#fulfilled?()","concurrent::promises::internalstates::resolvedwithresult#fulfilled?()","concurrent::promises::factorymethods#fulfilled_future()","concurrent::mvar#full?()","concurrent::synchronization::abstractobject#full_memory_barrier()","concurrent::synchronization::mriattrvolatile#full_memory_barrier()","concurrent::synchronization::rbxattrvolatile#full_memory_barrier()","concurrent::synchronization::trufflerubyattrvolatile#full_memory_barrier()","concurrent::promises::abstractpromise#future()","concurrent::promises::factorymethods#future()","concurrent::promises::factorymethods#future_on()","concurrent::atomicmarkablereference#get()","concurrent::map#get()","concurrent::mutexatomicreference#get()","concurrent::threadsafe::util::xorshiftrandom#get()","concurrent::tuple#get()","concurrent::collection::atomicreferencemapbackend#get_and_set()","concurrent::collection::mrimapbackend#get_and_set()","concurrent::collection::nonconcurrentmapbackend#get_and_set()","concurrent::collection::synchronizedmapbackend#get_and_set()","concurrent::mutexatomicreference#get_and_set()","concurrent::concern::obligation#get_arguments_from()","concurrent::collection::atomicreferencemapbackend#get_or_default()","concurrent::collection::nonconcurrentmapbackend#get_or_default()","concurrent::collection::synchronizedmapbackend#get_or_default()","concurrent::rubythreadlocalvar#get_threadlocal_array()","concurrent#get_time()","concurrent::global_fast_executor()","concurrent::global_immediate_executor()","concurrent::global_io_executor()","concurrent::global_logger()","concurrent::global_logger=()","concurrent::global_timer_set()","concurrent::agent#handle_error()","concurrent::abstractexecutorservice#handle_fallback()","concurrent::atexitimplementation#handler?()","concurrent::atexitimplementation#handlers()","concurrent::collection::javanonconcurrentpriorityqueue#has_priority?()","concurrent::collection::rubynonconcurrentpriorityqueue#has_priority?()","concurrent::readwritelock#has_waiters?()","concurrent::threadsafe::util::striped64#hash_code()","concurrent::threadsafe::util::striped64#hash_code=()","concurrent::threadsafe::util::poweroftwotuple#hash_to_index()","concurrent::javathreadpoolexecutor#idletime()","concurrent::concern::obligation#if_state()","concurrent::atomicmarkablereference#immutable_array()","concurrent::reinclude#include()","concurrent::collection::javanonconcurrentpriorityqueue#include?()","concurrent::collection::rubynonconcurrentpriorityqueue#include?()","concurrent::async::included()","concurrent::immutablestruct::included()","concurrent::reinclude#included()","concurrent::synchronization::jrubyattrvolatile::included()","concurrent::synchronization::mriattrvolatile::included()","concurrent::synchronization::rbxattrvolatile::included()","concurrent::synchronization::trufflerubyattrvolatile::included()","concurrent::concern::obligation#incomplete?()","concurrent::mutexatomicfixnum#increment()","concurrent::threadsafe::util::adder#increment()","concurrent::collection::atomicreferencemapbackend#increment_size()","concurrent::map#index()","concurrent::concern::obligation#init_obligation()","concurrent::async#init_synchronization()","concurrent::scheduledtask#initial_delay()","concurrent::collection::atomicreferencemapbackend#initialize_copy()","concurrent::collection::nonconcurrentmapbackend#initialize_copy()","concurrent::map#initialize_copy()","concurrent::collection::atomicreferencemapbackend#initialize_table()","atomicreference#inspect()","concurrent::atomicboolean#inspect()","concurrent::atomicfixnum#inspect()","concurrent::immutablestruct#inspect()","concurrent::lockfreestack#inspect()","concurrent::map#inspect()","concurrent::multipleassignmenterror#inspect()","concurrent::mutablestruct#inspect()","concurrent::promises::abstracteventfuture#inspect()","concurrent::promises::abstractpromise#inspect()","concurrent::promises::future#inspect()","concurrent::promises::scheduledpromise#inspect()","concurrent::settablestruct#inspect()","concurrent::atexitimplementation#install()","concurrent::promises::scheduledpromise#intended_time()","concurrent::collection::atomicreferencemapbackend#internal_compute()","concurrent::collection::atomicreferencemapbackend#internal_replace()","concurrent::threadsafe::util::striped64#internal_reset()","concurrent::rubyexchanger::node#item()","concurrent::utility::nativeextensionloader#java_extensions_loaded?()","concurrent::maybe::just()","concurrent::maybe#just?()","concurrent::map#key()","concurrent::collection::atomicreferencemapbackend#key?()","concurrent::collection::atomicreferencemapbackend::node#key?()","concurrent::collection::nonconcurrentmapbackend#key?()","concurrent::collection::synchronizedmapbackend#key?()","concurrent::collection::atomicreferencemapbackend#key_hash()","concurrent::map#keys()","concurrent::abstractexecutorservice#kill()","concurrent::immediateexecutor#kill()","concurrent::javaexecutorservice#kill()","concurrent::rubyexecutorservice#kill()","concurrent::rubythreadpoolexecutor::worker#kill()","concurrent::simpleexecutorservice#kill()","concurrent::timerset#kill()","concurrent::javathreadpoolexecutor#largest_length()","concurrent::rubythreadpoolexecutor#largest_length()","concurrent::rubyexchanger::node#latch()","concurrent::leave_transaction()","concurrent#leave_transaction()","concurrent::collection::javanonconcurrentpriorityqueue#length()","concurrent::collection::rubynonconcurrentpriorityqueue#length()","concurrent::javathreadpoolexecutor#length()","concurrent::rubythreadpoolexecutor#length()","concurrent::synchronization::abstractstruct#length()","concurrent::utility::nativeextensionloader#load_error_path()","concurrent::utility::nativeextensionloader#load_native_extensions()","concurrent::collection::atomicreferencemapbackend#lock_and_clean_up_reverse_forwarders()","concurrent::collection::atomicreferencemapbackend::node#locked?()","concurrent::collection::atomicreferencemapbackend::node::locked_hash?()","concurrent::concern::logging#log()","concurrent::mutexatomicboolean#make_false()","concurrent::promises::factorymethods#make_future()","concurrent::threadsafe::util::make_synchronized_on_rbx()","concurrent::threadsafe::util::make_synchronized_on_truffleruby()","concurrent::mutexatomicboolean#make_true()","concurrent::atomicmarkablereference#mark()","concurrent::atomicmarkablereference#marked?()","concurrent::map#marshal_dump()","concurrent::map#marshal_load()","concurrent::collection::atomicreferencemapbackend::node#matches?()","concurrent::readwritelock#max_readers?()","concurrent::reentrantreadwritelock#max_readers?()","concurrent::readwritelock#max_writers?()","concurrent::reentrantreadwritelock#max_writers?()","concurrent::synchronization::abstractstruct#members()","concurrent::immutablestruct#merge()","concurrent::mutablestruct#merge()","concurrent::settablestruct#merge()","concurrent::collection::atomicreferencemapbackend#merge_pair()","concurrent::collection::mrimapbackend#merge_pair()","concurrent::collection::nonconcurrentmapbackend#merge_pair()","concurrent::collection::synchronizedmapbackend#merge_pair()","concurrent::async::asyncdelegator#method_missing()","concurrent::async::awaitdelegator#method_missing()","concurrent::synchronizeddelegator#method_missing()","concurrent::javathreadpoolexecutor#min_length()","concurrent::mvar#modify()","concurrent::mvar#modify!()","concurrent#monotonic_time()","concurrent::monotonic_time()","concurrent::new()","concurrent::abstractexchanger::new()","concurrent::abstractexecutorservice::new()","concurrent::abstractthreadlocalvar::new()","concurrent::agent::new()","concurrent::agent::error::new()","concurrent::agent::validationerror::new()","concurrent::async::asyncdelegator::new()","concurrent::async::awaitdelegator::new()","concurrent::async::classmethods#new()","concurrent::atexitimplementation::new()","concurrent::atom::new()","concurrent::atomicmarkablereference::new()","concurrent::cachedthreadpool::new()","concurrent::collection::atomicreferencemapbackend::new()","concurrent::collection::atomicreferencemapbackend::node::new()","concurrent::collection::copyonnotifyobserverset::new()","concurrent::collection::copyonwriteobserverset::new()","concurrent::collection::javanonconcurrentpriorityqueue::new()","concurrent::collection::mrimapbackend::new()","concurrent::collection::nonconcurrentmapbackend::new()","concurrent::collection::rubynonconcurrentpriorityqueue::new()","concurrent::cyclicbarrier::new()","concurrent::delay::new()","concurrent::event::new()","concurrent::fixedthreadpool::new()","concurrent::future::new()","concurrent::ivar::new()","concurrent::immediateexecutor::new()","concurrent::immutablestruct::new()","concurrent::indirectimmediateexecutor::new()","concurrent::javacountdownlatch::new()","concurrent::javaexchanger::new()","concurrent::javaexecutorservice::new()","concurrent::javaexecutorservice::job::new()","concurrent::javasinglethreadexecutor::new()","concurrent::javathreadpoolexecutor::new()","concurrent::lockfreestack::new()","concurrent::lockfreestack::node::new()","concurrent::mvar::new()","concurrent::map::new()","concurrent::maybe::new()","concurrent::multipleassignmenterror::new()","concurrent::multipleerrors::new()","concurrent::mutablestruct::new()","concurrent::mutexatomicboolean::new()","concurrent::mutexatomicfixnum::new()","concurrent::mutexatomicreference::new()","concurrent::mutexcountdownlatch::new()","concurrent::mutexsemaphore::new()","concurrent::promise::new()","concurrent::promises::abstracteventfuture::new()","concurrent::promises::abstractflatpromise::new()","concurrent::promises::abstractpromise::new()","concurrent::promises::anyresolvedeventpromise::new()","concurrent::promises::anyresolvedfuturepromise::new()","concurrent::promises::blockedpromise::new()","concurrent::promises::blockedpromise::new()","concurrent::promises::blockedtaskpromise::new()","concurrent::promises::delaypromise::new()","concurrent::promises::eventwrapperpromise::new()","concurrent::promises::flateventpromise::new()","concurrent::promises::flatfuturepromise::new()","concurrent::promises::futurewrapperpromise::new()","concurrent::promises::immediateeventpromise::new()","concurrent::promises::immediatefuturepromise::new()","concurrent::promises::internalstates::fulfilled::new()","concurrent::promises::internalstates::partiallyrejected::new()","concurrent::promises::internalstates::rejected::new()","concurrent::promises::rescuepromise::new()","concurrent::promises::resolvableeventpromise::new()","concurrent::promises::resolvablefuturepromise::new()","concurrent::promises::runfuturepromise::new()","concurrent::promises::scheduledpromise::new()","concurrent::promises::thenpromise::new()","concurrent::promises::zipeventeventpromise::new()","concurrent::promises::zipeventspromise::new()","concurrent::promises::zipfutureeventpromise::new()","concurrent::promises::zipfuturespromise::new()","concurrent::readwritelock::new()","concurrent::reentrantreadwritelock::new()","concurrent::rubyexchanger::new()","concurrent::rubyexchanger::node::new()","concurrent::rubyexecutorservice::new()","concurrent::rubysinglethreadexecutor::new()","concurrent::rubythreadpoolexecutor::new()","concurrent::rubythreadpoolexecutor::worker::new()","concurrent::safetaskexecutor::new()","concurrent::scheduledtask::new()","concurrent::serializedexecution::new()","concurrent::serializedexecutiondelegator::new()","concurrent::settablestruct::new()","concurrent::synchronization::abstractobject::new()","concurrent::synchronization::abstractstruct::new()","concurrent::synchronization::condition::new()","concurrent::synchronization::jrubyobject::new()","concurrent::synchronization::monitorlockableobject::new()","concurrent::synchronization::mriobject::new()","concurrent::synchronization::mutexlockableobject::new()","concurrent::synchronization::object::new()","concurrent::synchronization::object::new()","concurrent::synchronization::rbxlockableobject::new()","concurrent::synchronization::rbxobject::new()","concurrent::synchronization::trufflerubyobject::new()","concurrent::synchronizeddelegator::new()","concurrent::tvar::new()","concurrent::threadsafe::util::new()","concurrent::threadsafe::util::poweroftwotuple::new()","concurrent::threadsafe::util::striped64::new()","concurrent::timerset::new()","concurrent::timertask::new()","concurrent::transaction::new()","concurrent::tuple::new()","concurrent::utility::processorcounter::new()","concurrent::promises::blockedpromise::new_blocked_by()","concurrent::promises::blockedpromise::new_blocked_by1()","concurrent::promises::blockedpromise::new_blocked_by2()","concurrent::synchronization::lockableobject#new_condition()","concurrent::new_fast_executor()","concurrent::new_io_executor()","concurrent::threadsafe::util::poweroftwotuple#next_in_size_table()","concurrent::concern::obligation#no_error!()","concurrent::maybe::nothing()","concurrent::maybe#nothing?()","concurrent::collection::copyonnotifyobserverset#notify_and_delete_observers()","concurrent::collection::copyonwriteobserverset#notify_and_delete_observers()","concurrent::promise#notify_child()","concurrent::collection::copyonnotifyobserverset#notify_observers()","concurrent::collection::copyonwriteobserverset#notify_observers()","concurrent::ivar#notify_observers()","concurrent::collection::copyonnotifyobserverset#notify_to()","concurrent::collection::copyonwriteobserverset#notify_to()","concurrent::rubythreadpoolexecutor#ns_add_busy_worker()","concurrent::rubythreadpoolexecutor#ns_assign_worker()","concurrent::abstractexecutorservice#ns_auto_terminate=()","concurrent::abstractexecutorservice#ns_auto_terminate?()","concurrent::synchronization::abstractlockableobject#ns_broadcast()","concurrent::synchronization::condition#ns_broadcast()","concurrent::synchronization::conditionsignalling#ns_broadcast()","concurrent::synchronization::rbxlockableobject#ns_broadcast()","concurrent::concern::obligation#ns_check_state?()","concurrent::ivar#ns_complete_without_notification()","concurrent::synchronization::abstractstruct#ns_each()","concurrent::synchronization::abstractstruct#ns_each_pair()","concurrent::rubythreadpoolexecutor#ns_enqueue()","concurrent::agent#ns_enqueue_job()","concurrent::synchronization::abstractstruct#ns_equality()","concurrent::abstractexecutorservice#ns_execute()","concurrent::rubythreadpoolexecutor#ns_execute()","concurrent::agent#ns_find_last_job_for_thread()","concurrent::cyclicbarrier#ns_generation_done()","concurrent::synchronization::abstractstruct#ns_get()","concurrent::agent#ns_initialize()","concurrent::atexitimplementation#ns_initialize()","concurrent::cachedthreadpool#ns_initialize()","concurrent::collection::copyonnotifyobserverset#ns_initialize()","concurrent::collection::copyonwriteobserverset#ns_initialize()","concurrent::cyclicbarrier#ns_initialize()","concurrent::delay#ns_initialize()","concurrent::event#ns_initialize()","concurrent::future#ns_initialize()","concurrent::ivar#ns_initialize()","concurrent::javasinglethreadexecutor#ns_initialize()","concurrent::javathreadpoolexecutor#ns_initialize()","concurrent::mutexatomicboolean#ns_initialize()","concurrent::mutexatomicfixnum#ns_initialize()","concurrent::mutexatomicreference#ns_initialize()","concurrent::mutexcountdownlatch#ns_initialize()","concurrent::mutexsemaphore#ns_initialize()","concurrent::promise#ns_initialize()","concurrent::rubythreadpoolexecutor#ns_initialize()","concurrent::serializedexecution#ns_initialize()","concurrent::simpleexecutorservice#ns_initialize()","concurrent::synchronization::abstractstruct#ns_initialize()","concurrent::timerset#ns_initialize()","concurrent::timertask#ns_initialize()","concurrent::synchronization::abstractstruct#ns_inspect()","concurrent::abstractexecutorservice#ns_kill_execution()","concurrent::rubythreadpoolexecutor#ns_kill_execution()","concurrent::timertask#ns_kill_execution()","concurrent::rubythreadpoolexecutor#ns_limited_queue?()","concurrent::mutexatomicboolean#ns_make_value()","concurrent::synchronization::abstractstruct#ns_merge()","concurrent::cyclicbarrier#ns_next_generation()","concurrent::agent#ns_post_next_job()","concurrent::timerset#ns_post_task()","concurrent::rubythreadpoolexecutor#ns_prune_pool()","concurrent::rubythreadpoolexecutor#ns_ready_worker()","concurrent::rubythreadpoolexecutor#ns_remove_busy_worker()","concurrent::scheduledtask#ns_reschedule()","concurrent::rubythreadpoolexecutor#ns_reset_if_forked()","concurrent::timerset#ns_reset_if_forked()","concurrent::javaexecutorservice#ns_running?()","concurrent::rubyexecutorservice#ns_running?()","concurrent::scheduledtask#ns_schedule()","concurrent::synchronization::abstractstruct#ns_select()","concurrent::event#ns_set()","concurrent::mutexatomicfixnum#ns_set()","concurrent::concern::dereferenceable#ns_set_deref_options()","concurrent::concern::obligation#ns_set_state()","concurrent::javaexecutorservice#ns_shutdown?()","concurrent::rubyexecutorservice#ns_shutdown?()","concurrent::abstractexecutorservice#ns_shutdown_execution()","concurrent::rubyexecutorservice#ns_shutdown_execution()","concurrent::rubythreadpoolexecutor#ns_shutdown_execution()","concurrent::timerset#ns_shutdown_execution()","concurrent::timertask#ns_shutdown_execution()","concurrent::javaexecutorservice#ns_shuttingdown?()","concurrent::rubyexecutorservice#ns_shuttingdown?()","concurrent::synchronization::abstractlockableobject#ns_signal()","concurrent::synchronization::condition#ns_signal()","concurrent::synchronization::conditionsignalling#ns_signal()","concurrent::synchronization::rbxlockableobject#ns_signal()","concurrent::synchronization::abstractstruct#ns_to_h()","concurrent::agent#ns_validate()","concurrent::synchronization::abstractstruct#ns_values()","concurrent::synchronization::abstractstruct#ns_values_at()","concurrent::synchronization::abstractlockableobject#ns_wait()","concurrent::synchronization::condition#ns_wait()","concurrent::synchronization::monitorlockableobject#ns_wait()","concurrent::synchronization::mutexlockableobject#ns_wait()","concurrent::synchronization::rbxlockableobject#ns_wait()","concurrent::synchronization::abstractlockableobject#ns_wait_until()","concurrent::synchronization::condition#ns_wait_until()","concurrent::rubythreadpoolexecutor#ns_worker_died()","concurrent::rubythreadpoolexecutor#ns_worker_not_old_enough()","concurrent::cyclicbarrier#number_waiting()","concurrent::collection::copyonwriteobserverset#observers()","concurrent::collection::copyonwriteobserverset#observers=()","concurrent::lockfreestack::of1()","concurrent::lockfreestack::of2()","concurrent::promises::blockedpromise#on_blocker_resolution()","concurrent::utility::enginedetector#on_cruby?()","concurrent::promise#on_error()","concurrent::promise#on_fulfill()","concurrent::promises::future#on_fulfillment()","concurrent::promises::future#on_fulfillment!()","concurrent::promises::future#on_fulfillment_using()","concurrent::utility::enginedetector#on_jruby?()","concurrent::utility::enginedetector#on_jruby_9000?()","concurrent::utility::enginedetector#on_linux?()","concurrent::utility::enginedetector#on_osx?()","concurrent::utility::enginedetector#on_rbx?()","concurrent::promise#on_reject()","concurrent::promises::future#on_rejection()","concurrent::promises::future#on_rejection!()","concurrent::promises::future#on_rejection_using()","concurrent::promises::abstracteventfuture#on_resolution()","concurrent::promises::abstracteventfuture#on_resolution!()","concurrent::promises::abstracteventfuture#on_resolution_using()","concurrent::promises::abstractflatpromise#on_resolvable()","concurrent::promises::anyresolvedeventpromise#on_resolvable()","concurrent::promises::anyresolvedfuturepromise#on_resolvable()","concurrent::promises::blockedpromise#on_resolvable()","concurrent::promises::chainpromise#on_resolvable()","concurrent::promises::eventwrapperpromise#on_resolvable()","concurrent::promises::futurewrapperpromise#on_resolvable()","concurrent::promises::rescuepromise#on_resolvable()","concurrent::promises::thenpromise#on_resolvable()","concurrent::promises::zipeventeventpromise#on_resolvable()","concurrent::promises::zipeventspromise#on_resolvable()","concurrent::promises::zipfutureeventpromise#on_resolvable()","concurrent::promises::zipfuturespromise#on_resolvable()","concurrent::promise#on_success()","concurrent::utility::enginedetector#on_truffleruby?()","concurrent::utility::enginedetector#on_windows?()","concurrent::maybe#or()","concurrent::collection::rubynonconcurrentpriorityqueue#ordered?()","concurrent::threadsafe::util::striped64::cell::padding()","concurrent::collection::nonconcurrentmapbackend#pair?()","concurrent::cyclicbarrier#parties()","concurrent::collection::javanonconcurrentpriorityqueue#peek()","concurrent::collection::rubynonconcurrentpriorityqueue#peek()","concurrent::lockfreestack#peek()","concurrent::concern::obligation#pending?()","concurrent::promises::abstracteventfuture#pending?()","concurrent::async::asyncdelegator#perform()","concurrent::physical_processor_count()","concurrent::utility::processorcounter#physical_processor_count()","concurrent::collection::javanonconcurrentpriorityqueue#pop()","concurrent::collection::rubynonconcurrentpriorityqueue#pop()","concurrent::lockfreestack#pop()","concurrent::map#populate_from()","concurrent::agent#post()","concurrent::executorservice#post()","concurrent::immediateexecutor#post()","concurrent::indirectimmediateexecutor#post()","concurrent::javaexecutorservice#post()","concurrent::rubyexecutorservice#post()","concurrent::serializedexecution#post()","concurrent::serializedexecutiondelegator#post()","concurrent::simpleexecutorservice#post()","concurrent::simpleexecutorservice::post()","concurrent::timerset#post()","concurrent::timerset#post_task()","concurrent::serializedexecution#posts()","concurrent::synchronization::abstractstruct#pr_underscore()","concurrent::promises::blockedpromise#process_on_blocker_resolution()","concurrent::promises::flateventpromise#process_on_blocker_resolution()","concurrent::promises::flatfuturepromise#process_on_blocker_resolution()","concurrent::promises::runfuturepromise#process_on_blocker_resolution()","concurrent::promises::zipfutureeventpromise#process_on_blocker_resolution()","concurrent::promises::zipfuturespromise#process_on_blocker_resolution()","concurrent::scheduledtask#process_task()","concurrent::timerset#process_tasks()","concurrent::scheduledtask#processing?()","concurrent::processor_count()","concurrent::utility::processorcounter#processor_count()","concurrent::promises::abstracteventfuture#promise()","concurrent::collection::atomicreferencemapbackend::node#pure_hash()","concurrent::collection::javanonconcurrentpriorityqueue#push()","concurrent::collection::rubynonconcurrentpriorityqueue#push()","concurrent::lockfreestack#push()","concurrent::mvar#put()","concurrent::map#put_if_absent()","concurrent::javathreadpoolexecutor#queue_length()","concurrent::rubythreadpoolexecutor#queue_length()","concurrent::map#raise_fetch_no_key()","concurrent::transaction#read()","concurrent::rubythreadpoolexecutor#ready_worker()","concurrent::promise#realize()","concurrent::concern::obligation#realized?()","concurrent::agent#reason()","concurrent::concern::obligation#reason()","concurrent::promises::future#reason()","concurrent::promises::internalstates::fulfilled#reason()","concurrent::promises::internalstates::partiallyrejected#reason()","concurrent::promises::internalstates::rejected#reason()","concurrent::promises::internalstates::resolvedwithresult#reason()","concurrent::promises::resolvablefuture#reason()","concurrent::collection::atomicreferencemapbackend#rebuild()","concurrent::delay#reconfigure()","concurrent::mutexsemaphore#reduce_permits()","concurrent::promise::reject()","concurrent::promises::resolvablefuture#reject()","concurrent::concern::obligation#rejected?()","concurrent::maybe#rejected?()","concurrent::promises::future#rejected?()","concurrent::promises::factorymethods#rejected_future()","concurrent::promises::event#rejected_resolution()","concurrent::promises::future#rejected_resolution()","concurrent::mutexsemaphore#release()","concurrent::readwritelock#release_read_lock()","concurrent::reentrantreadwritelock#release_read_lock()","concurrent::readwritelock#release_write_lock()","concurrent::reentrantreadwritelock#release_write_lock()","concurrent::javathreadpoolexecutor#remaining_capacity()","concurrent::rubythreadpoolexecutor#remaining_capacity()","concurrent::rubythreadpoolexecutor#remove_busy_worker()","concurrent::timerset#remove_task()","concurrent::lockfreestack#replace_if()","concurrent::collection::atomicreferencemapbackend#replace_if_exists()","concurrent::collection::mrimapbackend#replace_if_exists()","concurrent::collection::nonconcurrentmapbackend#replace_if_exists()","concurrent::collection::synchronizedmapbackend#replace_if_exists()","concurrent::collection::atomicreferencemapbackend#replace_pair()","concurrent::collection::mrimapbackend#replace_pair()","concurrent::collection::nonconcurrentmapbackend#replace_pair()","concurrent::collection::synchronizedmapbackend#replace_pair()","concurrent::scheduledtask#reschedule()","concurrent::promise#rescue()","concurrent::promises::future#rescue()","concurrent::promises::future#rescue_on()","concurrent::atom#reset()","concurrent::cyclicbarrier#reset()","concurrent::event#reset()","concurrent::scheduledtask#reset()","concurrent::threadsafe::util::adder#reset()","concurrent::promises::abstractflatpromise#resolvable?()","concurrent::promises::anyfulfilledfuturepromise#resolvable?()","concurrent::promises::anyresolvedeventpromise#resolvable?()","concurrent::promises::anyresolvedfuturepromise#resolvable?()","concurrent::promises::blockedpromise#resolvable?()","concurrent::promises::factorymethods#resolvable_event()","concurrent::promises::factorymethods#resolvable_event_on()","concurrent::promises::factorymethods#resolvable_future()","concurrent::promises::factorymethods#resolvable_future_on()","concurrent::promises::resolvableevent#resolve()","concurrent::promises::resolvablefuture#resolve()","concurrent::promises::abstracteventfuture#resolve_with()","concurrent::promises::abstractpromise#resolve_with()","concurrent::promises::abstracteventfuture#resolved?()","concurrent::promises::internalstates::pending#resolved?()","concurrent::promises::internalstates::resolvedwithresult#resolved?()","concurrent::promises::internalstates::state#resolved?()","concurrent::promises::factorymethods#resolved_event()","concurrent::promises::factorymethods#resolved_future()","concurrent::async::asyncdelegator#respond_to_missing?()","concurrent::async::awaitdelegator#respond_to_missing?()","concurrent::agent#restart()","concurrent::promises::future#result()","concurrent::promises::internalstates::resolvedwithresult#result()","concurrent::promises::resolvablefuture#result()","concurrent::threadsafe::util::striped64#retry_update()","concurrent::utility::enginedetector#ruby_engine()","concurrent::utility::enginedetector#ruby_version()","concurrent::atexitimplementation#run()","concurrent::javaexecutorservice::job#run()","concurrent::promises::future#run()","concurrent::rubythreadpoolexecutor::worker#run_task()","concurrent::promises::future#run_test()","concurrent::atexitimplementation#runner()","concurrent::abstractexecutorservice#running?()","concurrent::immediateexecutor#running?()","concurrent::javathreadpoolexecutor#running?()","concurrent::simpleexecutorservice#running?()","concurrent::timertask#running?()","concurrent::readwritelock#running_readers()","concurrent::reentrantreadwritelock#running_readers()","concurrent::readwritelock#running_readers?()","concurrent::reentrantreadwritelock#running_readers?()","concurrent::readwritelock#running_writer?()","concurrent::reentrantreadwritelock#running_writer?()","concurrent::ivar#safe_execute()","concurrent::synchronization::object::safe_initialization!()","concurrent::synchronization::object::safe_initialization?()","concurrent::promises::event#schedule()","concurrent::promises::factorymethods#schedule()","concurrent::promises::future#schedule()","concurrent::timertask#schedule_next_task()","concurrent::promises::factorymethods#schedule_on()","concurrent::scheduledtask#schedule_time()","concurrent::javathreadpoolexecutor#scheduled_task_count()","concurrent::rubythreadpoolexecutor#scheduled_task_count()","concurrent::immutablestruct#select()","concurrent::mutablestruct#select()","concurrent::settablestruct#select()","concurrent::agent#send()","concurrent::agent#send!()","concurrent::agent#send_off()","concurrent::agent#send_off!()","concurrent::agent#send_via()","concurrent::agent#send_via!()","concurrent::executorservice#serialized?()","concurrent::serialexecutorservice#serialized?()","concurrent::atomicmarkablereference#set()","concurrent::event#set()","concurrent::future#set()","concurrent::ivar#set()","concurrent::mutexatomicreference#set()","concurrent::promise#set()","concurrent::tuple#set()","concurrent::mvar#set!()","concurrent::event#set?()","concurrent::utility::nativeextensionloader#set_c_extensions_loaded()","concurrent::concern::dereferenceable#set_deref_options()","concurrent::utility::nativeextensionloader#set_java_extensions_loaded()","concurrent::promise#set_pending()","concurrent::concern::obligation#set_state()","concurrent::promise#set_state!()","concurrent::rubythreadlocalvar#set_threadlocal_array()","concurrent::synchronizeddelegator#setup()","concurrent::collection::javanonconcurrentpriorityqueue#shift()","concurrent::collection::rubynonconcurrentpriorityqueue#shift()","concurrent::abstractexecutorservice#shutdown()","concurrent::immediateexecutor#shutdown()","concurrent::javaexecutorservice#shutdown()","concurrent::rubyexecutorservice#shutdown()","concurrent::simpleexecutorservice#shutdown()","concurrent::abstractexecutorservice#shutdown?()","concurrent::immediateexecutor#shutdown?()","concurrent::simpleexecutorservice#shutdown?()","concurrent::abstractexecutorservice#shuttingdown?()","concurrent::immediateexecutor#shuttingdown?()","concurrent::simpleexecutorservice#shuttingdown?()","concurrent::synchronization::condition#signal()","concurrent::synchronization::lock#signal()","concurrent::collection::rubynonconcurrentpriorityqueue#sink()","concurrent::collection::atomicreferencemapbackend#size()","concurrent::collection::javanonconcurrentpriorityqueue#size()","concurrent::collection::nonconcurrentmapbackend#size()","concurrent::collection::rubynonconcurrentpriorityqueue#size()","concurrent::collection::synchronizedmapbackend#size()","concurrent::map#size()","concurrent::synchronization::abstractstruct#size()","concurrent::collection::atomicreferencemapbackend#split_bin()","concurrent::collection::atomicreferencemapbackend#split_old_bin()","concurrent::concern::obligation#state()","concurrent::promises::abstracteventfuture#state()","concurrent::promises::abstractpromise#state()","concurrent::concern::obligation#state=()","concurrent::rubythreadpoolexecutor::worker#stop()","concurrent::rubyexecutorservice#stop_event()","concurrent::agent#stopped?()","concurrent::rubyexecutorservice#stopped_event()","concurrent::collection::nonconcurrentmapbackend#store_computed_value()","concurrent::threadsafe::util::adder#sum()","concurrent::atom#swap()","concurrent::collection::rubynonconcurrentpriorityqueue#swap()","concurrent::mutexatomicreference#swap()","concurrent::collection::rubynonconcurrentpriorityqueue#swim()","concurrent::mvar#synchronize()","concurrent::synchronization::abstractlockableobject#synchronize()","concurrent::synchronization::monitorlockableobject#synchronize()","concurrent::synchronization::mutexlockableobject#synchronize()","concurrent::synchronization::rbxlockableobject#synchronize()","truffleruby::synchronized()","concurrent::promise#synchronized_set_state!()","concurrent::collection::atomicreferencemapbackend#table_size_for()","concurrent::mvar#take()","concurrent::promises::abstracteventfuture#tangle()","concurrent::synchronizeddelegator#teardown()","concurrent::abstractexecutorservice#terminate_at_exit()","concurrent::promise#then()","concurrent::promises::future#then()","concurrent::promises::future#then_on()","concurrent::rubythreadlocalvar::thread_finalizer()","concurrent::rubythreadlocalvar::threadlocal_finalizer()","concurrent::timertask#timeout_interval()","concurrent::timertask#timeout_interval=()","concurrent::timertask#timeout_task()","concurrent::immutablestruct#to_a()","concurrent::mutablestruct#to_a()","concurrent::settablestruct#to_a()","concurrent::promises::event#to_event()","concurrent::promises::future#to_event()","concurrent::promises::event#to_future()","concurrent::promises::future#to_future()","concurrent::immutablestruct#to_h()","concurrent::mutablestruct#to_h()","concurrent::settablestruct#to_h()","atomicreference#to_s()","concurrent::atomicboolean#to_s()","concurrent::atomicfixnum#to_s()","concurrent::immutablestruct#to_s()","concurrent::lockfreestack#to_s()","concurrent::mutablestruct#to_s()","concurrent::promises::abstracteventfuture#to_s()","concurrent::promises::abstractpromise#to_s()","concurrent::promises::future#to_s()","concurrent::settablestruct#to_s()","concurrent::promises::internalstates::fulfilled#to_sym()","concurrent::promises::internalstates::partiallyrejected#to_sym()","concurrent::promises::internalstates::pending#to_sym()","concurrent::promises::internalstates::rejected#to_sym()","concurrent::promises::internalstates::resolvedwithresult#to_sym()","concurrent::promises::internalstates::state#to_sym()","concurrent::promises::abstracteventfuture#touch()","concurrent::promises::abstractflatpromise#touch()","concurrent::promises::abstractpromise#touch()","concurrent::promises::blockedpromise#touch()","concurrent::promises::delaypromise#touch()","concurrent::promises::abstracteventfuture#touched?()","concurrent::promises::abstractflatpromise#touched?()","concurrent::mutexatomicboolean#true?()","concurrent::event#try?()","concurrent::mutexsemaphore#try_acquire()","concurrent::mutexsemaphore#try_acquire_now()","concurrent::mutexsemaphore#try_acquire_timed()","concurrent::collection::atomicreferencemapbackend#try_await_lock()","concurrent::collection::atomicreferencemapbackend::node#try_await_lock()","concurrent::abstractexchanger#try_exchange()","concurrent::threadsafe::util::striped64#try_in_busy()","concurrent::collection::atomicreferencemapbackend#try_in_resize_lock()","concurrent::threadsafe::util::striped64#try_initialize_cells()","concurrent::utility::nativeextensionloader#try_load_c_extension()","concurrent::collection::atomicreferencemapbackend::node#try_lock_via_hash()","concurrent::collection::atomicreferencemapbackend::table#try_lock_via_hash()","concurrent::mvar#try_put!()","concurrent::reentrantreadwritelock#try_read_lock()","concurrent::ivar#try_set()","concurrent::mvar#try_take!()","concurrent::collection::atomicreferencemapbackend::table#try_to_cas_in_computed()","concurrent::threadsafe::util::striped64#try_to_install_new_cell()","concurrent::atomicdirectupdate#try_update()","concurrent::atomicmarkablereference#try_update()","concurrent::atomicdirectupdate#try_update!()","concurrent::atomicmarkablereference#try_update!()","concurrent::reentrantreadwritelock#try_write_lock()","concurrent::transaction#unlock()","concurrent::collection::atomicreferencemapbackend::node#unlock_via_hash()","concurrent::mvar#unlocked_empty?()","concurrent::mvar#unlocked_full?()","concurrent::concern::obligation#unscheduled?()","concurrent::mutexatomicfixnum#up()","concurrent::atomicdirectupdate#update()","concurrent::atomicmarkablereference#update()","concurrent::mutexatomicfixnum#update()","concurrent::use_simple_logger()","concurrent::use_stdlib_logger()","concurrent::atom#valid?()","concurrent::transaction#valid?()","concurrent::async::validate_argc()","concurrent::map#validate_options_hash!()","concurrent::abstractthreadlocalvar#value()","concurrent::agent#value()","concurrent::atomicmarkablereference#value()","concurrent::concern::dereferenceable#value()","concurrent::concern::obligation#value()","concurrent::delay#value()","concurrent::javathreadlocalvar#value()","concurrent::mutexatomicboolean#value()","concurrent::mutexatomicfixnum#value()","concurrent::mutexatomicreference#value()","concurrent::promises::future#value()","concurrent::promises::internalstates::fulfilled#value()","concurrent::promises::internalstates::partiallyrejected#value()","concurrent::promises::internalstates::rejected#value()","concurrent::promises::internalstates::resolvedwithresult#value()","concurrent::promises::resolvablefuture#value()","concurrent::rubythreadlocalvar#value()","concurrent::tvar#value()","concurrent::concern::obligation#value!()","concurrent::delay#value!()","concurrent::promises::future#value!()","concurrent::promises::resolvablefuture#value!()","concurrent::abstractthreadlocalvar#value=()","concurrent::concern::dereferenceable#value=()","concurrent::javathreadlocalvar#value=()","concurrent::mutexatomicboolean#value=()","concurrent::mutexatomicfixnum#value=()","concurrent::mutexatomicreference#value=()","concurrent::rubythreadlocalvar#value=()","concurrent::tvar#value=()","concurrent::map#value?()","concurrent::rubythreadlocalvar#value_for()","concurrent::immutablestruct#values()","concurrent::map#values()","concurrent::mutablestruct#values()","concurrent::settablestruct#values()","concurrent::immutablestruct#values_at()","concurrent::mutablestruct#values_at()","concurrent::settablestruct#values_at()","concurrent::tuple#volatile_get()","concurrent::threadsafe::util::poweroftwotuple#volatile_get_by_hash()","concurrent::tuple#volatile_set()","concurrent::threadsafe::util::poweroftwotuple#volatile_set_by_hash()","concurrent::agent#wait()","concurrent::concern::obligation#wait()","concurrent::cyclicbarrier#wait()","concurrent::delay#wait()","concurrent::event#wait()","concurrent::javacountdownlatch#wait()","concurrent::mutexcountdownlatch#wait()","concurrent::promises::abstracteventfuture#wait()","concurrent::promises::resolvableevent#wait()","concurrent::promises::resolvablefuture#wait()","concurrent::synchronization::condition#wait()","concurrent::synchronization::lock#wait()","concurrent::concern::obligation#wait!()","concurrent::promises::future#wait!()","concurrent::promises::resolvablefuture#wait!()","concurrent::mvar#wait_for_empty()","concurrent::mvar#wait_for_full()","concurrent::abstractexecutorservice#wait_for_termination()","concurrent::immediateexecutor#wait_for_termination()","concurrent::javaexecutorservice#wait_for_termination()","concurrent::rubyexecutorservice#wait_for_termination()","concurrent::simpleexecutorservice#wait_for_termination()","concurrent::future#wait_or_cancel()","concurrent::synchronization::condition#wait_until()","concurrent::synchronization::lock#wait_until()","concurrent::promises::abstracteventfuture#wait_until_resolved()","concurrent::promises::future#wait_until_resolved!()","concurrent::mvar#wait_while()","concurrent::reentrantreadwritelock#waiting_or_running_writer?()","concurrent::promises::abstracteventfuture#waiting_threads()","concurrent::readwritelock#waiting_writer?()","concurrent::readwritelock#waiting_writers()","concurrent::reentrantreadwritelock#waiting_writers()","concurrent::promises::abstracteventfuture#with_async()","concurrent::promises::abstracteventfuture#with_default_executor()","concurrent::promises::event#with_default_executor()","concurrent::promises::future#with_default_executor()","concurrent::promises::abstracteventfuture#with_hidden_resolvable()","concurrent::promises::resolvableevent#with_hidden_resolvable()","concurrent::promises::resolvablefuture#with_hidden_resolvable()","concurrent::concern::observable#with_observer()","concurrent::readwritelock#with_read_lock()","concurrent::reentrantreadwritelock#with_read_lock()","concurrent::readwritelock#with_write_lock()","concurrent::reentrantreadwritelock#with_write_lock()","concurrent::serializedexecution#work()","concurrent::rubythreadpoolexecutor#worker_died()","concurrent::rubythreadpoolexecutor#worker_not_old_enough()","concurrent::rubythreadpoolexecutor#worker_task_completed()","concurrent::transaction#write()","concurrent::readwritelock#write_locked?()","concurrent::threadsafe::util::xorshiftrandom#xorshift()","concurrent::promise#zip()","concurrent::promise::zip()","concurrent::promises::event#zip()","concurrent::promises::factorymethods#zip()","concurrent::promises::future#zip()","concurrent::promises::factorymethods#zip_events()","concurrent::promises::factorymethods#zip_events_on()","concurrent::promises::factorymethods#zip_futures()","concurrent::promises::factorymethods#zip_futures_on()","concurrent::promises::event#|()","concurrent::promises::future#|()","","",""],"info":[["Array","","Array.html","","<p>@!macro concurrent_array\n"],["AtomicReference","","AtomicReference.html","","<p>@!macro atomic_reference\n"],["Concurrent","","Concurrent.html","","<p>{include:file:README.md}\n<p>@!macro thread_safe_variable_comparison\n\n<pre class=\"ruby\"><span class=\"ruby-comment\">## Thread-safe Variable Classes</span>\n\n<span class=\"ruby-constant\">Each</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["Concurrent::AbstractExchanger","","Concurrent/AbstractExchanger.html","","<p>@!visibility private\n"],["Concurrent::AbstractExecutorService","","Concurrent/AbstractExecutorService.html","","<p>@!macro abstract_executor_service_public_api @!visibility private\n"],["Concurrent::AbstractThreadLocalVar","","Concurrent/AbstractThreadLocalVar.html","","<p>@!macro thread_local_var @!macro internal_implementation_note @!visibility private\n"],["Concurrent::Agent","","Concurrent/Agent.html","","<p>`Agent` is inspired by Clojure&#39;s [agent](clojure.org/agents) function. An agent is a shared, mutable \n"],["Concurrent::Agent::Error","","Concurrent/Agent/Error.html","","<p>Raised during action processing or any other time in an Agent&#39;s lifecycle.\n"],["Concurrent::Agent::ValidationError","","Concurrent/Agent/ValidationError.html","","<p>Raised when a new value obtained during action processing or at `#restart` fails validation.\n"],["Concurrent::Async","","Concurrent/Async.html","","<p>A mixin module that provides simple asynchronous behavior to a class, turning it into a simple actor. \n"],["Concurrent::Async::AsyncDelegator","","Concurrent/Async/AsyncDelegator.html","","<p>Delegates asynchronous, thread-safe method calls to the wrapped object.\n<p>@!visibility private\n"],["Concurrent::Async::AwaitDelegator","","Concurrent/Async/AwaitDelegator.html","","<p>Delegates synchronous, thread-safe method calls to the wrapped object.\n<p>@!visibility private\n"],["Concurrent::Async::ClassMethods","","Concurrent/Async/ClassMethods.html","","<p>@!visibility private\n"],["Concurrent::AtExitImplementation","","Concurrent/AtExitImplementation.html","","<p>Provides ability to add and remove handlers to be run at `Kernel#at_exit`, order is undefined. Each handler \n"],["Concurrent::Atom","","Concurrent/Atom.html","","<p>Atoms provide a way to manage shared, synchronous, independent state.\n<p>An atom is initialized with an initial \n"],["Concurrent::AtomicBoolean","","Concurrent/AtomicBoolean.html","","<p>@!macro atomic_boolean\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">A</span> <span class=\"ruby-identifier\">boolean</span> <span class=\"ruby-identifier\">value</span> <span class=\"ruby-identifier\">that</span> <span class=\"ruby-identifier\">can</span> <span class=\"ruby-identifier\">be</span> <span class=\"ruby-identifier\">updated</span> <span class=\"ruby-identifier\">atomically</span>. <span class=\"ruby-constant\">Reads</span> <span class=\"ruby-keyword\">and</span> <span class=\"ruby-identifier\">writes</span> <span class=\"ruby-identifier\">to</span> <span class=\"ruby-identifier\">an</span> <span class=\"ruby-identifier\">atomic</span>\n<span class=\"ruby-identifier\">boolean</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["Concurrent::AtomicDirectUpdate","","Concurrent/AtomicDirectUpdate.html","","<p>Define update methods that use direct paths\n<p>@!visibility private @!macro internal_implementation_note \n"],["Concurrent::AtomicFixnum","","Concurrent/AtomicFixnum.html","","<p>@!macro atomic_fixnum\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">A</span> <span class=\"ruby-identifier\">numeric</span> <span class=\"ruby-identifier\">value</span> <span class=\"ruby-identifier\">that</span> <span class=\"ruby-identifier\">can</span> <span class=\"ruby-identifier\">be</span> <span class=\"ruby-identifier\">updated</span> <span class=\"ruby-identifier\">atomically</span>. <span class=\"ruby-constant\">Reads</span> <span class=\"ruby-keyword\">and</span> <span class=\"ruby-identifier\">writes</span> <span class=\"ruby-identifier\">to</span> <span class=\"ruby-identifier\">an</span> <span class=\"ruby-identifier\">atomic</span>\n<span class=\"ruby-identifier\">fixnum</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["Concurrent::AtomicMarkableReference","","Concurrent/AtomicMarkableReference.html","","<p>An atomic reference which maintains an object reference along with a mark bit that can be updated atomically. \n"],["Concurrent::AtomicNumericCompareAndSetWrapper","","Concurrent/AtomicNumericCompareAndSetWrapper.html","","<p>Special compare and set handling of numeric values.\n<p>@!visibility private @!macro internal_implementation_note \n"],["Concurrent::CachedThreadPool","","Concurrent/CachedThreadPool.html","","<p>A thread pool that dynamically grows and shrinks to fit the current workload. New threads are created \n"],["Concurrent::Collection","","Concurrent/Collection.html","","<p>@!visibility private\n<p>@!visibility private\n<p>@!visibility private\n"],["Concurrent::Collection::AtomicReferenceMapBackend","","Concurrent/Collection/AtomicReferenceMapBackend.html","","<p>A Ruby port of the Doug Lea&#39;s jsr166e.ConcurrentHashMapV8 class version 1.59 available in public \n"],["Concurrent::Collection::AtomicReferenceMapBackend::Node","","Concurrent/Collection/AtomicReferenceMapBackend/Node.html","","<p>Key-value entry. Nodes with a hash field of <code>MOVED</code> are special, and do not contain user keys or values. \n"],["Concurrent::Collection::AtomicReferenceMapBackend::Table","","Concurrent/Collection/AtomicReferenceMapBackend/Table.html","","<p>@!visibility private\n"],["Concurrent::Collection::CopyOnNotifyObserverSet","","Concurrent/Collection/CopyOnNotifyObserverSet.html","","<p>A thread safe observer set implemented using copy-on-read approach: observers are added and removed from \n"],["Concurrent::Collection::CopyOnWriteObserverSet","","Concurrent/Collection/CopyOnWriteObserverSet.html","","<p>A thread safe observer set implemented using copy-on-write approach: every time an observer is added \n"],["Concurrent::Collection::JavaNonConcurrentPriorityQueue","","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html","","<p>@!macro priority_queue\n<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Collection::MriMapBackend","","Concurrent/Collection/MriMapBackend.html","","<p>@!visibility private\n"],["Concurrent::Collection::NonConcurrentMapBackend","","Concurrent/Collection/NonConcurrentMapBackend.html","","<p>@!visibility private\n"],["Concurrent::Collection::NonConcurrentPriorityQueue","","Concurrent/Collection/NonConcurrentPriorityQueue.html","","<p>@!macro priority_queue\n\n<pre>A queue collection in which the elements are sorted based on their\ncomparison (spaceship) ...</pre>\n"],["Concurrent::Collection::RubyNonConcurrentPriorityQueue","","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html","","<p>@!macro priority_queue\n<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Collection::SynchronizedMapBackend","","Concurrent/Collection/SynchronizedMapBackend.html","","<p>@!visibility private\n"],["Concurrent::Concern","","Concurrent/Concern.html","",""],["Concurrent::Concern::Deprecation","","Concurrent/Concern/Deprecation.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Concern::Dereferenceable","","Concurrent/Concern/Dereferenceable.html","","<p>Object references in Ruby are mutable. This can lead to serious problems when the `#value` of a concurrent \n"],["Concurrent::Concern::Logging","","Concurrent/Concern/Logging.html","","<p>Include where logging is needed\n<p>@!visibility private\n"],["Concurrent::Concern::Obligation","","Concurrent/Concern/Obligation.html","",""],["Concurrent::Concern::Observable","","Concurrent/Concern/Observable.html","","<p>The [observer pattern](en.wikipedia.org/wiki/Observer_pattern) is one of the most useful design patterns. \n"],["Concurrent::ConcurrentUpdateError","","Concurrent/ConcurrentUpdateError.html","","<p>@!macro internal_implementation_note\n"],["Concurrent::CountDownLatch","","Concurrent/CountDownLatch.html","","<p>@!macro count_down_latch\n\n<pre>A synchronization object that allows one thread to wait on multiple other threads. ...</pre>\n"],["Concurrent::CyclicBarrier","","Concurrent/CyclicBarrier.html","","<p>A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier \n"],["Concurrent::Delay","","Concurrent/Delay.html","","<p>Lazy evaluation of a block yielding an immutable result. Useful for expensive operations that may never \n"],["Concurrent::DependencyCounter","","Concurrent/DependencyCounter.html","",""],["Concurrent::Event","","Concurrent/Event.html","","<p>Old school kernel-style event reminiscent of Win32 programming in C++.\n<p>When an `Event` is created it is \n"],["Concurrent::Exchanger","","Concurrent/Exchanger.html","","<p>@!macro exchanger\n"],["Concurrent::ExecutorService","","Concurrent/ExecutorService.html","","<p>@!macro executor_service_public_api @!visibility private\n"],["Concurrent::FixedThreadPool","","Concurrent/FixedThreadPool.html","","<p>@!macro fixed_thread_pool\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">A</span> <span class=\"ruby-identifier\">thread</span> <span class=\"ruby-identifier\">pool</span> <span class=\"ruby-identifier\">that</span> <span class=\"ruby-identifier\">reuses</span> <span class=\"ruby-identifier\">a</span> <span class=\"ruby-identifier\">fixed</span> <span class=\"ruby-identifier\">number</span> <span class=\"ruby-identifier\">of</span> <span class=\"ruby-identifier\">threads</span> <span class=\"ruby-identifier\">operating</span> <span class=\"ruby-identifier\">off</span> <span class=\"ruby-identifier\">an</span> <span class=\"ruby-identifier\">unbounded</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["Concurrent::Future","","Concurrent/Future.html","","<p>{include:file:docs-source/future.md}\n<p>@!macro copy_options\n<p>@see ruby-doc.org/stdlib-2.1.1/libdoc/observer/rdoc/Observable.html \n"],["Concurrent::IVar","","Concurrent/IVar.html","","<p>An `IVar` is like a future that you can assign. As a future is a value that is being computed that you \n"],["Concurrent::ImmediateExecutor","","Concurrent/ImmediateExecutor.html","","<p>An executor service which runs all operations on the current thread, blocking as necessary. Operations \n"],["Concurrent::ImmutableStruct","","Concurrent/ImmutableStruct.html","","<p>A thread-safe, immutable variation of Ruby&#39;s standard `Struct`.\n<p>@see ruby-doc.org/core-2.2.0/Struct.html \n"],["Concurrent::IndirectImmediateExecutor","","Concurrent/IndirectImmediateExecutor.html","","<p>An executor service which runs all operations on a new thread, blocking until it completes. Operations \n"],["Concurrent::JavaAtomicReference","","Concurrent/JavaAtomicReference.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::JavaCountDownLatch","","Concurrent/JavaCountDownLatch.html","","<p>@!macro count_down_latch @!visibility private @!macro internal_implementation_note\n"],["Concurrent::JavaExchanger","","Concurrent/JavaExchanger.html","","<p>@!macro internal_implementation_note @!visibility private\n"],["Concurrent::JavaExecutorService","","Concurrent/JavaExecutorService.html","","<p>@!macro abstract_executor_service_public_api @!visibility private\n"],["Concurrent::JavaExecutorService::Job","","Concurrent/JavaExecutorService/Job.html","",""],["Concurrent::JavaSingleThreadExecutor","","Concurrent/JavaSingleThreadExecutor.html","","<p>@!macro single_thread_executor @!macro abstract_executor_service_public_api @!visibility private\n"],["Concurrent::JavaThreadLocalVar","","Concurrent/JavaThreadLocalVar.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::JavaThreadPoolExecutor","","Concurrent/JavaThreadPoolExecutor.html","","<p>@!macro thread_pool_executor @!macro thread_pool_options @!visibility private\n"],["Concurrent::LockFreeStack","","Concurrent/LockFreeStack.html","","<p>@!macro warn.edge\n"],["Concurrent::LockFreeStack::Node","","Concurrent/LockFreeStack/Node.html","",""],["Concurrent::MVar","","Concurrent/MVar.html","","<p>An `MVar` is a synchronized single element container. They are empty or contain one item. Taking a value \n"],["Concurrent::Map","","Concurrent/Map.html","","<p>`Concurrent::Map` is a hash-like object and should have much better performance characteristics, especially \n"],["Concurrent::Maybe","","Concurrent/Maybe.html","","<p>A `Maybe` encapsulates an optional value. A `Maybe` either contains a value of (represented as `Just`), \n"],["Concurrent::MultipleAssignmentError","","Concurrent/MultipleAssignmentError.html","","<p>Raised when an attempt is made to modify an immutable object (such as an `IVar`) after its final state \n"],["Concurrent::MultipleErrors","","Concurrent/MultipleErrors.html","","<p>Aggregates multiple exceptions.\n"],["Concurrent::MutableStruct","","Concurrent/MutableStruct.html","","<p>An thread-safe variation of Ruby&#39;s standard `Struct`. Values can be set at construction or safely \n"],["Concurrent::MutexAtomicBoolean","","Concurrent/MutexAtomicBoolean.html","","<p>@!macro atomic_boolean @!visibility private @!macro internal_implementation_note\n"],["Concurrent::MutexAtomicFixnum","","Concurrent/MutexAtomicFixnum.html","","<p>@!macro atomic_fixnum @!visibility private @!macro internal_implementation_note\n"],["Concurrent::MutexAtomicReference","","Concurrent/MutexAtomicReference.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::MutexCountDownLatch","","Concurrent/MutexCountDownLatch.html","","<p>@!macro count_down_latch @!visibility private @!macro internal_implementation_note\n"],["Concurrent::MutexSemaphore","","Concurrent/MutexSemaphore.html","","<p>@!macro semaphore @!visibility private @!macro internal_implementation_note\n"],["Concurrent::Options","","Concurrent/Options.html","","<p>@!visibility private\n"],["Concurrent::Promise","","Concurrent/Promise.html","","<p>Promises are inspired by the JavaScript [Promises/A](wiki.commonjs.org/wiki/Promises/A) and [Promises/A+]( \n"],["Concurrent::Promises","","Concurrent/Promises.html","","<p>{include:file:docs-source/promises-main.md}\n"],["Concurrent::Promises::AbstractAnyPromise","","Concurrent/Promises/AbstractAnyPromise.html","","<p>@abstract\n"],["Concurrent::Promises::AbstractEventFuture","","Concurrent/Promises/AbstractEventFuture.html","","<p>Common ancestor of {Event} and {Future} classes, many shared methods are defined here.\n"],["Concurrent::Promises::AbstractFlatPromise","","Concurrent/Promises/AbstractFlatPromise.html","",""],["Concurrent::Promises::AbstractPromise","","Concurrent/Promises/AbstractPromise.html","","<p>@abstract @private\n"],["Concurrent::Promises::AnyFulfilledFuturePromise","","Concurrent/Promises/AnyFulfilledFuturePromise.html","",""],["Concurrent::Promises::AnyResolvedEventPromise","","Concurrent/Promises/AnyResolvedEventPromise.html","",""],["Concurrent::Promises::AnyResolvedFuturePromise","","Concurrent/Promises/AnyResolvedFuturePromise.html","",""],["Concurrent::Promises::BlockedPromise","","Concurrent/Promises/BlockedPromise.html","","<p>@abstract\n"],["Concurrent::Promises::BlockedTaskPromise","","Concurrent/Promises/BlockedTaskPromise.html","","<p>@abstract\n"],["Concurrent::Promises::ChainPromise","","Concurrent/Promises/ChainPromise.html","",""],["Concurrent::Promises::DelayPromise","","Concurrent/Promises/DelayPromise.html","",""],["Concurrent::Promises::Event","","Concurrent/Promises/Event.html","","<p>Represents an event which will happen in future (will be resolved). The event is either pending or resolved. \n"],["Concurrent::Promises::EventWrapperPromise","","Concurrent/Promises/EventWrapperPromise.html","",""],["Concurrent::Promises::FactoryMethods","","Concurrent/Promises/FactoryMethods.html","","<p>Container of all {Future}, {Event} factory methods. They are never constructed directly with new.\n"],["Concurrent::Promises::FactoryMethods::Configuration","","Concurrent/Promises/FactoryMethods/Configuration.html","",""],["Concurrent::Promises::FlatEventPromise","","Concurrent/Promises/FlatEventPromise.html","",""],["Concurrent::Promises::FlatFuturePromise","","Concurrent/Promises/FlatFuturePromise.html","",""],["Concurrent::Promises::Future","","Concurrent/Promises/Future.html","","<p>Represents a value which will become available in future. May reject with a reason instead, e.g. when \n"],["Concurrent::Promises::FutureWrapperPromise","","Concurrent/Promises/FutureWrapperPromise.html","",""],["Concurrent::Promises::ImmediateEventPromise","","Concurrent/Promises/ImmediateEventPromise.html","","<p>will be immediately resolved\n"],["Concurrent::Promises::ImmediateFuturePromise","","Concurrent/Promises/ImmediateFuturePromise.html","",""],["Concurrent::Promises::InnerPromise","","Concurrent/Promises/InnerPromise.html","","<p>@abstract\n"],["Concurrent::Promises::InternalStates","","Concurrent/Promises/InternalStates.html","",""],["Concurrent::Promises::InternalStates::Fulfilled","","Concurrent/Promises/InternalStates/Fulfilled.html","","<p>@!visibility private\n"],["Concurrent::Promises::InternalStates::FulfilledArray","","Concurrent/Promises/InternalStates/FulfilledArray.html","","<p>@!visibility private\n"],["Concurrent::Promises::InternalStates::PartiallyRejected","","Concurrent/Promises/InternalStates/PartiallyRejected.html","","<p>@!visibility private\n"],["Concurrent::Promises::InternalStates::Pending","","Concurrent/Promises/InternalStates/Pending.html","","<p>@!visibility private\n"],["Concurrent::Promises::InternalStates::Rejected","","Concurrent/Promises/InternalStates/Rejected.html","","<p>@!visibility private\n"],["Concurrent::Promises::InternalStates::Reserved","","Concurrent/Promises/InternalStates/Reserved.html","","<p>@!visibility private\n"],["Concurrent::Promises::InternalStates::ResolvedWithResult","","Concurrent/Promises/InternalStates/ResolvedWithResult.html","","<p>@!visibility private\n"],["Concurrent::Promises::InternalStates::State","","Concurrent/Promises/InternalStates/State.html","","<p>@!visibility private\n"],["Concurrent::Promises::RescuePromise","","Concurrent/Promises/RescuePromise.html","",""],["Concurrent::Promises::Resolvable","","Concurrent/Promises/Resolvable.html","","<p>Marker module of Future, Event resolved manually.\n"],["Concurrent::Promises::ResolvableEvent","","Concurrent/Promises/ResolvableEvent.html","","<p>A Event which can be resolved by user.\n"],["Concurrent::Promises::ResolvableEventPromise","","Concurrent/Promises/ResolvableEventPromise.html","",""],["Concurrent::Promises::ResolvableFuture","","Concurrent/Promises/ResolvableFuture.html","","<p>A Future which can be resolved by user.\n"],["Concurrent::Promises::ResolvableFuturePromise","","Concurrent/Promises/ResolvableFuturePromise.html","",""],["Concurrent::Promises::RunFuturePromise","","Concurrent/Promises/RunFuturePromise.html","",""],["Concurrent::Promises::ScheduledPromise","","Concurrent/Promises/ScheduledPromise.html","",""],["Concurrent::Promises::ThenPromise","","Concurrent/Promises/ThenPromise.html","",""],["Concurrent::Promises::ZipEventEventPromise","","Concurrent/Promises/ZipEventEventPromise.html","",""],["Concurrent::Promises::ZipEventsPromise","","Concurrent/Promises/ZipEventsPromise.html","",""],["Concurrent::Promises::ZipFutureEventPromise","","Concurrent/Promises/ZipFutureEventPromise.html","",""],["Concurrent::Promises::ZipFuturesPromise","","Concurrent/Promises/ZipFuturesPromise.html","",""],["Concurrent::RbxArray","","Concurrent/RbxArray.html","",""],["Concurrent::RbxAtomicReference","","Concurrent/RbxAtomicReference.html","","<p>@note Extends `Rubinius::AtomicReference` version adding aliases\n\n<pre>and numeric logic.</pre>\n<p>@!visibility private \n"],["Concurrent::RbxHash","","Concurrent/RbxHash.html","",""],["Concurrent::RbxSet","","Concurrent/RbxSet.html","",""],["Concurrent::ReInclude","","Concurrent/ReInclude.html","","<p>Methods form module A included to a module B, which is already included into class C, will not be visible \n"],["Concurrent::ReadWriteLock","","Concurrent/ReadWriteLock.html","","<p>Ruby read-write lock implementation\n<p>Allows any number of concurrent readers, but only one concurrent writer \n"],["Concurrent::ReentrantReadWriteLock","","Concurrent/ReentrantReadWriteLock.html","","<p>Re-entrant read-write lock implementation\n<p>Allows any number of concurrent readers, but only one concurrent \n"],["Concurrent::RubyExchanger","","Concurrent/RubyExchanger.html","","<p>@!macro internal_implementation_note @!visibility private\n"],["Concurrent::RubyExchanger::Node","","Concurrent/RubyExchanger/Node.html","",""],["Concurrent::RubyExecutorService","","Concurrent/RubyExecutorService.html","","<p>@!macro abstract_executor_service_public_api @!visibility private\n"],["Concurrent::RubySingleThreadExecutor","","Concurrent/RubySingleThreadExecutor.html","","<p>@!macro single_thread_executor @!macro abstract_executor_service_public_api @!visibility private\n"],["Concurrent::RubyThreadLocalVar","","Concurrent/RubyThreadLocalVar.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::RubyThreadPoolExecutor","","Concurrent/RubyThreadPoolExecutor.html","","<p>@!macro thread_pool_executor @!macro thread_pool_options @!visibility private\n"],["Concurrent::RubyThreadPoolExecutor::Worker","","Concurrent/RubyThreadPoolExecutor/Worker.html","","<p>@!visibility private\n"],["Concurrent::SafeTaskExecutor","","Concurrent/SafeTaskExecutor.html","","<p>A simple utility class that executes a callable and returns and array of three elements: success - indicating \n"],["Concurrent::ScheduledTask","","Concurrent/ScheduledTask.html","","<p>`ScheduledTask` is a close relative of `Concurrent::Future` but with one important difference: A `Future` \n"],["Concurrent::Semaphore","","Concurrent/Semaphore.html","","<p>@!macro semaphore\n\n<pre>A counting semaphore. Conceptually, a semaphore maintains a set of\npermits. Each {#acquire} ...</pre>\n"],["Concurrent::SerialExecutorService","","Concurrent/SerialExecutorService.html","","<p>Indicates that the including `ExecutorService` guarantees that all operations will occur in the order \n"],["Concurrent::SerializedExecution","","Concurrent/SerializedExecution.html","","<p>Ensures passed jobs in a serialized order never running at the same time.\n"],["Concurrent::SerializedExecutionDelegator","","Concurrent/SerializedExecutionDelegator.html","","<p>A wrapper/delegator for any `ExecutorService` that guarantees serialized execution of tasks.\n<p>@see [SimpleDelegator]( \n"],["Concurrent::SettableStruct","","Concurrent/SettableStruct.html","","<p>An thread-safe, write-once variation of Ruby&#39;s standard `Struct`. Each member can have its value \n"],["Concurrent::SimpleExecutorService","","Concurrent/SimpleExecutorService.html","","<p>An executor service in which every operation spawns a new, independently operating thread.\n<p>This is perhaps \n"],["Concurrent::SingleThreadExecutor","","Concurrent/SingleThreadExecutor.html","","<p>@!macro single_thread_executor\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">A</span> <span class=\"ruby-identifier\">thread</span> <span class=\"ruby-identifier\">pool</span> <span class=\"ruby-identifier\">with</span> <span class=\"ruby-identifier\">a</span> <span class=\"ruby-identifier\">single</span> <span class=\"ruby-identifier\">thread</span> <span class=\"ruby-identifier\">an</span> <span class=\"ruby-identifier\">unlimited</span> <span class=\"ruby-identifier\">queue</span>. <span class=\"ruby-constant\">Should</span> <span class=\"ruby-identifier\">the</span> <span class=\"ruby-identifier\">thread</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["Concurrent::Synchronization","","Concurrent/Synchronization.html","","<p>{include:file:docs-source/synchronization.md} {include:file:docs-source/synchronization-notes.md}\n<p>noinspection \n"],["Concurrent::Synchronization::AbstractLockableObject","","Concurrent/Synchronization/AbstractLockableObject.html","","<p>@!visibility private\n"],["Concurrent::Synchronization::AbstractObject","","Concurrent/Synchronization/AbstractObject.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Synchronization::AbstractStruct","","Concurrent/Synchronization/AbstractStruct.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Synchronization::Condition","","Concurrent/Synchronization/Condition.html","","<p>@!visibility private TODO (pitr-ch 04-Dec-2016): should be in edge\n"],["Concurrent::Synchronization::ConditionSignalling","","Concurrent/Synchronization/ConditionSignalling.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Synchronization::JRubyAttrVolatile","","Concurrent/Synchronization/JRubyAttrVolatile.html","","<p>@!visibility private\n"],["Concurrent::Synchronization::JRubyAttrVolatile::ClassMethods","","Concurrent/Synchronization/JRubyAttrVolatile/ClassMethods.html","",""],["Concurrent::Synchronization::JRubyLockableObject","","Concurrent/Synchronization/JRubyLockableObject.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Synchronization::JRubyObject","","Concurrent/Synchronization/JRubyObject.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Synchronization::Lock","","Concurrent/Synchronization/Lock.html","","<p>@!visibility private TODO (pitr-ch 04-Dec-2016): should be in edge\n"],["Concurrent::Synchronization::LockableObject","","Concurrent/Synchronization/LockableObject.html","","\n<pre>Safe synchronization under any Ruby implementation.\nIt provides methods like {#synchronize}, {#wait}, ...</pre>\n"],["Concurrent::Synchronization::MonitorLockableObject","","Concurrent/Synchronization/MonitorLockableObject.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Synchronization::MriAttrVolatile","","Concurrent/Synchronization/MriAttrVolatile.html","","<p>@!visibility private\n"],["Concurrent::Synchronization::MriAttrVolatile::ClassMethods","","Concurrent/Synchronization/MriAttrVolatile/ClassMethods.html","",""],["Concurrent::Synchronization::MriObject","","Concurrent/Synchronization/MriObject.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Synchronization::MutexLockableObject","","Concurrent/Synchronization/MutexLockableObject.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Synchronization::Object","","Concurrent/Synchronization/Object.html","","<p>Abstract object providing final, volatile, ans CAS extensions to build other concurrent abstractions. \n"],["Concurrent::Synchronization::RbxAttrVolatile","","Concurrent/Synchronization/RbxAttrVolatile.html","","<p>@!visibility private\n"],["Concurrent::Synchronization::RbxAttrVolatile::ClassMethods","","Concurrent/Synchronization/RbxAttrVolatile/ClassMethods.html","",""],["Concurrent::Synchronization::RbxLockableObject","","Concurrent/Synchronization/RbxLockableObject.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Synchronization::RbxObject","","Concurrent/Synchronization/RbxObject.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Synchronization::TruffleRubyAttrVolatile","","Concurrent/Synchronization/TruffleRubyAttrVolatile.html","","<p>@!visibility private\n"],["Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods","","Concurrent/Synchronization/TruffleRubyAttrVolatile/ClassMethods.html","",""],["Concurrent::Synchronization::TruffleRubyObject","","Concurrent/Synchronization/TruffleRubyObject.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::SynchronizedDelegator","","Concurrent/SynchronizedDelegator.html","","<p>This class provides a trivial way to synchronize all calls to a given object by wrapping it with a `Delegator` \n"],["Concurrent::TVar","","Concurrent/TVar.html","","<p>A `TVar` is a transactional variable - a single-element container that is used as part of a transaction \n"],["Concurrent::ThreadLocalVar","","Concurrent/ThreadLocalVar.html","","<p>@!macro thread_local_var\n\n<pre>A `ThreadLocalVar` is a variable where the value is different for each thread. ...</pre>\n"],["Concurrent::ThreadPoolExecutor","","Concurrent/ThreadPoolExecutor.html","","<p>@!macro thread_pool_executor\n\n<pre>An abstraction composed of one or more threads and a task queue. Tasks\n(blocks ...</pre>\n"],["Concurrent::ThreadSafe","","Concurrent/ThreadSafe.html","","<p>@!visibility private\n<p>@!visibility private\n<p>@!visibility private\n"],["Concurrent::ThreadSafe::Util","","Concurrent/ThreadSafe/Util.html","","<p>@!visibility private\n<p>@!visibility private\n<p>@!visibility private\n"],["Concurrent::ThreadSafe::Util::Adder","","Concurrent/ThreadSafe/Util/Adder.html","","<p>A Ruby port of the Doug Lea&#39;s jsr166e.LondAdder class version 1.8 available in public domain.\n<p>Original \n"],["Concurrent::ThreadSafe::Util::CheapLockable","","Concurrent/ThreadSafe/Util/CheapLockable.html","","<p>Provides a cheapest possible (mainly in terms of memory usage) <code>Mutex</code> with the <code>ConditionVariable</code> bundled \n"],["Concurrent::ThreadSafe::Util::PowerOfTwoTuple","","Concurrent/ThreadSafe/Util/PowerOfTwoTuple.html","","<p>@!visibility private\n"],["Concurrent::ThreadSafe::Util::Striped64","","Concurrent/ThreadSafe/Util/Striped64.html","","<p>A Ruby port of the Doug Lea&#39;s jsr166e.Striped64 class version 1.6 available in public domain.\n<p>Original \n"],["Concurrent::ThreadSafe::Util::Striped64::Cell","","Concurrent/ThreadSafe/Util/Striped64/Cell.html","","<p>Padded variant of AtomicLong supporting only raw accesses plus CAS. The <code>value</code> field is placed between \n"],["Concurrent::ThreadSafe::Util::Volatile","","Concurrent/ThreadSafe/Util/Volatile.html","","<p>@!visibility private\n"],["Concurrent::ThreadSafe::Util::XorShiftRandom","","Concurrent/ThreadSafe/Util/XorShiftRandom.html","","<p>A xorshift random number (positive +Fixnum+s) generator, provides reasonably cheap way to generate thread \n"],["Concurrent::TimerSet","","Concurrent/TimerSet.html","","<p>Executes a collection of tasks, each after a given delay. A master task monitors the set and schedules \n"],["Concurrent::TimerTask","","Concurrent/TimerTask.html","","<p>A very common concurrency pattern is to run a thread that performs a task at regular intervals. The thread \n"],["Concurrent::Transaction","","Concurrent/Transaction.html","",""],["Concurrent::TruffleRubyArray","","Concurrent/TruffleRubyArray.html","",""],["Concurrent::TruffleRubyAtomicReference","","Concurrent/TruffleRubyAtomicReference.html","",""],["Concurrent::TruffleRubyHash","","Concurrent/TruffleRubyHash.html","",""],["Concurrent::TruffleRubySet","","Concurrent/TruffleRubySet.html","",""],["Concurrent::Tuple","","Concurrent/Tuple.html","","<p>A fixed size array with volatile (synchronized, thread safe) getters/setters. Mixes in Ruby&#39;s `Enumerable` \n"],["Concurrent::Utility","","Concurrent/Utility.html","",""],["Concurrent::Utility::EngineDetector","","Concurrent/Utility/EngineDetector.html","","<p>@!visibility private\n"],["Concurrent::Utility::NativeExtensionLoader","","Concurrent/Utility/NativeExtensionLoader.html","","<p>@!visibility private\n"],["Concurrent::Utility::NativeInteger","","Concurrent/Utility/NativeInteger.html","","<p>@private\n"],["Concurrent::Utility::ProcessorCounter","","Concurrent/Utility/ProcessorCounter.html","","<p>@!visibility private\n"],["Hash","","Hash.html","","<p>@!macro concurrent_hash\n"],["Set","","Set.html","","<p>@!macro concurrent_set\n"],["TruffleRuby","","TruffleRuby.html","","<p>@!visibility private\n"],["&","Concurrent::Promises::Event","Concurrent/Promises/Event.html#method-i-26","(other)",""],["&","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-26","(other)",""],["<<","Concurrent::Agent","Concurrent/Agent.html#method-i-3C-3C","(action)","<p>Dispatches an action to the Agent and returns immediately. Subsequently, in a thread from a thread pool, \n"],["<<","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-3C-3C","(item)",""],["<<","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-3C-3C","(item)",""],["<<","Concurrent::ExecutorService","Concurrent/ExecutorService.html#method-i-3C-3C","(task)","<p>@!macro executor_service_method_left_shift\n"],["<<","Concurrent::ImmediateExecutor","Concurrent/ImmediateExecutor.html#method-i-3C-3C","(task)","<p>@!macro executor_service_method_left_shift\n"],["<<","Concurrent::RubyThreadPoolExecutor::Worker","Concurrent/RubyThreadPoolExecutor/Worker.html#method-i-3C-3C","(message)",""],["<<","Concurrent::SimpleExecutorService","Concurrent/SimpleExecutorService.html#method-c-3C-3C","(task)","<p>@!macro executor_service_method_left_shift\n"],["<<","Concurrent::SimpleExecutorService","Concurrent/SimpleExecutorService.html#method-i-3C-3C","(task)","<p>@!macro executor_service_method_left_shift\n"],["<=>","Concurrent::Maybe","Concurrent/Maybe.html#method-i-3C-3D-3E","(other)","<p>Comparison operator.\n<p>@return [Integer] 0 if self and other are both `Nothing`;\n\n<pre>-1 if self is `Nothing` ...</pre>\n"],["<=>","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-3C-3D-3E","(other)","<p>Comparator which orders by schedule time.\n<p>@!visibility private\n"],["==","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-3D-3D","(other)","<p>@!macro struct_equality\n"],["==","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-3D-3D","(other)","<p>@!macro struct_equality\n\n<pre>Equality\n\n@return [Boolean] true if other has the same struct subclass and has ...</pre>\n"],["==","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-3D-3D","(other)","<p>@!macro struct_equality\n"],["[]","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-5B-5D","(key)",""],["[]","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-5B-5D","(key)",""],["[]","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-5B-5D","(key)","<p>WARNING: Mutex_m is a non-reentrant lock, so the synchronized methods are not allowed to call each other. \n"],["[]","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-5B-5D","(member)","<p>@!macro struct_get\n"],["[]","Concurrent::Map","Concurrent/Map.html#method-i-5B-5D","(key)","<p>Get a value with key @param [Object] key @return [Object] the value\n"],["[]","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-5B-5D","(member)","<p>@!macro struct_get\n\n<pre>Attribute Reference\n\n@param [Symbol, String, Integer] member the string or symbol name ...</pre>\n"],["[]","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-5B-5D","(member)","<p>@!macro struct_get\n"],["[]=","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-5B-5D-3D","(key, value)",""],["[]=","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-i-5B-5D-3D","(key, value)",""],["[]=","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-5B-5D-3D","(key, value)",""],["[]=","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-5B-5D-3D","(key, value)",""],["[]=","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-5B-5D-3D","(member, value)","<p>@!macro struct_set\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Attribute</span> <span class=\"ruby-constant\">Assignment</span>\n\n<span class=\"ruby-constant\">Sets</span> <span class=\"ruby-identifier\">the</span> <span class=\"ruby-identifier\">value</span> <span class=\"ruby-identifier\">of</span> <span class=\"ruby-identifier\">the</span> <span class=\"ruby-identifier\">given</span> <span class=\"ruby-identifier\">struct</span> <span class=\"ruby-identifier\">member</span> <span class=\"ruby-keyword\">or</span> <span class=\"ruby-identifier\">the</span> <span class=\"ruby-identifier\">member</span> <span class=\"ruby-identifier\">at</span> <span class=\"ruby-identifier\">the</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["[]=","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-5B-5D-3D","(member, value)","<p>@!macro struct_set\n<p>@raise [Concurrent::ImmutabilityError] if the given member has already been set\n"],["__initialize_atomic_fields__","Concurrent::Synchronization::Object","Concurrent/Synchronization/Object.html#method-i-__initialize_atomic_fields__","()",""],["_compare_and_set","Concurrent::MutexAtomicReference","Concurrent/MutexAtomicReference.html#method-i-_compare_and_set","(old_value, new_value)","<p>@!macro atomic_reference_method_compare_and_set\n"],["_get","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-_get","(key)",""],["_mon_initialize","Concurrent::ThreadSafe::Util","Concurrent/ThreadSafe/Util.html#method-i-_mon_initialize","()",""],["_set","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-_set","(key, value)",""],["abort","Concurrent::Transaction","Concurrent/Transaction.html#method-i-abort","()",""],["abort_transaction","Concurrent","Concurrent.html#method-c-abort_transaction","()","<p>Abort a currently running transaction - see `Concurrent::atomically`.\n"],["abort_transaction","Concurrent","Concurrent.html#method-i-abort_transaction","()","<p>Abort a currently running transaction - see `Concurrent::atomically`.\n"],["acquire","Concurrent::MutexSemaphore","Concurrent/MutexSemaphore.html#method-i-acquire","(permits = 1)","<p>@!macro semaphore_method_acquire\n"],["acquire_read_lock","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-acquire_read_lock","()","<p>Acquire a read lock. If a write lock has been acquired will block until it is released. Will not block \n"],["acquire_read_lock","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-acquire_read_lock","()","<p>Acquire a read lock. If a write lock is held by another thread, will block until it is released.\n<p>@return \n"],["acquire_write_lock","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-acquire_write_lock","()","<p>Acquire a write lock. Will block and wait for all active readers and writers.\n<p>@return [Boolean] true if \n"],["acquire_write_lock","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-acquire_write_lock","()","<p>Acquire a write lock. Will block and wait for all active readers and writers.\n<p>@return [Boolean] true if \n"],["add","Concurrent::AtExitImplementation","Concurrent/AtExitImplementation.html#method-i-add","(handler_id = nil, &handler)","<p>Add a handler to be run at `Kernel#at_exit` @param [Object] handler_id optionally provide an id, if already \n"],["add","Concurrent::ThreadSafe::Util::Adder","Concurrent/ThreadSafe/Util/Adder.html#method-i-add","(x)","<p>Adds the given value.\n"],["add_callback","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-add_callback","(method, *args)",""],["add_callback_clear_delayed_node","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-add_callback_clear_delayed_node","(node)","<p>@!visibility private\n"],["add_callback_notify_blocked","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-add_callback_notify_blocked","(promise, index)","<p>@!visibility private\n"],["add_delayed","Concurrent::Promises::BlockedPromise","Concurrent/Promises/BlockedPromise.html#method-c-add_delayed","(delayed1, delayed2)",""],["add_delayed_of","Concurrent::Promises::AbstractFlatPromise","Concurrent/Promises/AbstractFlatPromise.html#method-i-add_delayed_of","(future)",""],["add_observer","Concurrent::Collection::CopyOnNotifyObserverSet","Concurrent/Collection/CopyOnNotifyObserverSet.html#method-i-add_observer","(observer = nil, func = :update, &block)","<p>@!macro observable_add_observer\n"],["add_observer","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-i-add_observer","(observer = nil, func = :update, &block)","<p>@!macro observable_add_observer\n"],["add_observer","Concurrent::Concern::Observable","Concurrent/Concern/Observable.html#method-i-add_observer","(observer = nil, func = :update, &block)","<p>@!macro observable_add_observer\n\n<pre>Adds an observer to this set. If a block is passed, the observer will ...</pre>\n"],["add_observer","Concurrent::IVar","Concurrent/IVar.html#method-i-add_observer","(observer = nil, func = :update, &block)","<p>Add an observer on this object that will receive notification on update.\n<p>Upon completion the `IVar` will \n"],["aggregate","Concurrent::Promise","Concurrent/Promise.html#method-c-aggregate","(method, *promises)","<p>Aggregate a collection of zero or more promises under a composite promise, execute the aggregated promises \n"],["all?","Concurrent::Promise","Concurrent/Promise.html#method-c-all-3F","(*promises)","<p>Aggregates a collection of promises and executes the `then` condition if all aggregated promises succeed. \n"],["allocate_storage","Concurrent::AbstractThreadLocalVar","Concurrent/AbstractThreadLocalVar.html#method-i-allocate_storage","()","<p>@!visibility private\n"],["allocate_storage","Concurrent::JavaThreadLocalVar","Concurrent/JavaThreadLocalVar.html#method-i-allocate_storage","()","<p>@!visibility private\n"],["allocate_storage","Concurrent::RubyThreadLocalVar","Concurrent/RubyThreadLocalVar.html#method-i-allocate_storage","()","<p>@!visibility private\n"],["allow_c_extensions?","Concurrent::Utility::NativeExtensionLoader","Concurrent/Utility/NativeExtensionLoader.html#method-i-allow_c_extensions-3F","()",""],["any","Concurrent::Promises::Event","Concurrent/Promises/Event.html#method-i-any","(event_or_future)","<p>Creates a new event which will be resolved when the first of receiver, `event_or_future` resolves.\n<p>@return \n"],["any","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-any","(*futures_and_or_events)",""],["any","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-any","(event_or_future)","<p>Creates a new event which will be resolved when the first of receiver, `event_or_future` resolves. Returning \n"],["any?","Concurrent::Promise","Concurrent/Promise.html#method-c-any-3F","(*promises)","<p>Aggregates a collection of promises and executes the `then` condition if any aggregated promises succeed. \n"],["any_event","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-any_event","(*futures_and_or_events)","<p>@!macro promises.shortcut.on @return [Future]\n"],["any_event_on","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-any_event_on","(default_executor, *futures_and_or_events)","<p>Creates new event which becomes resolved after first of the futures_and_or_events resolves. @!macro  \n"],["any_fulfilled_future","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-any_fulfilled_future","(*futures_and_or_events)","<p>@!macro promises.shortcut.on @return [Future]\n"],["any_fulfilled_future_on","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-any_fulfilled_future_on","(default_executor, *futures_and_or_events)","<p>Creates new future which is resolved after first of futures_and_or_events is fulfilled. Its result equals \n"],["any_resolved_future","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-any_resolved_future","(*futures_and_or_events)","<p>@!macro promises.shortcut.on @return [Future]\n"],["any_resolved_future_on","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-any_resolved_future_on","(default_executor, *futures_and_or_events)","<p>Creates new future which is resolved after first futures_and_or_events is resolved. Its result equals \n"],["apply","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-apply","(args, block)","<p>@!visibility private\n"],["apply","Concurrent::Promises::InternalStates::Fulfilled","Concurrent/Promises/InternalStates/Fulfilled.html#method-i-apply","(args, block)",""],["apply","Concurrent::Promises::InternalStates::FulfilledArray","Concurrent/Promises/InternalStates/FulfilledArray.html#method-i-apply","(args, block)",""],["apply","Concurrent::Promises::InternalStates::PartiallyRejected","Concurrent/Promises/InternalStates/PartiallyRejected.html#method-i-apply","(args, block)",""],["apply","Concurrent::Promises::InternalStates::Rejected","Concurrent/Promises/InternalStates/Rejected.html#method-i-apply","(args, block)",""],["apply","Concurrent::Promises::InternalStates::ResolvedWithResult","Concurrent/Promises/InternalStates/ResolvedWithResult.html#method-i-apply","()",""],["apply_deref_options","Concurrent::Concern::Dereferenceable","Concurrent/Concern/Dereferenceable.html#method-i-apply_deref_options","(value)","<p>@!visibility private\n"],["async","Concurrent::Async","Concurrent/Async.html#method-i-async","()","<p>Causes the chained method call to be performed asynchronously on the object&#39;s thread. The delegated \n"],["async_callback_on_fulfillment","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-async_callback_on_fulfillment","(state, executor, args, callback)",""],["async_callback_on_rejection","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-async_callback_on_rejection","(state, executor, args, callback)",""],["async_callback_on_resolution","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-async_callback_on_resolution","(state, executor, args, callback)",""],["atomic_attribute?","Concurrent::Synchronization::Object","Concurrent/Synchronization/Object.html#method-c-atomic_attribute-3F","(name)","<p>@return [true, false] is the attribute with name atomic?\n"],["atomic_attributes","Concurrent::Synchronization::Object","Concurrent/Synchronization/Object.html#method-c-atomic_attributes","(inherited = true)","<p>@param [true, false] inherited should inherited volatile with CAS fields be returned? @return [::Array&lt;Symbol&gt;] \n"],["atomically","Concurrent","Concurrent.html#method-c-atomically","()","<p>Run a block that reads and writes `TVar`s as a single atomic transaction. With respect to the value of \n"],["atomically","Concurrent","Concurrent.html#method-i-atomically","()","<p>Run a block that reads and writes `TVar`s as a single atomic transaction. With respect to the value of \n"],["attempt_compute","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-attempt_compute","(key, hash, current_table, i, node, node_hash)",""],["attempt_get_and_set","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-attempt_get_and_set","(key, value, hash, current_table, i, node, node_hash)",""],["attempt_internal_compute_if_absent","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-attempt_internal_compute_if_absent","(key, hash, current_table, i, node, node_hash)",""],["attempt_internal_replace","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-attempt_internal_replace","(key, expected_old_value, hash, current_table, i, node, node_hash)",""],["attr_atomic","Concurrent::Synchronization::Object","Concurrent/Synchronization/Object.html#method-c-attr_atomic","(*names)","<p>Creates methods for reading and writing to a instance variable with volatile (Java) semantic as {.attr_volatile} \n"],["attr_volatile","Concurrent::Synchronization::AbstractObject","Concurrent/Synchronization/AbstractObject.html#method-c-attr_volatile","(*names)",""],["attr_volatile","Concurrent::Synchronization::JRubyAttrVolatile::ClassMethods","Concurrent/Synchronization/JRubyAttrVolatile/ClassMethods.html#method-i-attr_volatile","(*names)",""],["attr_volatile","Concurrent::Synchronization::MriAttrVolatile::ClassMethods","Concurrent/Synchronization/MriAttrVolatile/ClassMethods.html#method-i-attr_volatile","(*names)",""],["attr_volatile","Concurrent::Synchronization::RbxAttrVolatile::ClassMethods","Concurrent/Synchronization/RbxAttrVolatile/ClassMethods.html#method-i-attr_volatile","(*names)",""],["attr_volatile","Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods","Concurrent/Synchronization/TruffleRubyAttrVolatile/ClassMethods.html#method-i-attr_volatile","(*names)",""],["attr_volatile","Concurrent::ThreadSafe::Util::Volatile","Concurrent/ThreadSafe/Util/Volatile.html#method-i-attr_volatile","(*attr_names)","<p>Provides <code>volatile</code> (in the JVM&#39;s sense) attribute accessors implemented atop of <code>Concurrent::AtomicReference</code> \n"],["auto_terminate=","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-auto_terminate-3D","(value)","<p>@!macro executor_service_method_auto_terminate_setter\n"],["auto_terminate?","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-auto_terminate-3F","()","<p>@!macro executor_service_method_auto_terminate_question\n"],["available_permits","Concurrent::MutexSemaphore","Concurrent/MutexSemaphore.html#method-i-available_permits","()","<p>@!macro semaphore_method_available_permits\n"],["await","Concurrent::Agent","Concurrent/Agent.html#method-i-await","()","<p>Blocks the current thread (indefinitely!) until all actions dispatched thus far, from this thread or \n"],["await","Concurrent::Agent","Concurrent/Agent.html#method-c-await","(*agents)","<p>Blocks the current thread (indefinitely!) until all actions dispatched thus far to all the given Agents \n"],["await","Concurrent::Async","Concurrent/Async.html#method-i-await","()","<p>Causes the chained method call to be performed synchronously on the current thread. The delegated will \n"],["await_for","Concurrent::Agent","Concurrent/Agent.html#method-i-await_for","(timeout)","<p>Blocks the current thread until all actions dispatched thus far, from this thread or nested by the Agent \n"],["await_for","Concurrent::Agent","Concurrent/Agent.html#method-c-await_for","(timeout, *agents)","<p>Blocks the current thread until all actions dispatched thus far to all the given Agents, from this thread \n"],["await_for!","Concurrent::Agent","Concurrent/Agent.html#method-c-await_for-21","(timeout, *agents)","<p>Blocks the current thread until all actions dispatched thus far to all the given Agents, from this thread \n"],["await_for!","Concurrent::Agent","Concurrent/Agent.html#method-i-await_for-21","(timeout)","<p>Blocks the current thread until all actions dispatched thus far, from this thread or nested by the Agent \n"],["bind","Concurrent::AbstractThreadLocalVar","Concurrent/AbstractThreadLocalVar.html#method-i-bind","(value, &block)","<p>@!macro thread_local_var_method_bind\n"],["blocked_by","Concurrent::Promises::BlockedPromise","Concurrent/Promises/BlockedPromise.html#method-i-blocked_by","()","<p>for inspection only\n"],["blocks","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-blocks","()","<p>For inspection. @!visibility private @return [Array&lt;AbstractPromise&gt;]\n"],["borrow","Concurrent::MVar","Concurrent/MVar.html#method-i-borrow","(timeout = nil)","<p>acquires lock on the from an `MVAR`, yields the value to provided block, and release lock. A timeout \n"],["broadcast","Concurrent::Synchronization::Condition","Concurrent/Synchronization/Condition.html#method-i-broadcast","()",""],["broadcast","Concurrent::Synchronization::Lock","Concurrent/Synchronization/Lock.html#method-i-broadcast","()",""],["broken?","Concurrent::CyclicBarrier","Concurrent/CyclicBarrier.html#method-i-broken-3F","()","<p>A barrier can be broken when:\n<p>a thread called the `reset` method while at least one other thread was waiting \n"],["c_extensions_loaded?","Concurrent::Utility::NativeExtensionLoader","Concurrent/Utility/NativeExtensionLoader.html#method-i-c_extensions_loaded-3F","()",""],["call","Concurrent::Async","Concurrent/Async.html#method-i-call","()",""],["call_callback","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-call_callback","(method, state, args)",""],["call_callbacks","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-call_callbacks","(state)",""],["call_dataflow","Concurrent","Concurrent.html#method-i-call_dataflow","(method, executor, *inputs, &block)",""],["call_dataflow","Concurrent","Concurrent.html#method-c-call_dataflow","(method, executor, *inputs, &block)",""],["call_job","Concurrent::SerializedExecution","Concurrent/SerializedExecution.html#method-i-call_job","(job)",""],["callback_clear_delayed_node","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-callback_clear_delayed_node","(state, node)",""],["callback_notify_blocked","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-callback_notify_blocked","(state, promise, index)",""],["callback_on_fulfillment","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-callback_on_fulfillment","(state, args, callback)",""],["callback_on_rejection","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-callback_on_rejection","(state, args, callback)",""],["callback_on_resolution","Concurrent::Promises::Event","Concurrent/Promises/Event.html#method-i-callback_on_resolution","(state, args, callback)",""],["callback_on_resolution","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-callback_on_resolution","(state, args, callback)",""],["callbacks","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-callbacks","()","<p>For inspection. @!visibility private\n"],["can_overflow?","Concurrent::ExecutorService","Concurrent/ExecutorService.html#method-i-can_overflow-3F","()","<p>@!macro executor_service_method_can_overflow_question\n<p>@note Always returns `false`\n"],["can_overflow?","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-i-can_overflow-3F","()","<p>@!macro executor_service_method_can_overflow_question\n"],["can_overflow?","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-can_overflow-3F","()","<p>@!macro executor_service_method_can_overflow_question\n"],["cancel","Concurrent::Future","Concurrent/Future.html#method-i-cancel","()","<p>Attempt to cancel the operation if it has not already processed. The operation can only be cancelled \n"],["cancel","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-cancel","()","<p>Cancel this task and prevent it from executing. A task can only be cancelled if it is pending or unscheduled. \n"],["cancelled?","Concurrent::Future","Concurrent/Future.html#method-i-cancelled-3F","()","<p>Has the operation been successfully cancelled?\n<p>@return [Boolean]\n"],["cancelled?","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-cancelled-3F","()","<p>Has the task been cancelled?\n<p>@return [Boolean] true if the task is in the given state else false\n"],["cas","Concurrent::Tuple","Concurrent/Tuple.html#method-i-cas","(i, old_value, new_value)",""],["cas_base_computed","Concurrent::ThreadSafe::Util::Striped64","Concurrent/ThreadSafe/Util/Striped64.html#method-i-cas_base_computed","()",""],["cas_computed","Concurrent::ThreadSafe::Util::Striped64::Cell","Concurrent/ThreadSafe/Util/Striped64/Cell.html#method-i-cas_computed","()",""],["cas_new_node","Concurrent::Collection::AtomicReferenceMapBackend::Table","Concurrent/Collection/AtomicReferenceMapBackend/Table.html#method-i-cas_new_node","(i, hash, key, value)",""],["cast","Concurrent::Async","Concurrent/Async.html#method-i-cast","()",""],["catch","Concurrent::Promise","Concurrent/Promise.html#method-i-catch","(&block)",""],["chain","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-chain","(*args, &task)","<p>@!macro promises.shortcut.on @return [Future]\n"],["chain_on","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-chain_on","(executor, *args, &task)","<p>Chains the task to be executed asynchronously on executor after it is resolved.\n<p>@!macro promises.param.executor \n"],["chain_resolvable","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-chain_resolvable","(resolvable)","<p>Resolves the resolvable when receiver is resolved.\n<p>@param [Resolvable] resolvable @return [self]\n"],["cheap_broadcast","Concurrent::ThreadSafe::Util::CheapLockable","Concurrent/ThreadSafe/Util/CheapLockable.html#method-i-cheap_broadcast","()",""],["cheap_synchronize","Concurrent::ThreadSafe::Util::CheapLockable","Concurrent/ThreadSafe/Util/CheapLockable.html#method-i-cheap_synchronize","()","<p>Making use of the Rubinius&#39; ability to lock via object headers to avoid the overhead of the extra \n"],["cheap_wait","Concurrent::ThreadSafe::Util::CheapLockable","Concurrent/ThreadSafe/Util/CheapLockable.html#method-i-cheap_wait","()",""],["check_for_resize","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-check_for_resize","()","<p>If table is too small and not already resizing, creates next table and transfers bins. Rechecks occupancy \n"],["clear","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-clear","()","<p>Implementation for clear. Steps through each bin, removing all nodes.\n"],["clear","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-clear","()","<p>@!macro priority_queue_method_clear\n"],["clear","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-i-clear","()",""],["clear","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-clear","()",""],["clear","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-clear","()","<p>@!macro priority_queue_method_clear\n"],["clear","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-clear","()",""],["clear","Concurrent::LockFreeStack","Concurrent/LockFreeStack.html#method-i-clear","()","<p>@return [true, false]\n"],["clear_and_propagate_touch","Concurrent::Promises::BlockedPromise","Concurrent/Promises/BlockedPromise.html#method-i-clear_and_propagate_touch","(stack_or_element = @Delayed)",""],["clear_each","Concurrent::LockFreeStack","Concurrent/LockFreeStack.html#method-i-clear_each","(&block)","<p>@return [self] @yield over the cleared stack @yieldparam [Object] value\n"],["clear_if","Concurrent::LockFreeStack","Concurrent/LockFreeStack.html#method-i-clear_if","(head)","<p>@param [Node] head @return [true, false]\n"],["clear_observers_and_return_old","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-i-clear_observers_and_return_old","()",""],["commit","Concurrent::Transaction","Concurrent/Transaction.html#method-i-commit","()",""],["compare_and_clear","Concurrent::LockFreeStack","Concurrent/LockFreeStack.html#method-i-compare_and_clear","(head)","<p>@param [Node] head @return [true, false]\n"],["compare_and_pop","Concurrent::LockFreeStack","Concurrent/LockFreeStack.html#method-i-compare_and_pop","(head)","<p>@param [Node] head @return [true, false]\n"],["compare_and_push","Concurrent::LockFreeStack","Concurrent/LockFreeStack.html#method-i-compare_and_push","(head, value)","<p>@param [Node] head @param [Object] value @return [true, false]\n"],["compare_and_set","Concurrent::Atom","Concurrent/Atom.html#method-i-compare_and_set","(old_value, new_value)","<p>Atomically sets the value of atom to the new value if and only if the current value of the atom is identical \n"],["compare_and_set","Concurrent::AtomicMarkableReference","Concurrent/AtomicMarkableReference.html#method-i-compare_and_set","(expected_val, new_val, expected_mark, new_mark)","<p>Atomically sets the value and mark to the given updated value and mark given both:\n\n<pre>- the current value ...</pre>\n"],["compare_and_set","Concurrent::AtomicNumericCompareAndSetWrapper","Concurrent/AtomicNumericCompareAndSetWrapper.html#method-i-compare_and_set","(old_value, new_value)","<p>@!macro atomic_reference_method_compare_and_set\n"],["compare_and_set","Concurrent::MutexAtomicFixnum","Concurrent/MutexAtomicFixnum.html#method-i-compare_and_set","(expect, update)","<p>@!macro atomic_fixnum_method_compare_and_set\n"],["compare_and_set","Concurrent::Tuple","Concurrent/Tuple.html#method-i-compare_and_set","(i, old_value, new_value)","<p>Set the value at the given index to the new value if and only if the current value matches the given \n"],["compare_and_set_state","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-compare_and_set_state","(next_state, *expected_current)","<p>Atomic compare and set operation State is set to `next_state` only if `current state == expected_current \n"],["compare_and_swap","Concurrent::AtomicMarkableReference","Concurrent/AtomicMarkableReference.html#method-i-compare_and_swap","(expected_val, new_val, expected_mark, new_mark)",""],["complete","Concurrent::IVar","Concurrent/IVar.html#method-i-complete","(success, value, reason)","<p>@!visibility private\n"],["complete","Concurrent::Promise","Concurrent/Promise.html#method-i-complete","(success, value, reason)","<p>@!visibility private\n"],["complete?","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-complete-3F","()","<p>Has the obligation completed processing?\n<p>@return [Boolean]\n"],["complete_without_notification","Concurrent::IVar","Concurrent/IVar.html#method-i-complete_without_notification","(success, value, reason)","<p>@!visibility private\n"],["completed_task_count","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-i-completed_task_count","()","<p>@!macro thread_pool_executor_attr_reader_completed_task_count\n"],["completed_task_count","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-completed_task_count","()","<p>@!macro thread_pool_executor_attr_reader_completed_task_count\n"],["compute","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-compute","(key)",""],["compute","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-i-compute","(key)",""],["compute","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-compute","(key)",""],["compute","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-compute","(key)",""],["compute_if_absent","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-compute_if_absent","(key)",""],["compute_if_absent","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-i-compute_if_absent","(key)",""],["compute_if_absent","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-compute_if_absent","(key)",""],["compute_if_absent","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-compute_if_absent","(key)",""],["compute_if_present","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-compute_if_present","(key)",""],["compute_if_present","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-i-compute_if_present","(key)",""],["compute_if_present","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-compute_if_present","(key)",""],["compute_if_present","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-compute_if_present","(key)",""],["compute_physical_processor_count","Concurrent::Utility::ProcessorCounter","Concurrent/Utility/ProcessorCounter.html#method-i-compute_physical_processor_count","()",""],["compute_processor_count","Concurrent::Utility::ProcessorCounter","Concurrent/Utility/ProcessorCounter.html#method-i-compute_processor_count","()",""],["count","Concurrent::JavaCountDownLatch","Concurrent/JavaCountDownLatch.html#method-i-count","()","<p>@!macro count_down_latch_method_count\n"],["count","Concurrent::MutexCountDownLatch","Concurrent/MutexCountDownLatch.html#method-i-count","()","<p>@!macro count_down_latch_method_count\n"],["count_down","Concurrent::JavaCountDownLatch","Concurrent/JavaCountDownLatch.html#method-i-count_down","()","<p>@!macro count_down_latch_method_count_down\n"],["count_down","Concurrent::MutexCountDownLatch","Concurrent/MutexCountDownLatch.html#method-i-count_down","()","<p>@!macro count_down_latch_method_count_down\n"],["count_observers","Concurrent::Collection::CopyOnNotifyObserverSet","Concurrent/Collection/CopyOnNotifyObserverSet.html#method-i-count_observers","()","<p>@!macro observable_count_observers\n"],["count_observers","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-i-count_observers","()","<p>@!macro observable_count_observers\n"],["count_observers","Concurrent::Concern::Observable","Concurrent/Concern/Observable.html#method-i-count_observers","()","<p>@!macro observable_count_observers\n\n<pre>Return the number of observers associated with this object.\n\n@return ...</pre>\n"],["create_simple_logger","Concurrent","Concurrent.html#method-c-create_simple_logger","(level = Logger::FATAL, output = $stderr)","<p>@return [Logger] Logger with provided level and output.\n"],["create_stdlib_logger","Concurrent","Concurrent.html#method-c-create_stdlib_logger","(level = Logger::FATAL, output = $stderr)","<p>@return [Logger] Logger with provided level and output. @deprecated\n"],["create_worker","Concurrent::RubyThreadPoolExecutor::Worker","Concurrent/RubyThreadPoolExecutor/Worker.html#method-i-create_worker","(queue, pool, idletime)",""],["current","Concurrent::Transaction","Concurrent/Transaction.html#method-c-current","()",""],["current=","Concurrent::Transaction","Concurrent/Transaction.html#method-c-current-3D","(transaction)",""],["dataflow","Concurrent","Concurrent.html#method-i-dataflow","(*inputs, &block)","<p>Dataflow allows you to create a task that will be scheduled when all of its data dependencies are available. \n"],["dataflow","Concurrent","Concurrent.html#method-c-dataflow","(*inputs, &block)","<p>Dataflow allows you to create a task that will be scheduled when all of its data dependencies are available. \n"],["dataflow!","Concurrent","Concurrent.html#method-i-dataflow-21","(*inputs, &block)",""],["dataflow!","Concurrent","Concurrent.html#method-c-dataflow-21","(*inputs, &block)",""],["dataflow_with","Concurrent","Concurrent.html#method-i-dataflow_with","(executor, *inputs, &block)",""],["dataflow_with","Concurrent","Concurrent.html#method-c-dataflow_with","(executor, *inputs, &block)",""],["dataflow_with!","Concurrent","Concurrent.html#method-c-dataflow_with-21","(executor, *inputs, &block)",""],["dataflow_with!","Concurrent","Concurrent.html#method-i-dataflow_with-21","(executor, *inputs, &block)",""],["decrement","Concurrent::MutexAtomicFixnum","Concurrent/MutexAtomicFixnum.html#method-i-decrement","(delta = 1)","<p>@!macro atomic_fixnum_method_decrement\n"],["decrement","Concurrent::ThreadSafe::Util::Adder","Concurrent/ThreadSafe/Util/Adder.html#method-i-decrement","()",""],["decrement_size","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-decrement_size","(by = 1)",""],["default","Concurrent::AbstractThreadLocalVar","Concurrent/AbstractThreadLocalVar.html#method-i-default","()","<p>@!visibility private\n"],["default_executor","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-default_executor","()","<p>Returns default executor. @return [Executor] default executor @see #with_default_executor @see FactoryMethods#future_on \n"],["default_executor","Concurrent::Promises::AbstractPromise","Concurrent/Promises/AbstractPromise.html#method-i-default_executor","()",""],["default_executor","Concurrent::Promises::FactoryMethods::Configuration","Concurrent/Promises/FactoryMethods/Configuration.html#method-i-default_executor","()","<p>@return [Executor, :io, :fast] the executor which is used when none is supplied\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">to</span> <span class=\"ruby-identifier\">a</span> <span class=\"ruby-identifier\">factory</span> <span class=\"ruby-identifier\">method</span>. <span class=\"ruby-constant\">The</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["default_for","Concurrent::RubyThreadLocalVar","Concurrent/RubyThreadLocalVar.html#method-i-default_for","(thread)",""],["define_initialize_atomic_fields","Concurrent::Synchronization::Object","Concurrent/Synchronization/Object.html#method-c-define_initialize_atomic_fields","()",""],["define_struct_class","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-c-define_struct_class","(parent, base, name, members, &block)","<p>@!visibility private\n"],["delay","Concurrent::Promises::Event","Concurrent/Promises/Event.html#method-i-delay","()","<p>Creates new event dependent on receiver which will not evaluate until touched, see {#touch}. In other \n"],["delay","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-delay","(*args, &task)","<p>@!macro promises.shortcut.on @return [Future, Event]\n"],["delay","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-delay","()","<p>Creates new future dependent on receiver which will not evaluate until touched, see {#touch}. In other \n"],["delay_on","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-delay_on","(default_executor, *args, &task)","<p>Creates new event or future which is resolved only after it is touched, see {Concurrent::AbstractEventFuture#touch}. \n"],["delayed_because","Concurrent::Promises::AbstractPromise","Concurrent/Promises/AbstractPromise.html#method-i-delayed_because","()",""],["delayed_because","Concurrent::Promises::BlockedPromise","Concurrent/Promises/BlockedPromise.html#method-i-delayed_because","()",""],["delayed_because","Concurrent::Promises::DelayPromise","Concurrent/Promises/DelayPromise.html#method-i-delayed_because","()",""],["delete","Concurrent::AtExitImplementation","Concurrent/AtExitImplementation.html#method-i-delete","(handler_id)","<p>Delete a handler by handler_id @return [true, false]\n"],["delete","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-delete","(key)",""],["delete","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-delete","(item)","<p>@!macro priority_queue_method_delete\n"],["delete","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-i-delete","(key)",""],["delete","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-delete","(key)",""],["delete","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-delete","(item)","<p>@!macro priority_queue_method_delete\n"],["delete","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-delete","(key)",""],["delete_node_at","Concurrent::Collection::AtomicReferenceMapBackend::Table","Concurrent/Collection/AtomicReferenceMapBackend/Table.html#method-i-delete_node_at","(i, node, predecessor_node)",""],["delete_observer","Concurrent::Collection::CopyOnNotifyObserverSet","Concurrent/Collection/CopyOnNotifyObserverSet.html#method-i-delete_observer","(observer)","<p>@!macro observable_delete_observer\n"],["delete_observer","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-i-delete_observer","(observer)","<p>@!macro observable_delete_observer\n"],["delete_observer","Concurrent::Concern::Observable","Concurrent/Concern/Observable.html#method-i-delete_observer","(observer)","<p>@!macro observable_delete_observer\n\n<pre>Remove `observer` as an observer on this object so that it will no ...</pre>\n"],["delete_observers","Concurrent::Collection::CopyOnNotifyObserverSet","Concurrent/Collection/CopyOnNotifyObserverSet.html#method-i-delete_observers","()","<p>@!macro observable_delete_observers\n"],["delete_observers","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-i-delete_observers","()","<p>@!macro observable_delete_observers\n"],["delete_observers","Concurrent::Concern::Observable","Concurrent/Concern/Observable.html#method-i-delete_observers","()","<p>@!macro observable_delete_observers\n\n<pre>Remove all observers associated with this object.\n\n@return [Observable] ...</pre>\n"],["delete_pair","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-delete_pair","(key, value)",""],["delete_pair","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-i-delete_pair","(key, value)",""],["delete_pair","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-delete_pair","(key, value)",""],["delete_pair","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-delete_pair","(key, value)",""],["deprecated","Concurrent::Concern::Deprecation","Concurrent/Concern/Deprecation.html#method-i-deprecated","(message, strip = 2)",""],["deprecated_method","Concurrent::Concern::Deprecation","Concurrent/Concern/Deprecation.html#method-i-deprecated_method","(old_name, new_name)",""],["deq","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-deq","()",""],["deq","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-deq","()",""],["deref","Concurrent::Agent","Concurrent/Agent.html#method-i-deref","()",""],["deref","Concurrent::Concern::Dereferenceable","Concurrent/Concern/Dereferenceable.html#method-i-deref","()",""],["disable_at_exit_handlers!","Concurrent","Concurrent.html#method-c-disable_at_exit_handlers-21","()","<p>Disables AtExit handlers including pool auto-termination handlers. When disabled it will be the application \n"],["do_exchange","Concurrent::AbstractExchanger","Concurrent/AbstractExchanger.html#method-i-do_exchange","(value, timeout)","<p>@!macro exchanger_method_do_exchange\n<p>@return [Object, CANCEL] the value exchanged by the other thread; \n"],["do_exchange","Concurrent::JavaExchanger","Concurrent/JavaExchanger.html#method-i-do_exchange","(value, timeout)","<p>@!macro exchanger_method_do_exchange\n<p>@return [Object, CANCEL] the value exchanged by the other thread; \n"],["do_exchange","Concurrent::RubyExchanger","Concurrent/RubyExchanger.html#method-i-do_exchange","(value, timeout)","<p>@!macro exchanger_method_do_exchange\n<p>@return [Object, CANCEL] the value exchanged by the other thread; \n"],["down","Concurrent::MutexAtomicFixnum","Concurrent/MutexAtomicFixnum.html#method-i-down","(delta = 1)",""],["drain_permits","Concurrent::MutexSemaphore","Concurrent/MutexSemaphore.html#method-i-drain_permits","()","<p>@!macro semaphore_method_drain_permits\n\n<pre>Acquires and returns all permits that are immediately available. ...</pre>\n"],["duplicate_and_clear_observers","Concurrent::Collection::CopyOnNotifyObserverSet","Concurrent/Collection/CopyOnNotifyObserverSet.html#method-i-duplicate_and_clear_observers","()",""],["duplicate_observers","Concurrent::Collection::CopyOnNotifyObserverSet","Concurrent/Collection/CopyOnNotifyObserverSet.html#method-i-duplicate_observers","()",""],["dupped_backend","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-dupped_backend","()",""],["dupped_backend","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-dupped_backend","()",""],["each","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-each","(&block)","<p>@!macro struct_each\n"],["each","Concurrent::LockFreeStack","Concurrent/LockFreeStack.html#method-i-each","(head = nil)","<p>@param [Node] head @return [self]\n"],["each","Concurrent::Map","Concurrent/Map.html#method-i-each","()",""],["each","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-each","(&block)","<p>@!macro struct_each\n\n<pre>Yields the value of each struct member in order. If no block is given\nan enumerator ...</pre>\n"],["each","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-each","(&block)","<p>@!macro struct_each\n"],["each","Concurrent::Tuple","Concurrent/Tuple.html#method-i-each","()","<p>Calls the given block once for each element in self, passing that element as a parameter.\n<p>@yieldparam \n"],["each_key","Concurrent::Map","Concurrent/Map.html#method-i-each_key","()","<p>Iterates over each key. @yield for each key in the map @yieldparam key [Object] @return [self] @!macro \n"],["each_pair","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-each_pair","()",""],["each_pair","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-each_pair","()",""],["each_pair","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-each_pair","(&block)","<p>@!macro struct_each_pair\n"],["each_pair","Concurrent::Map","Concurrent/Map.html#method-i-each_pair","()","<p>Iterates over each key value pair. @yield for each key value pair in the map @yieldparam key [Object] \n"],["each_pair","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-each_pair","(&block)","<p>@!macro struct_each_pair\n\n<pre>Yields the name and value of each struct member in order. If no block is\ngiven ...</pre>\n"],["each_pair","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-each_pair","(&block)","<p>@!macro struct_each_pair\n"],["each_value","Concurrent::Map","Concurrent/Map.html#method-i-each_value","()","<p>Iterates over each value. @yield for each value in the map @yieldparam value [Object] @return [self] \n"],["empty?","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-empty-3F","()",""],["empty?","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-empty-3F","()","<p>@!macro priority_queue_method_empty\n"],["empty?","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-empty-3F","()","<p>@!macro priority_queue_method_empty\n"],["empty?","Concurrent::LockFreeStack","Concurrent/LockFreeStack.html#method-i-empty-3F","(head = head())","<p>@param [Node] head @return [true, false]\n"],["empty?","Concurrent::MVar","Concurrent/MVar.html#method-i-empty-3F","()","<p>Returns if the `MVar` is currently empty.\n"],["empty?","Concurrent::Map","Concurrent/Map.html#method-i-empty-3F","()","<p>Is map empty? @return [true, false]\n"],["enabled=","Concurrent::AtExitImplementation","Concurrent/AtExitImplementation.html#method-i-enabled-3D","(value)","<p>Configure if it runs during `Kernel#at_exit`\n"],["enabled?","Concurrent::AtExitImplementation","Concurrent/AtExitImplementation.html#method-i-enabled-3F","()","<p>Will it run during `Kernel#at_exit`\n"],["enq","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-enq","(item)",""],["enq","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-enq","(item)",""],["enqueue_action_job","Concurrent::Agent","Concurrent/Agent.html#method-i-enqueue_action_job","(action, args, executor)",""],["enqueue_await_job","Concurrent::Agent","Concurrent/Agent.html#method-i-enqueue_await_job","(latch)",""],["ensure_integer","Concurrent::Utility::NativeInteger","Concurrent/Utility/NativeInteger.html#method-i-ensure_integer","(value)",""],["ensure_integer_and_bounds","Concurrent::Utility::NativeInteger","Concurrent/Utility/NativeInteger.html#method-i-ensure_integer_and_bounds","(value)",""],["ensure_lower_bound","Concurrent::Utility::NativeInteger","Concurrent/Utility/NativeInteger.html#method-i-ensure_lower_bound","(value)",""],["ensure_positive","Concurrent::Utility::NativeInteger","Concurrent/Utility/NativeInteger.html#method-i-ensure_positive","(value)",""],["ensure_positive_and_no_zero","Concurrent::Utility::NativeInteger","Concurrent/Utility/NativeInteger.html#method-i-ensure_positive_and_no_zero","(value)",""],["ensure_safe_initialization_when_final_fields_are_present","Concurrent::Synchronization::Object","Concurrent/Synchronization/Object.html#method-c-ensure_safe_initialization_when_final_fields_are_present","()","<p>For testing purposes, quite slow. Injects assert code to new method which will raise if class instance \n"],["ensure_upper_bound","Concurrent::Utility::NativeInteger","Concurrent/Utility/NativeInteger.html#method-i-ensure_upper_bound","(value)",""],["error","Concurrent::Agent","Concurrent/Agent.html#method-i-error","()","<p>When {#failed?} and {#error_mode} is `:fail`, returns the error object which caused the failure, else \n"],["evaluate_to","Concurrent::Promises::AbstractPromise","Concurrent/Promises/AbstractPromise.html#method-i-evaluate_to","(*args, block)","<p>@return [Future]\n"],["evaluate_to","Concurrent::Promises::ResolvableFuture","Concurrent/Promises/ResolvableFuture.html#method-i-evaluate_to","(*args, &block)","<p>Evaluates the block and sets its result as future&#39;s value fulfilling, if the block raises an exception \n"],["evaluate_to!","Concurrent::Promises::ResolvableFuture","Concurrent/Promises/ResolvableFuture.html#method-i-evaluate_to-21","(*args, &block)","<p>Evaluates the block and sets its result as future&#39;s value fulfilling, if the block raises an exception \n"],["event","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-event","()","<p>@!visibility private\n"],["event","Concurrent::Promises::AbstractPromise","Concurrent/Promises/AbstractPromise.html#method-i-event","()",""],["exception","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-exception","(*args)","<p>@example allows Obligation to be risen\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">rejected_ivar</span> = <span class=\"ruby-constant\">Ivar</span>.<span class=\"ruby-identifier\">new</span>.<span class=\"ruby-identifier\">fail</span>\n<span class=\"ruby-identifier\">raise</span> <span class=\"ruby-identifier\">rejected_ivar</span>\n</pre>\n"],["exception","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-exception","(*args)","<p>Allows rejected Future to be risen with `raise` method. If the reason is not an exception `Runtime.new(reason)` \n"],["exchange","Concurrent::AbstractExchanger","Concurrent/AbstractExchanger.html#method-i-exchange","(value, timeout = nil)","<p>@!macro exchanger_method_do_exchange\n\n<pre>Waits for another thread to arrive at this exchange point (unless ...</pre>\n"],["exchange!","Concurrent::AbstractExchanger","Concurrent/AbstractExchanger.html#method-i-exchange-21","(value, timeout = nil)","<p>@!macro exchanger_method_do_exchange @!macro exchanger_method_exchange_bang\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">On</span> <span class=\"ruby-identifier\">timeout</span> <span class=\"ruby-identifier\">a</span> {<span class=\"ruby-constant\">Concurrent</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">TimeoutError</span>} <span class=\"ruby-operator\">...</span>\n</pre>\n"],["execute","Concurrent::Future","Concurrent/Future.html#method-i-execute","()","<p>Execute an `:unscheduled` `Future`. Immediately sets the state to `:pending` and passes the block to \n"],["execute","Concurrent::Future","Concurrent/Future.html#method-c-execute","(opts = {}, &block)","<p>Create a new `Future` object with the given block, execute it, and return the `:pending` object.\n<p>@yield \n"],["execute","Concurrent::Promise","Concurrent/Promise.html#method-c-execute","(opts = {}, &block)","<p>Create a new `Promise` object with the given block, execute it, and return the `:pending` object.\n<p>@!macro \n"],["execute","Concurrent::Promise","Concurrent/Promise.html#method-i-execute","()","<p>Execute an `:unscheduled` `Promise`. Immediately sets the state to `:pending` and passes the block to \n"],["execute","Concurrent::SafeTaskExecutor","Concurrent/SafeTaskExecutor.html#method-i-execute","(*args)","<p>@return [Array]\n"],["execute","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-execute","()","<p>Execute an `:unscheduled` `ScheduledTask`. Immediately sets the state to `:pending` and starts counting \n"],["execute","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-c-execute","(delay, opts = {}, &task)","<p>Create a new `ScheduledTask` object with the given block, execute it, and return the `:pending` object. \n"],["execute","Concurrent::TimerTask","Concurrent/TimerTask.html#method-c-execute","(opts = {}, &task)","<p>Create and execute a new `TimerTask`.\n<p>@!macro timer_task_initialize\n<p>@example\n"],["execute","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-execute","()","<p>Execute a previously created `TimerTask`.\n<p>@return [TimerTask] a reference to `self`\n<p>@example Instance and \n"],["execute_next_job","Concurrent::Agent","Concurrent/Agent.html#method-i-execute_next_job","()",""],["execute_task","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-execute_task","(completion)","<p>@!visibility private\n"],["execution_interval","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-execution_interval","()","<p>@!attribute [rw] execution_interval @return [Fixnum] Number of seconds after the task completes before \n"],["execution_interval=","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-execution_interval-3D","(value)","<p>@!attribute [rw] execution_interval @return [Fixnum] Number of seconds after the task completes before \n"],["executor","Concurrent","Concurrent.html#method-c-executor","(executor_identifier)","<p>General access point to global executors. @param [Symbol, Executor] executor_identifier symbols:\n\n<pre class=\"ruby\"><span class=\"ruby-operator\">-</span> <span class=\"ruby-value\">:fast</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["executor","Concurrent::Options","Concurrent/Options.html#method-c-executor","(executor_identifier)",""],["executor","Concurrent::Promises::BlockedTaskPromise","Concurrent/Promises/BlockedTaskPromise.html#method-i-executor","()",""],["expand_table_unless_stale","Concurrent::ThreadSafe::Util::Striped64","Concurrent/ThreadSafe/Util/Striped64.html#method-i-expand_table_unless_stale","(current_cells)",""],["extended","Concurrent::ReInclude","Concurrent/ReInclude.html#method-i-extended","(base)","<p>@!visibility private\n"],["fail","Concurrent::IVar","Concurrent/IVar.html#method-i-fail","(reason = StandardError.new)","<p>@!macro ivar_fail_method\n\n<pre>Set the `IVar` to failed due to some error and wake or notify all threads waiting ...</pre>\n"],["fail","Concurrent::Promise","Concurrent/Promise.html#method-i-fail","(reason = StandardError.new)","<p>@!macro ivar_fail_method\n<p>@raise [Concurrent::PromiseExecutionError] if not the root promise\n"],["failed?","Concurrent::Agent","Concurrent/Agent.html#method-i-failed-3F","()","<p>Is the Agent in a failed state?\n<p>@see #restart\n"],["false?","Concurrent::MutexAtomicBoolean","Concurrent/MutexAtomicBoolean.html#method-i-false-3F","()","<p>@!macro atomic_boolean_method_false_question\n"],["fetch","Concurrent::Map","Concurrent/Map.html#method-i-fetch","(key, default_value = NULL)","<p>Get a value with key, or default_value when key is absent, or fail when no default_value is given. @param \n"],["fetch_or_store","Concurrent::Map","Concurrent/Map.html#method-i-fetch_or_store","(key, default_value = NULL)","<p>Fetch value with key, or store default value when key is absent, or fail when no default_value is given. \n"],["find_value_in_node_list","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-find_value_in_node_list","(node, key, hash, pure_hash)",""],["flat","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-flat","(level = 1)",""],["flat_event","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-flat_event","()","<p>Creates new event which will be resolved when the returned event by receiver is. Be careful if the receiver \n"],["flat_future","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-flat_future","(level = 1)","<p>Creates new future which will have result of the future returned by receiver. If receiver rejects it \n"],["flat_map","Concurrent::Promise","Concurrent/Promise.html#method-i-flat_map","(&block)","<p>Yield the successful result to the block that returns a promise. If that promise is also successful the \n"],["force_acquire_lock","Concurrent::Collection::AtomicReferenceMapBackend::Node","Concurrent/Collection/AtomicReferenceMapBackend/Node.html#method-i-force_acquire_lock","(table, i)",""],["free?","Concurrent::ThreadSafe::Util::Striped64","Concurrent/ThreadSafe/Util/Striped64.html#method-i-free-3F","()",""],["from","Concurrent::Maybe","Concurrent/Maybe.html#method-c-from","(*args)","<p>Create a new `Maybe` using the given block.\n<p>Runs the given block passing all function arguments to the \n"],["from_list","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-c-from_list","(list, opts = {})","<p>@!macro priority_queue_method_from_list\n"],["from_list","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-c-from_list","(list, opts = {})","<p>@!macro priority_queue_method_from_list\n"],["fulfill","Concurrent::Promise","Concurrent/Promise.html#method-c-fulfill","(value, opts = {})","<p>Create a new `Promise` and fulfill it immediately.\n<p>@!macro executor_and_deref_options\n<p>@!macro promise_init_options \n"],["fulfill","Concurrent::Promises::ResolvableFuture","Concurrent/Promises/ResolvableFuture.html#method-i-fulfill","(value, raise_on_reassign = true, reserved = false)","<p>Makes the future fulfilled with `value`, which triggers all dependent futures.\n<p>@param [Object] value @!macro \n"],["fulfilled?","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-fulfilled-3F","()","<p>Has the obligation been fulfilled?\n<p>@return [Boolean]\n"],["fulfilled?","Concurrent::Maybe","Concurrent/Maybe.html#method-i-fulfilled-3F","()",""],["fulfilled?","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-fulfilled-3F","()","<p>Is it in fulfilled state? @return [Boolean]\n"],["fulfilled?","Concurrent::Promises::InternalStates::Fulfilled","Concurrent/Promises/InternalStates/Fulfilled.html#method-i-fulfilled-3F","()",""],["fulfilled?","Concurrent::Promises::InternalStates::PartiallyRejected","Concurrent/Promises/InternalStates/PartiallyRejected.html#method-i-fulfilled-3F","()",""],["fulfilled?","Concurrent::Promises::InternalStates::Rejected","Concurrent/Promises/InternalStates/Rejected.html#method-i-fulfilled-3F","()",""],["fulfilled?","Concurrent::Promises::InternalStates::ResolvedWithResult","Concurrent/Promises/InternalStates/ResolvedWithResult.html#method-i-fulfilled-3F","()",""],["fulfilled_future","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-fulfilled_future","(value, default_executor = self.default_executor)","<p>Creates resolved future with will be fulfilled with the given value.\n<p>@!macro promises.param.default_executor \n"],["full?","Concurrent::MVar","Concurrent/MVar.html#method-i-full-3F","()","<p>Returns if the `MVar` currently contains a value.\n"],["full_memory_barrier","Concurrent::Synchronization::AbstractObject","Concurrent/Synchronization/AbstractObject.html#method-i-full_memory_barrier","()","<p>@!visibility private @abstract\n"],["full_memory_barrier","Concurrent::Synchronization::MriAttrVolatile","Concurrent/Synchronization/MriAttrVolatile.html#method-i-full_memory_barrier","()",""],["full_memory_barrier","Concurrent::Synchronization::RbxAttrVolatile","Concurrent/Synchronization/RbxAttrVolatile.html#method-i-full_memory_barrier","()",""],["full_memory_barrier","Concurrent::Synchronization::TruffleRubyAttrVolatile","Concurrent/Synchronization/TruffleRubyAttrVolatile.html#method-i-full_memory_barrier","()",""],["future","Concurrent::Promises::AbstractPromise","Concurrent/Promises/AbstractPromise.html#method-i-future","()",""],["future","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-future","(*args, &task)","<p>@!macro promises.shortcut.on @return [Future]\n"],["future_on","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-future_on","(default_executor, *args, &task)","<p>Constructs new Future which will be resolved after block is evaluated on default executor. Evaluation \n"],["get","Concurrent::AtomicMarkableReference","Concurrent/AtomicMarkableReference.html#method-i-get","()","<p>Gets the current reference and marked values.\n<p>@return [Array] the current reference and marked values \n"],["get","Concurrent::Map","Concurrent/Map.html#method-i-get","(key)",""],["get","Concurrent::MutexAtomicReference","Concurrent/MutexAtomicReference.html#method-i-get","()","<p>@!macro atomic_reference_method_get\n"],["get","Concurrent::ThreadSafe::Util::XorShiftRandom","Concurrent/ThreadSafe/Util/XorShiftRandom.html#method-i-get","()","<p>Generates an initial non-zero positive <code>Fixnum</code> via <code>Kernel.rand</code>.\n"],["get","Concurrent::Tuple","Concurrent/Tuple.html#method-i-get","(i)","<p>Get the value of the element at the given index.\n<p>@param [Integer] i the index from which to retrieve the \n"],["get_and_set","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-get_and_set","(key, value)",""],["get_and_set","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-i-get_and_set","(key, value)",""],["get_and_set","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-get_and_set","(key, value)",""],["get_and_set","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-get_and_set","(key, value)",""],["get_and_set","Concurrent::MutexAtomicReference","Concurrent/MutexAtomicReference.html#method-i-get_and_set","(new_value)","<p>@!macro atomic_reference_method_get_and_set\n"],["get_arguments_from","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-get_arguments_from","(opts = {})","<p>@!visibility private\n"],["get_or_default","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-get_or_default","(key, else_value = nil)",""],["get_or_default","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-get_or_default","(key, default_value)",""],["get_or_default","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-get_or_default","(key, default_value)",""],["get_threadlocal_array","Concurrent::RubyThreadLocalVar","Concurrent/RubyThreadLocalVar.html#method-i-get_threadlocal_array","(thread = Thread.current)",""],["get_time","Concurrent","Concurrent.html#method-i-get_time","()","<p>@!visibility private\n"],["global_fast_executor","Concurrent","Concurrent.html#method-c-global_fast_executor","()","<p>Global thread pool optimized for short, fast <strong>operations</strong>.\n<p>@return [ThreadPoolExecutor] the thread pool \n"],["global_immediate_executor","Concurrent","Concurrent.html#method-c-global_immediate_executor","()",""],["global_io_executor","Concurrent","Concurrent.html#method-c-global_io_executor","()","<p>Global thread pool optimized for long, blocking (IO) <strong>tasks</strong>.\n<p>@return [ThreadPoolExecutor] the thread pool \n"],["global_logger","Concurrent","Concurrent.html#method-c-global_logger","()",""],["global_logger=","Concurrent","Concurrent.html#method-c-global_logger-3D","(value)",""],["global_timer_set","Concurrent","Concurrent.html#method-c-global_timer_set","()","<p>Global thread pool user for global <strong>timers</strong>.\n<p>@return [Concurrent::TimerSet] the thread pool\n"],["handle_error","Concurrent::Agent","Concurrent/Agent.html#method-i-handle_error","(error)",""],["handle_fallback","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-handle_fallback","(*args)","<p>Handler which executes the `fallback_policy` once the queue size reaches `max_queue`.\n<p>@param [Array] args \n"],["handler?","Concurrent::AtExitImplementation","Concurrent/AtExitImplementation.html#method-i-handler-3F","(handler_id)","<p>Is handler with handler_id rpesent? @return [true, false]\n"],["handlers","Concurrent::AtExitImplementation","Concurrent/AtExitImplementation.html#method-i-handlers","()","<p>@return copy of the handlers\n"],["has_priority?","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-has_priority-3F","(item)",""],["has_priority?","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-has_priority-3F","(item)",""],["has_waiters?","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-has_waiters-3F","()","<p>Queries whether any threads are waiting to acquire the read or write lock.\n<p>@return [Boolean] true if any \n"],["hash_code","Concurrent::ThreadSafe::Util::Striped64","Concurrent/ThreadSafe/Util/Striped64.html#method-i-hash_code","()","<p>A thread-local hash code accessor. The code is initially random, but may be set to a different value \n"],["hash_code=","Concurrent::ThreadSafe::Util::Striped64","Concurrent/ThreadSafe/Util/Striped64.html#method-i-hash_code-3D","(hash)",""],["hash_to_index","Concurrent::ThreadSafe::Util::PowerOfTwoTuple","Concurrent/ThreadSafe/Util/PowerOfTwoTuple.html#method-i-hash_to_index","(hash)",""],["idletime","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-i-idletime","()","<p>@!macro thread_pool_executor_attr_reader_idletime\n"],["if_state","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-if_state","(*expected_states)","<p>Executes the block within mutex if current state is included in expected_states\n<p>@return block value if \n"],["immutable_array","Concurrent::AtomicMarkableReference","Concurrent/AtomicMarkableReference.html#method-i-immutable_array","(*args)",""],["include","Concurrent::ReInclude","Concurrent/ReInclude.html#method-i-include","(*modules)","<p>@!visibility private\n"],["include?","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-include-3F","(item)","<p>@!macro priority_queue_method_include\n"],["include?","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-include-3F","(item)","<p>@!macro priority_queue_method_include\n"],["included","Concurrent::Async","Concurrent/Async.html#method-c-included","(base)","<p>@!visibility private\n"],["included","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-c-included","(base)",""],["included","Concurrent::ReInclude","Concurrent/ReInclude.html#method-i-included","(base)","<p>@!visibility private\n"],["included","Concurrent::Synchronization::JRubyAttrVolatile","Concurrent/Synchronization/JRubyAttrVolatile.html#method-c-included","(base)",""],["included","Concurrent::Synchronization::MriAttrVolatile","Concurrent/Synchronization/MriAttrVolatile.html#method-c-included","(base)",""],["included","Concurrent::Synchronization::RbxAttrVolatile","Concurrent/Synchronization/RbxAttrVolatile.html#method-c-included","(base)",""],["included","Concurrent::Synchronization::TruffleRubyAttrVolatile","Concurrent/Synchronization/TruffleRubyAttrVolatile.html#method-c-included","(base)",""],["incomplete?","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-incomplete-3F","()","<p>Is the obligation still awaiting completion of processing?\n<p>@return [Boolean]\n"],["increment","Concurrent::MutexAtomicFixnum","Concurrent/MutexAtomicFixnum.html#method-i-increment","(delta = 1)","<p>@!macro atomic_fixnum_method_increment\n"],["increment","Concurrent::ThreadSafe::Util::Adder","Concurrent/ThreadSafe/Util/Adder.html#method-i-increment","()",""],["increment_size","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-increment_size","()",""],["index","Concurrent::Map","Concurrent/Map.html#method-i-index","(value)",""],["init_obligation","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-init_obligation","()","<p>@!visibility private\n"],["init_synchronization","Concurrent::Async","Concurrent/Async.html#method-i-init_synchronization","()","<p>Initialize the internal serializer and other stnchronization mechanisms.\n<p>@note This method <strong>must</strong> be called \n"],["initial_delay","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-initial_delay","()","<p>The `delay` value given at instanciation.\n<p>@return [Float] the initial delay.\n"],["initialize_copy","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-initialize_copy","(other)",""],["initialize_copy","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-initialize_copy","(other)",""],["initialize_copy","Concurrent::Map","Concurrent/Map.html#method-i-initialize_copy","(other)",""],["initialize_table","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-initialize_table","()","<p>Initializes table, using the size recorded in <code>size_control</code>.\n"],["inspect","AtomicReference","AtomicReference.html#method-i-inspect","()",""],["inspect","Concurrent::AtomicBoolean","Concurrent/AtomicBoolean.html#method-i-inspect","()",""],["inspect","Concurrent::AtomicFixnum","Concurrent/AtomicFixnum.html#method-i-inspect","()",""],["inspect","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-inspect","()","<p>@!macro struct_inspect\n"],["inspect","Concurrent::LockFreeStack","Concurrent/LockFreeStack.html#method-i-inspect","()",""],["inspect","Concurrent::Map","Concurrent/Map.html#method-i-inspect","()","<p>@!visibility private\n"],["inspect","Concurrent::MultipleAssignmentError","Concurrent/MultipleAssignmentError.html#method-i-inspect","()",""],["inspect","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-inspect","()","<p>@!macro struct_inspect\n\n<pre>Describe the contents of this struct in a string.\n\n@return [String] the contents ...</pre>\n"],["inspect","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-inspect","()",""],["inspect","Concurrent::Promises::AbstractPromise","Concurrent/Promises/AbstractPromise.html#method-i-inspect","()",""],["inspect","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-inspect","()",""],["inspect","Concurrent::Promises::ScheduledPromise","Concurrent/Promises/ScheduledPromise.html#method-i-inspect","()",""],["inspect","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-inspect","()","<p>@!macro struct_inspect\n"],["install","Concurrent::AtExitImplementation","Concurrent/AtExitImplementation.html#method-i-install","()","<p>install `Kernel#at_exit` callback to execute added handlers\n"],["intended_time","Concurrent::Promises::ScheduledPromise","Concurrent/Promises/ScheduledPromise.html#method-i-intended_time","()",""],["internal_compute","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-internal_compute","(key, &block)",""],["internal_replace","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-internal_replace","(key, expected_old_value = NULL, &block)","<p>Internal versions of the insertion methods, each a little more complicated than the last. All have the \n"],["internal_reset","Concurrent::ThreadSafe::Util::Striped64","Concurrent/ThreadSafe/Util/Striped64.html#method-i-internal_reset","(initial_value)","<p>Sets base and all <code>cells</code> to the given value.\n"],["item","Concurrent::RubyExchanger::Node","Concurrent/RubyExchanger/Node.html#method-i-item","()",""],["java_extensions_loaded?","Concurrent::Utility::NativeExtensionLoader","Concurrent/Utility/NativeExtensionLoader.html#method-i-java_extensions_loaded-3F","()",""],["just","Concurrent::Maybe","Concurrent/Maybe.html#method-c-just","(value)","<p>Create a new `Just` with the given value.\n<p>@param [Object] value The value to set for the new `Maybe` object. \n"],["just?","Concurrent::Maybe","Concurrent/Maybe.html#method-i-just-3F","()","<p>Is this `Maybe` a `Just` (successfully fulfilled with a value)?\n<p>@return [Boolean] True if `Just` or false \n"],["key","Concurrent::Map","Concurrent/Map.html#method-i-key","(value)","<p>Find key of a value. @param [Object] value @return [Object, nil] key or nil when not found\n"],["key?","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-key-3F","(key)",""],["key?","Concurrent::Collection::AtomicReferenceMapBackend::Node","Concurrent/Collection/AtomicReferenceMapBackend/Node.html#method-i-key-3F","(key)",""],["key?","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-key-3F","(key)",""],["key?","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-key-3F","(key)",""],["key_hash","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-key_hash","(key)",""],["keys","Concurrent::Map","Concurrent/Map.html#method-i-keys","()","<p>All keys @return [::Array&lt;Object&gt;] keys\n"],["kill","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-kill","()","<p>@!macro executor_service_method_kill\n"],["kill","Concurrent::ImmediateExecutor","Concurrent/ImmediateExecutor.html#method-i-kill","()",""],["kill","Concurrent::JavaExecutorService","Concurrent/JavaExecutorService.html#method-i-kill","()",""],["kill","Concurrent::RubyExecutorService","Concurrent/RubyExecutorService.html#method-i-kill","()",""],["kill","Concurrent::RubyThreadPoolExecutor::Worker","Concurrent/RubyThreadPoolExecutor/Worker.html#method-i-kill","()",""],["kill","Concurrent::SimpleExecutorService","Concurrent/SimpleExecutorService.html#method-i-kill","()","<p>@!macro executor_service_method_kill\n"],["kill","Concurrent::TimerSet","Concurrent/TimerSet.html#method-i-kill","()","<p>Begin an immediate shutdown. In-progress tasks will be allowed to complete but enqueued tasks will be \n"],["largest_length","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-i-largest_length","()","<p>@!macro thread_pool_executor_attr_reader_largest_length\n"],["largest_length","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-largest_length","()","<p>@!macro thread_pool_executor_attr_reader_largest_length\n"],["latch","Concurrent::RubyExchanger::Node","Concurrent/RubyExchanger/Node.html#method-i-latch","()",""],["leave_transaction","Concurrent","Concurrent.html#method-c-leave_transaction","()","<p>Leave a transaction without committing or aborting - see `Concurrent::atomically`.\n"],["leave_transaction","Concurrent","Concurrent.html#method-i-leave_transaction","()","<p>Leave a transaction without committing or aborting - see `Concurrent::atomically`.\n"],["length","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-length","()","<p>@!macro priority_queue_method_length\n"],["length","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-length","()","<p>@!macro priority_queue_method_length\n"],["length","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-i-length","()","<p>@!macro thread_pool_executor_attr_reader_length\n"],["length","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-length","()","<p>@!macro thread_pool_executor_attr_reader_length\n"],["length","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-length","()","<p>@!macro struct_length\n\n<pre>Returns the number of struct members.\n\n@return [Fixnum] the number of struct members</pre>\n"],["load_error_path","Concurrent::Utility::NativeExtensionLoader","Concurrent/Utility/NativeExtensionLoader.html#method-i-load_error_path","(error)",""],["load_native_extensions","Concurrent::Utility::NativeExtensionLoader","Concurrent/Utility/NativeExtensionLoader.html#method-i-load_native_extensions","()",""],["lock_and_clean_up_reverse_forwarders","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-lock_and_clean_up_reverse_forwarders","(old_table, old_table_size, new_table, i, forwarder)",""],["locked?","Concurrent::Collection::AtomicReferenceMapBackend::Node","Concurrent/Collection/AtomicReferenceMapBackend/Node.html#method-i-locked-3F","()",""],["locked_hash?","Concurrent::Collection::AtomicReferenceMapBackend::Node","Concurrent/Collection/AtomicReferenceMapBackend/Node.html#method-c-locked_hash-3F","(hash)",""],["log","Concurrent::Concern::Logging","Concurrent/Concern/Logging.html#method-i-log","(level, progname, message = nil, &block)","<p>Logs through {Concurrent.global_logger}, it can be overridden by setting @logger @param [Integer] level \n"],["make_false","Concurrent::MutexAtomicBoolean","Concurrent/MutexAtomicBoolean.html#method-i-make_false","()","<p>@!macro atomic_boolean_method_make_false\n"],["make_future","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-make_future","(argument = nil, default_executor = self.default_executor)","<p>General constructor. Behaves differently based on the argument&#39;s type. It&#39;s provided for convenience \n"],["make_synchronized_on_rbx","Concurrent::ThreadSafe::Util","Concurrent/ThreadSafe/Util.html#method-c-make_synchronized_on_rbx","(klass)",""],["make_synchronized_on_truffleruby","Concurrent::ThreadSafe::Util","Concurrent/ThreadSafe/Util.html#method-c-make_synchronized_on_truffleruby","(klass)",""],["make_true","Concurrent::MutexAtomicBoolean","Concurrent/MutexAtomicBoolean.html#method-i-make_true","()","<p>@!macro atomic_boolean_method_make_true\n"],["mark","Concurrent::AtomicMarkableReference","Concurrent/AtomicMarkableReference.html#method-i-mark","()","<p>Gets the current marked value\n<p>@return [Boolean] the current marked value\n"],["marked?","Concurrent::AtomicMarkableReference","Concurrent/AtomicMarkableReference.html#method-i-marked-3F","()",""],["marshal_dump","Concurrent::Map","Concurrent/Map.html#method-i-marshal_dump","()","<p>@!visibility private\n"],["marshal_load","Concurrent::Map","Concurrent/Map.html#method-i-marshal_load","(hash)","<p>@!visibility private\n"],["matches?","Concurrent::Collection::AtomicReferenceMapBackend::Node","Concurrent/Collection/AtomicReferenceMapBackend/Node.html#method-i-matches-3F","(key, hash)",""],["max_readers?","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-max_readers-3F","(c = @Counter.value)","<p>@!visibility private\n"],["max_readers?","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-max_readers-3F","(c = @Counter.value)","<p>@!visibility private\n"],["max_writers?","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-max_writers-3F","(c = @Counter.value)","<p>@!visibility private\n"],["max_writers?","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-max_writers-3F","(c = @Counter.value)","<p>@!visibility private\n"],["members","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-members","()","<p>@!macro struct_members\n\n<pre>Returns the struct members as an array of symbols.\n\n@return [Array] the struct ...</pre>\n"],["merge","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-merge","(other, &block)","<p>@!macro struct_merge\n"],["merge","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-merge","(other, &block)","<p>@!macro struct_merge\n\n<pre>Returns a new struct containing the contents of `other` and the contents\nof `self`. ...</pre>\n"],["merge","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-merge","(other, &block)","<p>@!macro struct_merge\n"],["merge_pair","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-merge_pair","(key, value)",""],["merge_pair","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-i-merge_pair","(key, value)",""],["merge_pair","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-merge_pair","(key, value)",""],["merge_pair","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-merge_pair","(key, value)",""],["method_missing","Concurrent::Async::AsyncDelegator","Concurrent/Async/AsyncDelegator.html#method-i-method_missing","(method, *args, &block)","<p>Delegates method calls to the wrapped object.\n<p>@param [Symbol] method the method being called @param [Array] \n"],["method_missing","Concurrent::Async::AwaitDelegator","Concurrent/Async/AwaitDelegator.html#method-i-method_missing","(method, *args, &block)","<p>Delegates method calls to the wrapped object.\n<p>@param [Symbol] method the method being called @param [Array] \n"],["method_missing","Concurrent::SynchronizedDelegator","Concurrent/SynchronizedDelegator.html#method-i-method_missing","(method, *args, &block)",""],["min_length","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-i-min_length","()","<p>@!macro thread_pool_executor_attr_reader_min_length\n"],["modify","Concurrent::MVar","Concurrent/MVar.html#method-i-modify","(timeout = nil)","<p>Atomically `take`, yield the value to a block for transformation, and then `put` the transformed value. \n"],["modify!","Concurrent::MVar","Concurrent/MVar.html#method-i-modify-21","()","<p>Non-blocking version of `modify` that will yield with `EMPTY` if there is no value yet.\n"],["monotonic_time","Concurrent","Concurrent.html#method-i-monotonic_time","()","<p>@!macro monotonic_get_time\n\n<pre>Returns the current time a tracked by the application monotonic clock.\n\n@return ...</pre>\n"],["monotonic_time","Concurrent","Concurrent.html#method-c-monotonic_time","()","<p>@!macro monotonic_get_time\n\n<pre>Returns the current time a tracked by the application monotonic clock.\n\n@return ...</pre>\n"],["new","Concurrent","Concurrent.html#method-c-new","()",""],["new","Concurrent::AbstractExchanger","Concurrent/AbstractExchanger.html#method-c-new","()",""],["new","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-c-new","(*args, &block)","<p>Create a new thread pool.\n"],["new","Concurrent::AbstractThreadLocalVar","Concurrent/AbstractThreadLocalVar.html#method-c-new","(default = nil, &default_block)","<p>@!macro thread_local_var_method_initialize\n"],["new","Concurrent::Agent","Concurrent/Agent.html#method-c-new","(initial, opts = {})","<p>Create a new `Agent` with the given initial value and options.\n<p>The `:validator` option must be `nil` or \n"],["new","Concurrent::Agent::Error","Concurrent/Agent/Error.html#method-c-new","(message = nil)",""],["new","Concurrent::Agent::ValidationError","Concurrent/Agent/ValidationError.html#method-c-new","(message = nil)",""],["new","Concurrent::Async::AsyncDelegator","Concurrent/Async/AsyncDelegator.html#method-c-new","(delegate)","<p>Create a new delegator object wrapping the given delegate.\n<p>@param [Object] delegate the object to wrap \n"],["new","Concurrent::Async::AwaitDelegator","Concurrent/Async/AwaitDelegator.html#method-c-new","(delegate)","<p>Create a new delegator object wrapping the given delegate.\n<p>@param [AsyncDelegator] delegate the object \n"],["new","Concurrent::Async::ClassMethods","Concurrent/Async/ClassMethods.html#method-i-new","(*args, &block)",""],["new","Concurrent::AtExitImplementation","Concurrent/AtExitImplementation.html#method-c-new","(*args)",""],["new","Concurrent::Atom","Concurrent/Atom.html#method-c-new","(value, opts = {})","<p>Create a new atom with the given initial value.\n<p>@param [Object] value The initial value @param [Hash] \n"],["new","Concurrent::AtomicMarkableReference","Concurrent/AtomicMarkableReference.html#method-c-new","(value = nil, mark = false)",""],["new","Concurrent::CachedThreadPool","Concurrent/CachedThreadPool.html#method-c-new","(opts = {})","<p>@!macro cached_thread_pool_method_initialize\n\n<pre>Create a new thread pool.\n\n@param [Hash] opts the options ...</pre>\n"],["new","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-c-new","(options = nil)",""],["new","Concurrent::Collection::AtomicReferenceMapBackend::Node","Concurrent/Collection/AtomicReferenceMapBackend/Node.html#method-c-new","(hash, key, value, next_node = nil)",""],["new","Concurrent::Collection::CopyOnNotifyObserverSet","Concurrent/Collection/CopyOnNotifyObserverSet.html#method-c-new","()",""],["new","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-c-new","()",""],["new","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-c-new","(opts = {})","<p>@!macro priority_queue_method_initialize\n"],["new","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-c-new","(options = nil)",""],["new","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-c-new","(options = nil)","<p>WARNING: all public methods of the class must operate on the @backend directly without calling each other. \n"],["new","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-c-new","(opts = {})","<p>@!macro priority_queue_method_initialize\n"],["new","Concurrent::CyclicBarrier","Concurrent/CyclicBarrier.html#method-c-new","(parties, &block)","<p>Create a new `CyclicBarrier` that waits for `parties` threads\n<p>@param [Fixnum] parties the number of parties \n"],["new","Concurrent::Delay","Concurrent/Delay.html#method-c-new","(opts = {}, &block)","<p>Create a new `Delay` in the `:pending` state.\n<p>@!macro executor_and_deref_options\n<p>@yield the delayed operation \n"],["new","Concurrent::Event","Concurrent/Event.html#method-c-new","()","<p>Creates a new `Event` in the unset state. Threads calling `#wait` on the `Event` will block.\n"],["new","Concurrent::FixedThreadPool","Concurrent/FixedThreadPool.html#method-c-new","(num_threads, opts = {})","<p>@!macro fixed_thread_pool_method_initialize\n\n<pre>Create a new thread pool.\n\n@param [Integer] num_threads the ...</pre>\n"],["new","Concurrent::Future","Concurrent/Future.html#method-c-new","(opts = {}, &block)","<p>Create a new `Future` in the `:unscheduled` state.\n<p>@yield the asynchronous operation to perform\n<p>@!macro \n"],["new","Concurrent::IVar","Concurrent/IVar.html#method-c-new","(value = NULL, opts = {}, &block)","<p>Create a new `IVar` in the `:pending` state with the (optional) initial value.\n<p>@param [Object] value the \n"],["new","Concurrent::ImmediateExecutor","Concurrent/ImmediateExecutor.html#method-c-new","()","<p>Creates a new executor\n"],["new","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-c-new","(*args, &block)","<p>@!macro struct_new\n"],["new","Concurrent::IndirectImmediateExecutor","Concurrent/IndirectImmediateExecutor.html#method-c-new","()","<p>Creates a new executor\n"],["new","Concurrent::JavaCountDownLatch","Concurrent/JavaCountDownLatch.html#method-c-new","(count = 1)","<p>@!macro count_down_latch_method_initialize\n"],["new","Concurrent::JavaExchanger","Concurrent/JavaExchanger.html#method-c-new","()",""],["new","Concurrent::JavaExecutorService","Concurrent/JavaExecutorService.html#method-c-new","(*args, &block)",""],["new","Concurrent::JavaExecutorService::Job","Concurrent/JavaExecutorService/Job.html#method-c-new","(args, block)",""],["new","Concurrent::JavaSingleThreadExecutor","Concurrent/JavaSingleThreadExecutor.html#method-c-new","(opts = {})","<p>@!macro single_thread_executor_method_initialize\n"],["new","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-c-new","(opts = {})","<p>@!macro thread_pool_executor_method_initialize\n"],["new","Concurrent::LockFreeStack","Concurrent/LockFreeStack.html#method-c-new","(head = EMPTY)","<p>@param [Node] head\n"],["new","Concurrent::LockFreeStack::Node","Concurrent/LockFreeStack/Node.html#method-c-new","(value, next_node)",""],["new","Concurrent::MVar","Concurrent/MVar.html#method-c-new","(value = EMPTY, opts = {})","<p>Create a new `MVar`, either empty or with an initial value.\n<p>@param [Hash] opts the options controlling \n"],["new","Concurrent::Map","Concurrent/Map.html#method-c-new","(options = nil, &block)","<p>@!method delete_pair(key, value)\n\n<pre>Delete pair and its value if current value equals the provided value. ...</pre>\n"],["new","Concurrent::Maybe","Concurrent/Maybe.html#method-c-new","(just, nothing)","<p>Create a new `Maybe` with the given attributes.\n<p>@param [Object] just The value when `Just` else `NONE`. \n"],["new","Concurrent::MultipleAssignmentError","Concurrent/MultipleAssignmentError.html#method-c-new","(message = nil, inspection_data = nil)",""],["new","Concurrent::MultipleErrors","Concurrent/MultipleErrors.html#method-c-new","(errors, message = \"#{errors.size} errors\")",""],["new","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-c-new","(*args, &block)","<p>@!macro struct_new\n"],["new","Concurrent::MutexAtomicBoolean","Concurrent/MutexAtomicBoolean.html#method-c-new","(initial = false)","<p>@!macro atomic_boolean_method_initialize\n"],["new","Concurrent::MutexAtomicFixnum","Concurrent/MutexAtomicFixnum.html#method-c-new","(initial = 0)","<p>@!macro atomic_fixnum_method_initialize\n"],["new","Concurrent::MutexAtomicReference","Concurrent/MutexAtomicReference.html#method-c-new","(value = nil)","<p>@!macro atomic_reference_method_initialize\n"],["new","Concurrent::MutexCountDownLatch","Concurrent/MutexCountDownLatch.html#method-c-new","(count = 1)","<p>@!macro count_down_latch_method_initialize\n"],["new","Concurrent::MutexSemaphore","Concurrent/MutexSemaphore.html#method-c-new","(count)","<p>@!macro semaphore_method_initialize\n"],["new","Concurrent::Promise","Concurrent/Promise.html#method-c-new","(opts = {}, &block)","<p>Initialize a new Promise with the provided options.\n<p>@!macro executor_and_deref_options\n<p>@!macro promise_init_options \n"],["new","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-c-new","(promise, default_executor)",""],["new","Concurrent::Promises::AbstractFlatPromise","Concurrent/Promises/AbstractFlatPromise.html#method-c-new","(delayed_because, blockers_count, event_or_future)",""],["new","Concurrent::Promises::AbstractPromise","Concurrent/Promises/AbstractPromise.html#method-c-new","(future)",""],["new","Concurrent::Promises::AnyResolvedEventPromise","Concurrent/Promises/AnyResolvedEventPromise.html#method-c-new","(delayed, blockers_count, default_executor)",""],["new","Concurrent::Promises::AnyResolvedFuturePromise","Concurrent/Promises/AnyResolvedFuturePromise.html#method-c-new","(delayed, blockers_count, default_executor)",""],["new","Concurrent::Promises::BlockedPromise","Concurrent/Promises/BlockedPromise.html#method-c-new","(future)",""],["new","Concurrent::Promises::BlockedPromise","Concurrent/Promises/BlockedPromise.html#method-c-new","(delayed, blockers_count, future)",""],["new","Concurrent::Promises::BlockedTaskPromise","Concurrent/Promises/BlockedTaskPromise.html#method-c-new","(delayed, blockers_count, default_executor, executor, args, &task)",""],["new","Concurrent::Promises::DelayPromise","Concurrent/Promises/DelayPromise.html#method-c-new","(default_executor)",""],["new","Concurrent::Promises::EventWrapperPromise","Concurrent/Promises/EventWrapperPromise.html#method-c-new","(delayed, blockers_count, default_executor)",""],["new","Concurrent::Promises::FlatEventPromise","Concurrent/Promises/FlatEventPromise.html#method-c-new","(delayed, blockers_count, default_executor)",""],["new","Concurrent::Promises::FlatFuturePromise","Concurrent/Promises/FlatFuturePromise.html#method-c-new","(delayed, blockers_count, levels, default_executor)",""],["new","Concurrent::Promises::FutureWrapperPromise","Concurrent/Promises/FutureWrapperPromise.html#method-c-new","(delayed, blockers_count, default_executor)",""],["new","Concurrent::Promises::ImmediateEventPromise","Concurrent/Promises/ImmediateEventPromise.html#method-c-new","(default_executor)",""],["new","Concurrent::Promises::ImmediateFuturePromise","Concurrent/Promises/ImmediateFuturePromise.html#method-c-new","(default_executor, fulfilled, value, reason)",""],["new","Concurrent::Promises::InternalStates::Fulfilled","Concurrent/Promises/InternalStates/Fulfilled.html#method-c-new","(value)",""],["new","Concurrent::Promises::InternalStates::PartiallyRejected","Concurrent/Promises/InternalStates/PartiallyRejected.html#method-c-new","(value, reason)",""],["new","Concurrent::Promises::InternalStates::Rejected","Concurrent/Promises/InternalStates/Rejected.html#method-c-new","(reason)",""],["new","Concurrent::Promises::RescuePromise","Concurrent/Promises/RescuePromise.html#method-c-new","(delayed, blockers_count, default_executor, executor, args, &task)",""],["new","Concurrent::Promises::ResolvableEventPromise","Concurrent/Promises/ResolvableEventPromise.html#method-c-new","(default_executor)",""],["new","Concurrent::Promises::ResolvableFuturePromise","Concurrent/Promises/ResolvableFuturePromise.html#method-c-new","(default_executor)",""],["new","Concurrent::Promises::RunFuturePromise","Concurrent/Promises/RunFuturePromise.html#method-c-new","(delayed, blockers_count, default_executor, run_test)",""],["new","Concurrent::Promises::ScheduledPromise","Concurrent/Promises/ScheduledPromise.html#method-c-new","(default_executor, intended_time)",""],["new","Concurrent::Promises::ThenPromise","Concurrent/Promises/ThenPromise.html#method-c-new","(delayed, blockers_count, default_executor, executor, args, &task)",""],["new","Concurrent::Promises::ZipEventEventPromise","Concurrent/Promises/ZipEventEventPromise.html#method-c-new","(delayed, blockers_count, default_executor)",""],["new","Concurrent::Promises::ZipEventsPromise","Concurrent/Promises/ZipEventsPromise.html#method-c-new","(delayed, blockers_count, default_executor)",""],["new","Concurrent::Promises::ZipFutureEventPromise","Concurrent/Promises/ZipFutureEventPromise.html#method-c-new","(delayed, blockers_count, default_executor)",""],["new","Concurrent::Promises::ZipFuturesPromise","Concurrent/Promises/ZipFuturesPromise.html#method-c-new","(delayed, blockers_count, default_executor)",""],["new","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-c-new","()","<p>Create a new `ReadWriteLock` in the unlocked state.\n"],["new","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-c-new","()","<p>Create a new `ReentrantReadWriteLock` in the unlocked state.\n"],["new","Concurrent::RubyExchanger","Concurrent/RubyExchanger.html#method-c-new","()",""],["new","Concurrent::RubyExchanger::Node","Concurrent/RubyExchanger/Node.html#method-c-new","(item)",""],["new","Concurrent::RubyExecutorService","Concurrent/RubyExecutorService.html#method-c-new","(*args, &block)",""],["new","Concurrent::RubySingleThreadExecutor","Concurrent/RubySingleThreadExecutor.html#method-c-new","(opts = {})","<p>@!macro single_thread_executor_method_initialize\n"],["new","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-c-new","(opts = {})","<p>@!macro thread_pool_executor_method_initialize\n"],["new","Concurrent::RubyThreadPoolExecutor::Worker","Concurrent/RubyThreadPoolExecutor/Worker.html#method-c-new","(pool)",""],["new","Concurrent::SafeTaskExecutor","Concurrent/SafeTaskExecutor.html#method-c-new","(task, opts = {})",""],["new","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-c-new","(delay, opts = {}, &task)","<p>Schedule a task for execution at a specified future time.\n<p>@param [Float] delay the number of seconds to \n"],["new","Concurrent::SerializedExecution","Concurrent/SerializedExecution.html#method-c-new","()",""],["new","Concurrent::SerializedExecutionDelegator","Concurrent/SerializedExecutionDelegator.html#method-c-new","(executor)",""],["new","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-c-new","(*args, &block)","<p>@!macro struct_new\n"],["new","Concurrent::Synchronization::AbstractObject","Concurrent/Synchronization/AbstractObject.html#method-c-new","()","<p>@abstract has to be implemented based on Ruby runtime\n"],["new","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-c-new","(*values)","<p>@!visibility private\n"],["new","Concurrent::Synchronization::Condition","Concurrent/Synchronization/Condition.html#method-c-new","(lock)",""],["new","Concurrent::Synchronization::JRubyObject","Concurrent/Synchronization/JRubyObject.html#method-c-new","()",""],["new","Concurrent::Synchronization::MonitorLockableObject","Concurrent/Synchronization/MonitorLockableObject.html#method-c-new","(*defaults)",""],["new","Concurrent::Synchronization::MriObject","Concurrent/Synchronization/MriObject.html#method-c-new","()",""],["new","Concurrent::Synchronization::MutexLockableObject","Concurrent/Synchronization/MutexLockableObject.html#method-c-new","(*defaults)",""],["new","Concurrent::Synchronization::Object","Concurrent/Synchronization/Object.html#method-c-new","()","<p>Has to be called by children.\n"],["new","Concurrent::Synchronization::Object","Concurrent/Synchronization/Object.html#method-c-new","(*args, &block)","<p>@!visibility private\n"],["new","Concurrent::Synchronization::RbxLockableObject","Concurrent/Synchronization/RbxLockableObject.html#method-c-new","(*defaults)",""],["new","Concurrent::Synchronization::RbxObject","Concurrent/Synchronization/RbxObject.html#method-c-new","()",""],["new","Concurrent::Synchronization::TruffleRubyObject","Concurrent/Synchronization/TruffleRubyObject.html#method-c-new","()",""],["new","Concurrent::SynchronizedDelegator","Concurrent/SynchronizedDelegator.html#method-c-new","(obj)",""],["new","Concurrent::TVar","Concurrent/TVar.html#method-c-new","(value)","<p>Create a new `TVar` with an initial value.\n"],["new","Concurrent::ThreadSafe::Util","Concurrent/ThreadSafe/Util.html#method-c-new","(*args)",""],["new","Concurrent::ThreadSafe::Util::PowerOfTwoTuple","Concurrent/ThreadSafe/Util/PowerOfTwoTuple.html#method-c-new","(size)",""],["new","Concurrent::ThreadSafe::Util::Striped64","Concurrent/ThreadSafe/Util/Striped64.html#method-c-new","()",""],["new","Concurrent::TimerSet","Concurrent/TimerSet.html#method-c-new","(opts = {})","<p>Create a new set of timed tasks.\n<p>@!macro executor_options\n\n<pre>@param [Hash] opts the options used to specify ...</pre>\n"],["new","Concurrent::TimerTask","Concurrent/TimerTask.html#method-c-new","(opts = {}, &task)","<p>Create a new TimerTask with the given task and configuration.\n<p>@!macro timer_task_initialize\n\n<pre class=\"ruby\"><span class=\"ruby-ivar\">@param</span> [<span class=\"ruby-constant\">Hash</span>] <span class=\"ruby-operator\">...</span>\n</pre>\n"],["new","Concurrent::Transaction","Concurrent/Transaction.html#method-c-new","()",""],["new","Concurrent::Tuple","Concurrent/Tuple.html#method-c-new","(size)","<p>Create a new tuple of the given size.\n<p>@param [Integer] size the number of elements in the tuple\n"],["new","Concurrent::Utility::ProcessorCounter","Concurrent/Utility/ProcessorCounter.html#method-c-new","()",""],["new_blocked_by","Concurrent::Promises::BlockedPromise","Concurrent/Promises/BlockedPromise.html#method-c-new_blocked_by","(blockers, *args, &block)",""],["new_blocked_by1","Concurrent::Promises::BlockedPromise","Concurrent/Promises/BlockedPromise.html#method-c-new_blocked_by1","(blocker, *args, &block)",""],["new_blocked_by2","Concurrent::Promises::BlockedPromise","Concurrent/Promises/BlockedPromise.html#method-c-new_blocked_by2","(blocker1, blocker2, *args, &block)",""],["new_condition","Concurrent::Synchronization::LockableObject","Concurrent/Synchronization/LockableObject.html#method-i-new_condition","()",""],["new_fast_executor","Concurrent","Concurrent.html#method-c-new_fast_executor","(opts = {})",""],["new_io_executor","Concurrent","Concurrent.html#method-c-new_io_executor","(opts = {})",""],["next_in_size_table","Concurrent::ThreadSafe::Util::PowerOfTwoTuple","Concurrent/ThreadSafe/Util/PowerOfTwoTuple.html#method-i-next_in_size_table","()",""],["no_error!","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-no_error-21","(timeout = nil)",""],["nothing","Concurrent::Maybe","Concurrent/Maybe.html#method-c-nothing","(error = '')","<p>Create a new `Nothing` with the given (optional) reason.\n<p>@param [Exception] error The reason to set for \n"],["nothing?","Concurrent::Maybe","Concurrent/Maybe.html#method-i-nothing-3F","()","<p>Is this `Maybe` a `nothing` (rejected with an exception upon fulfillment)?\n<p>@return [Boolean] True if `Nothing` \n"],["notify_and_delete_observers","Concurrent::Collection::CopyOnNotifyObserverSet","Concurrent/Collection/CopyOnNotifyObserverSet.html#method-i-notify_and_delete_observers","(*args, &block)","<p>Notifies all registered observers with optional args and deletes them.\n<p>@param [Object] args arguments \n"],["notify_and_delete_observers","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-i-notify_and_delete_observers","(*args, &block)","<p>Notifies all registered observers with optional args and deletes them.\n<p>@param [Object] args arguments \n"],["notify_child","Concurrent::Promise","Concurrent/Promise.html#method-i-notify_child","(child)","<p>@!visibility private\n"],["notify_observers","Concurrent::Collection::CopyOnNotifyObserverSet","Concurrent/Collection/CopyOnNotifyObserverSet.html#method-i-notify_observers","(*args, &block)","<p>Notifies all registered observers with optional args @param [Object] args arguments to be passed to each \n"],["notify_observers","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-i-notify_observers","(*args, &block)","<p>Notifies all registered observers with optional args @param [Object] args arguments to be passed to each \n"],["notify_observers","Concurrent::IVar","Concurrent/IVar.html#method-i-notify_observers","(value, reason)","<p>@!visibility private\n"],["notify_to","Concurrent::Collection::CopyOnNotifyObserverSet","Concurrent/Collection/CopyOnNotifyObserverSet.html#method-i-notify_to","(observers, *args)",""],["notify_to","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-i-notify_to","(observers, *args)",""],["ns_add_busy_worker","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_add_busy_worker","()","<p>creates new worker which has to receive work to do after it&#39;s added @return [nil, Worker] nil of \n"],["ns_assign_worker","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_assign_worker","(*args, &task)","<p>tries to assign task to a worker, tries to get one from @ready or to create new one @return [true, false] \n"],["ns_auto_terminate=","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-ns_auto_terminate-3D","(value)",""],["ns_auto_terminate?","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-ns_auto_terminate-3F","()",""],["ns_broadcast","Concurrent::Synchronization::AbstractLockableObject","Concurrent/Synchronization/AbstractLockableObject.html#method-i-ns_broadcast","()","<p>@!macro synchronization_object_method_ns_broadcast\n\n<pre>Broadcast to all waiting threads.\n@return [self]\n@note ...</pre>\n"],["ns_broadcast","Concurrent::Synchronization::Condition","Concurrent/Synchronization/Condition.html#method-i-ns_broadcast","()",""],["ns_broadcast","Concurrent::Synchronization::ConditionSignalling","Concurrent/Synchronization/ConditionSignalling.html#method-i-ns_broadcast","()",""],["ns_broadcast","Concurrent::Synchronization::RbxLockableObject","Concurrent/Synchronization/RbxLockableObject.html#method-i-ns_broadcast","()",""],["ns_check_state?","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-ns_check_state-3F","(expected)","<p>Am I in the current state?\n<p>@param [Symbol] expected The state to check against @return [Boolean] true \n"],["ns_complete_without_notification","Concurrent::IVar","Concurrent/IVar.html#method-i-ns_complete_without_notification","(success, value, reason)","<p>@!visibility private\n"],["ns_each","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-ns_each","()","<p>@!macro struct_each\n<p>@!visibility private\n"],["ns_each_pair","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-ns_each_pair","()","<p>@!macro struct_each_pair\n<p>@!visibility private\n"],["ns_enqueue","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_enqueue","(*args, &task)","<p>tries to enqueue task @return [true, false] if enqueued\n<p>@!visibility private\n"],["ns_enqueue_job","Concurrent::Agent","Concurrent/Agent.html#method-i-ns_enqueue_job","(job, index = nil)",""],["ns_equality","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-ns_equality","(other)","<p>@!macro struct_equality\n<p>@!visibility private\n"],["ns_execute","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-ns_execute","(*args, &task)",""],["ns_execute","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_execute","(*args, &task)","<p>@!visibility private\n"],["ns_find_last_job_for_thread","Concurrent::Agent","Concurrent/Agent.html#method-i-ns_find_last_job_for_thread","()",""],["ns_generation_done","Concurrent::CyclicBarrier","Concurrent/CyclicBarrier.html#method-i-ns_generation_done","(generation, status, continue = true)",""],["ns_get","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-ns_get","(member)","<p>@!macro struct_get\n<p>@!visibility private\n"],["ns_initialize","Concurrent::Agent","Concurrent/Agent.html#method-i-ns_initialize","(initial, opts)",""],["ns_initialize","Concurrent::AtExitImplementation","Concurrent/AtExitImplementation.html#method-i-ns_initialize","(enabled = true)",""],["ns_initialize","Concurrent::CachedThreadPool","Concurrent/CachedThreadPool.html#method-i-ns_initialize","(opts)","<p>@!macro cached_thread_pool_method_initialize @!visibility private\n"],["ns_initialize","Concurrent::Collection::CopyOnNotifyObserverSet","Concurrent/Collection/CopyOnNotifyObserverSet.html#method-i-ns_initialize","()",""],["ns_initialize","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-i-ns_initialize","()",""],["ns_initialize","Concurrent::CyclicBarrier","Concurrent/CyclicBarrier.html#method-i-ns_initialize","(parties, &block)",""],["ns_initialize","Concurrent::Delay","Concurrent/Delay.html#method-i-ns_initialize","(opts, &block)",""],["ns_initialize","Concurrent::Event","Concurrent/Event.html#method-i-ns_initialize","()",""],["ns_initialize","Concurrent::Future","Concurrent/Future.html#method-i-ns_initialize","(value, opts)",""],["ns_initialize","Concurrent::IVar","Concurrent/IVar.html#method-i-ns_initialize","(value, opts)","<p>@!visibility private\n"],["ns_initialize","Concurrent::JavaSingleThreadExecutor","Concurrent/JavaSingleThreadExecutor.html#method-i-ns_initialize","(opts)",""],["ns_initialize","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-i-ns_initialize","(opts)",""],["ns_initialize","Concurrent::MutexAtomicBoolean","Concurrent/MutexAtomicBoolean.html#method-i-ns_initialize","(initial)","<p>@!visibility private\n"],["ns_initialize","Concurrent::MutexAtomicFixnum","Concurrent/MutexAtomicFixnum.html#method-i-ns_initialize","(initial)","<p>@!visibility private\n"],["ns_initialize","Concurrent::MutexAtomicReference","Concurrent/MutexAtomicReference.html#method-i-ns_initialize","(value)",""],["ns_initialize","Concurrent::MutexCountDownLatch","Concurrent/MutexCountDownLatch.html#method-i-ns_initialize","(count)",""],["ns_initialize","Concurrent::MutexSemaphore","Concurrent/MutexSemaphore.html#method-i-ns_initialize","(count)","<p>@!visibility private\n"],["ns_initialize","Concurrent::Promise","Concurrent/Promise.html#method-i-ns_initialize","(value, opts)",""],["ns_initialize","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_initialize","(opts)","<p>@!visibility private\n"],["ns_initialize","Concurrent::SerializedExecution","Concurrent/SerializedExecution.html#method-i-ns_initialize","()",""],["ns_initialize","Concurrent::SimpleExecutorService","Concurrent/SimpleExecutorService.html#method-i-ns_initialize","()",""],["ns_initialize","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-ns_initialize","(*values)",""],["ns_initialize","Concurrent::TimerSet","Concurrent/TimerSet.html#method-i-ns_initialize","(opts)","<p>Initialize the object.\n<p>@param [Hash] opts the options to create the object with. @!visibility private \n"],["ns_initialize","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-ns_initialize","(opts, &task)",""],["ns_inspect","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-ns_inspect","()","<p>@!macro struct_inspect\n<p>@!visibility private\n"],["ns_kill_execution","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-ns_kill_execution","()","<p>@!macro executor_service_method_ns_kill_execution\n\n<pre>Callback method called when the executor has been killed. ...</pre>\n"],["ns_kill_execution","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_kill_execution","()","<p>@!visibility private\n"],["ns_kill_execution","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-ns_kill_execution","()","<p>@!visibility private\n"],["ns_limited_queue?","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_limited_queue-3F","()","<p>@!visibility private\n"],["ns_make_value","Concurrent::MutexAtomicBoolean","Concurrent/MutexAtomicBoolean.html#method-i-ns_make_value","(value)","<p>@!visibility private\n"],["ns_merge","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-ns_merge","(other, &block)","<p>@!macro struct_merge\n<p>@!visibility private\n"],["ns_next_generation","Concurrent::CyclicBarrier","Concurrent/CyclicBarrier.html#method-i-ns_next_generation","()",""],["ns_post_next_job","Concurrent::Agent","Concurrent/Agent.html#method-i-ns_post_next_job","()",""],["ns_post_task","Concurrent::TimerSet","Concurrent/TimerSet.html#method-i-ns_post_task","(task)","<p>@!visibility private\n"],["ns_prune_pool","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_prune_pool","()","<p>try oldest worker if it is idle for enough time, it&#39;s returned back at the start\n<p>@!visibility private \n"],["ns_ready_worker","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_ready_worker","(worker, success = true)","<p>handle ready worker, giving it new job or assigning back to @ready\n<p>@!visibility private\n"],["ns_remove_busy_worker","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_remove_busy_worker","(worker)","<p>removes a worker which is not in not tracked in @ready\n<p>@!visibility private\n"],["ns_reschedule","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-ns_reschedule","(delay)","<p>Reschedule the task using the given delay and the current time. A task can only be reset while it is \n"],["ns_reset_if_forked","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_reset_if_forked","()",""],["ns_reset_if_forked","Concurrent::TimerSet","Concurrent/TimerSet.html#method-i-ns_reset_if_forked","()",""],["ns_running?","Concurrent::JavaExecutorService","Concurrent/JavaExecutorService.html#method-i-ns_running-3F","()",""],["ns_running?","Concurrent::RubyExecutorService","Concurrent/RubyExecutorService.html#method-i-ns_running-3F","()",""],["ns_schedule","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-ns_schedule","(delay)","<p>Schedule the task using the given delay and the current time.\n<p>@param [Float] delay the number of seconds \n"],["ns_select","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-ns_select","()","<p>@!macro struct_select\n<p>@!visibility private\n"],["ns_set","Concurrent::Event","Concurrent/Event.html#method-i-ns_set","()",""],["ns_set","Concurrent::MutexAtomicFixnum","Concurrent/MutexAtomicFixnum.html#method-i-ns_set","(value)","<p>@!visibility private\n"],["ns_set_deref_options","Concurrent::Concern::Dereferenceable","Concurrent/Concern/Dereferenceable.html#method-i-ns_set_deref_options","(opts)","<p>@!macro dereferenceable_set_deref_options @!visibility private\n"],["ns_set_state","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-ns_set_state","(value)","<p>@!visibility private\n"],["ns_shutdown?","Concurrent::JavaExecutorService","Concurrent/JavaExecutorService.html#method-i-ns_shutdown-3F","()",""],["ns_shutdown?","Concurrent::RubyExecutorService","Concurrent/RubyExecutorService.html#method-i-ns_shutdown-3F","()",""],["ns_shutdown_execution","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-ns_shutdown_execution","()","<p>@!macro executor_service_method_ns_shutdown_execution\n\n<pre>Callback method called when an orderly shutdown ...</pre>\n"],["ns_shutdown_execution","Concurrent::RubyExecutorService","Concurrent/RubyExecutorService.html#method-i-ns_shutdown_execution","()",""],["ns_shutdown_execution","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_shutdown_execution","()","<p>@!visibility private\n"],["ns_shutdown_execution","Concurrent::TimerSet","Concurrent/TimerSet.html#method-i-ns_shutdown_execution","()","<p>`ExecutorService` callback called during shutdown.\n<p>@!visibility private\n"],["ns_shutdown_execution","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-ns_shutdown_execution","()","<p>@!visibility private\n"],["ns_shuttingdown?","Concurrent::JavaExecutorService","Concurrent/JavaExecutorService.html#method-i-ns_shuttingdown-3F","()",""],["ns_shuttingdown?","Concurrent::RubyExecutorService","Concurrent/RubyExecutorService.html#method-i-ns_shuttingdown-3F","()",""],["ns_signal","Concurrent::Synchronization::AbstractLockableObject","Concurrent/Synchronization/AbstractLockableObject.html#method-i-ns_signal","()","<p>@!macro synchronization_object_method_ns_signal\n\n<pre>Signal one waiting thread.\n@return [self]\n@note only to ...</pre>\n"],["ns_signal","Concurrent::Synchronization::Condition","Concurrent/Synchronization/Condition.html#method-i-ns_signal","()",""],["ns_signal","Concurrent::Synchronization::ConditionSignalling","Concurrent/Synchronization/ConditionSignalling.html#method-i-ns_signal","()",""],["ns_signal","Concurrent::Synchronization::RbxLockableObject","Concurrent/Synchronization/RbxLockableObject.html#method-i-ns_signal","()",""],["ns_to_h","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-ns_to_h","()","<p>@!macro struct_to_h\n<p>@!visibility private\n"],["ns_validate","Concurrent::Agent","Concurrent/Agent.html#method-i-ns_validate","(value)",""],["ns_values","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-ns_values","()","<p>@!macro struct_values\n<p>@!visibility private\n"],["ns_values_at","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-ns_values_at","(indexes)","<p>@!macro struct_values_at\n<p>@!visibility private\n"],["ns_wait","Concurrent::Synchronization::AbstractLockableObject","Concurrent/Synchronization/AbstractLockableObject.html#method-i-ns_wait","(timeout = nil)","<p>@!macro synchronization_object_method_ns_wait\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Wait</span> <span class=\"ruby-keyword\">until</span> <span class=\"ruby-identifier\">another</span> <span class=\"ruby-identifier\">thread</span> <span class=\"ruby-identifier\">calls</span> <span class=\"ruby-comment\">#signal or #broadcast,</span>\n<span class=\"ruby-identifier\">spurious</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["ns_wait","Concurrent::Synchronization::Condition","Concurrent/Synchronization/Condition.html#method-i-ns_wait","(timeout = nil)",""],["ns_wait","Concurrent::Synchronization::MonitorLockableObject","Concurrent/Synchronization/MonitorLockableObject.html#method-i-ns_wait","(timeout = nil)",""],["ns_wait","Concurrent::Synchronization::MutexLockableObject","Concurrent/Synchronization/MutexLockableObject.html#method-i-ns_wait","(timeout = nil)",""],["ns_wait","Concurrent::Synchronization::RbxLockableObject","Concurrent/Synchronization/RbxLockableObject.html#method-i-ns_wait","(timeout = nil)",""],["ns_wait_until","Concurrent::Synchronization::AbstractLockableObject","Concurrent/Synchronization/AbstractLockableObject.html#method-i-ns_wait_until","(timeout = nil, &condition)","<p>@!macro synchronization_object_method_ns_wait_until\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Wait</span> <span class=\"ruby-keyword\">until</span> <span class=\"ruby-identifier\">condition</span> <span class=\"ruby-identifier\">is</span> <span class=\"ruby-identifier\">met</span> <span class=\"ruby-keyword\">or</span> <span class=\"ruby-identifier\">timeout</span> <span class=\"ruby-identifier\">passes</span>,\n<span class=\"ruby-identifier\">protects</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["ns_wait_until","Concurrent::Synchronization::Condition","Concurrent/Synchronization/Condition.html#method-i-ns_wait_until","(timeout = nil, &condition)",""],["ns_worker_died","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_worker_died","(worker)","<p>@!visibility private\n"],["ns_worker_not_old_enough","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_worker_not_old_enough","(worker)","<p>returns back worker to @ready which was not idle for enough time\n<p>@!visibility private\n"],["number_waiting","Concurrent::CyclicBarrier","Concurrent/CyclicBarrier.html#method-i-number_waiting","()","<p>@return [Fixnum] the number of threads currently waiting on the barrier\n"],["observers","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-i-observers","()",""],["observers=","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-i-observers-3D","(new_set)",""],["of1","Concurrent::LockFreeStack","Concurrent/LockFreeStack.html#method-c-of1","(value)","<p>@!visibility private\n"],["of2","Concurrent::LockFreeStack","Concurrent/LockFreeStack.html#method-c-of2","(value1, value2)","<p>@!visibility private\n"],["on_blocker_resolution","Concurrent::Promises::BlockedPromise","Concurrent/Promises/BlockedPromise.html#method-i-on_blocker_resolution","(future, index)",""],["on_cruby?","Concurrent::Utility::EngineDetector","Concurrent/Utility/EngineDetector.html#method-i-on_cruby-3F","()",""],["on_error","Concurrent::Promise","Concurrent/Promise.html#method-i-on_error","(&block)",""],["on_fulfill","Concurrent::Promise","Concurrent/Promise.html#method-i-on_fulfill","(result)","<p>@!visibility private\n"],["on_fulfillment","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-on_fulfillment","(*args, &callback)","<p>@!macro promises.shortcut.using @return [self]\n"],["on_fulfillment!","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-on_fulfillment-21","(*args, &callback)","<p>Stores the callback to be executed synchronously on resolving thread after it is fulfilled. Does nothing \n"],["on_fulfillment_using","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-on_fulfillment_using","(executor, *args, &callback)","<p>Stores the callback to be executed asynchronously on executor after it is fulfilled. Does nothing on \n"],["on_jruby?","Concurrent::Utility::EngineDetector","Concurrent/Utility/EngineDetector.html#method-i-on_jruby-3F","()",""],["on_jruby_9000?","Concurrent::Utility::EngineDetector","Concurrent/Utility/EngineDetector.html#method-i-on_jruby_9000-3F","()",""],["on_linux?","Concurrent::Utility::EngineDetector","Concurrent/Utility/EngineDetector.html#method-i-on_linux-3F","()",""],["on_osx?","Concurrent::Utility::EngineDetector","Concurrent/Utility/EngineDetector.html#method-i-on_osx-3F","()",""],["on_rbx?","Concurrent::Utility::EngineDetector","Concurrent/Utility/EngineDetector.html#method-i-on_rbx-3F","()",""],["on_reject","Concurrent::Promise","Concurrent/Promise.html#method-i-on_reject","(reason)","<p>@!visibility private\n"],["on_rejection","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-on_rejection","(*args, &callback)","<p>@!macro promises.shortcut.using @return [self]\n"],["on_rejection!","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-on_rejection-21","(*args, &callback)","<p>Stores the callback to be executed synchronously on resolving thread after it is rejected. Does nothing \n"],["on_rejection_using","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-on_rejection_using","(executor, *args, &callback)","<p>Stores the callback to be executed asynchronously on executor after it is rejected. Does nothing on fulfillment. \n"],["on_resolution","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-on_resolution","(*args, &callback)","<p>@!macro promises.shortcut.using @return [self]\n"],["on_resolution!","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-on_resolution-21","(*args, &callback)","<p>Stores the callback to be executed synchronously on resolving thread after it is resolved.\n<p>@!macro promises.param.args \n"],["on_resolution_using","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-on_resolution_using","(executor, *args, &callback)","<p>Stores the callback to be executed asynchronously on executor after it is resolved.\n<p>@!macro promises.param.executor \n"],["on_resolvable","Concurrent::Promises::AbstractFlatPromise","Concurrent/Promises/AbstractFlatPromise.html#method-i-on_resolvable","(resolved_future, index)",""],["on_resolvable","Concurrent::Promises::AnyResolvedEventPromise","Concurrent/Promises/AnyResolvedEventPromise.html#method-i-on_resolvable","(resolved_future, index)",""],["on_resolvable","Concurrent::Promises::AnyResolvedFuturePromise","Concurrent/Promises/AnyResolvedFuturePromise.html#method-i-on_resolvable","(resolved_future, index)",""],["on_resolvable","Concurrent::Promises::BlockedPromise","Concurrent/Promises/BlockedPromise.html#method-i-on_resolvable","(resolved_future, index)",""],["on_resolvable","Concurrent::Promises::ChainPromise","Concurrent/Promises/ChainPromise.html#method-i-on_resolvable","(resolved_future, index)",""],["on_resolvable","Concurrent::Promises::EventWrapperPromise","Concurrent/Promises/EventWrapperPromise.html#method-i-on_resolvable","(resolved_future, index)",""],["on_resolvable","Concurrent::Promises::FutureWrapperPromise","Concurrent/Promises/FutureWrapperPromise.html#method-i-on_resolvable","(resolved_future, index)",""],["on_resolvable","Concurrent::Promises::RescuePromise","Concurrent/Promises/RescuePromise.html#method-i-on_resolvable","(resolved_future, index)",""],["on_resolvable","Concurrent::Promises::ThenPromise","Concurrent/Promises/ThenPromise.html#method-i-on_resolvable","(resolved_future, index)",""],["on_resolvable","Concurrent::Promises::ZipEventEventPromise","Concurrent/Promises/ZipEventEventPromise.html#method-i-on_resolvable","(resolved_future, index)",""],["on_resolvable","Concurrent::Promises::ZipEventsPromise","Concurrent/Promises/ZipEventsPromise.html#method-i-on_resolvable","(resolved_future, index)",""],["on_resolvable","Concurrent::Promises::ZipFutureEventPromise","Concurrent/Promises/ZipFutureEventPromise.html#method-i-on_resolvable","(resolved_future, index)",""],["on_resolvable","Concurrent::Promises::ZipFuturesPromise","Concurrent/Promises/ZipFuturesPromise.html#method-i-on_resolvable","(resolved_future, index)",""],["on_success","Concurrent::Promise","Concurrent/Promise.html#method-i-on_success","(&block)","<p>Chain onto this promise an action to be undertaken on success (fulfillment).\n<p>@yield The block to execute \n"],["on_truffleruby?","Concurrent::Utility::EngineDetector","Concurrent/Utility/EngineDetector.html#method-i-on_truffleruby-3F","()",""],["on_windows?","Concurrent::Utility::EngineDetector","Concurrent/Utility/EngineDetector.html#method-i-on_windows-3F","()",""],["or","Concurrent::Maybe","Concurrent/Maybe.html#method-i-or","(other)","<p>Return either the value of self or the given default value.\n<p>@return [Object] The value of self when `Just`; \n"],["ordered?","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-ordered-3F","(x, y)","<p>Are the items at the given indexes ordered based on the priority order specified at construction?\n<p>@param \n"],["padding","Concurrent::ThreadSafe::Util::Striped64::Cell","Concurrent/ThreadSafe/Util/Striped64/Cell.html#method-c-padding","()","<p>@!visibility private\n"],["pair?","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-pair-3F","(key, expected_value)",""],["parties","Concurrent::CyclicBarrier","Concurrent/CyclicBarrier.html#method-i-parties","()","<p>@return [Fixnum] the number of threads needed to pass the barrier\n"],["peek","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-peek","()","<p>@!macro priority_queue_method_peek\n"],["peek","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-peek","()","<p>@!macro priority_queue_method_peek\n"],["peek","Concurrent::LockFreeStack","Concurrent/LockFreeStack.html#method-i-peek","()","<p>@return [Node]\n"],["pending?","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-pending-3F","()","<p>Is obligation completion still pending?\n<p>@return [Boolean]\n"],["pending?","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-pending-3F","()","<p>Is it in pending state? @return [Boolean]\n"],["perform","Concurrent::Async::AsyncDelegator","Concurrent/Async/AsyncDelegator.html#method-i-perform","()","<p>Perform all enqueued tasks.\n<p>This method must be called from within the executor. It must not be called \n"],["physical_processor_count","Concurrent","Concurrent.html#method-c-physical_processor_count","()",""],["physical_processor_count","Concurrent::Utility::ProcessorCounter","Concurrent/Utility/ProcessorCounter.html#method-i-physical_processor_count","()","<p>Number of physical processor cores on the current system. For performance reasons the calculated value \n"],["pop","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-pop","()","<p>@!macro priority_queue_method_pop\n"],["pop","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-pop","()","<p>@!macro priority_queue_method_pop\n"],["pop","Concurrent::LockFreeStack","Concurrent/LockFreeStack.html#method-i-pop","()","<p>@return [Object]\n"],["populate_from","Concurrent::Map","Concurrent/Map.html#method-i-populate_from","(hash)",""],["post","Concurrent::Agent","Concurrent/Agent.html#method-i-post","(*args, &action)",""],["post","Concurrent::ExecutorService","Concurrent/ExecutorService.html#method-i-post","(*args, &task)","<p>@!macro executor_service_method_post\n"],["post","Concurrent::ImmediateExecutor","Concurrent/ImmediateExecutor.html#method-i-post","(*args, &task)","<p>@!macro executor_service_method_post\n"],["post","Concurrent::IndirectImmediateExecutor","Concurrent/IndirectImmediateExecutor.html#method-i-post","(*args, &task)","<p>@!macro executor_service_method_post\n"],["post","Concurrent::JavaExecutorService","Concurrent/JavaExecutorService.html#method-i-post","(*args, &task)",""],["post","Concurrent::RubyExecutorService","Concurrent/RubyExecutorService.html#method-i-post","(*args, &task)",""],["post","Concurrent::SerializedExecution","Concurrent/SerializedExecution.html#method-i-post","(executor, *args, &task)","<p>Submit a task to the executor for asynchronous processing.\n<p>@param [Executor] executor to be used for this \n"],["post","Concurrent::SerializedExecutionDelegator","Concurrent/SerializedExecutionDelegator.html#method-i-post","(*args, &task)","<p>@!macro executor_service_method_post\n"],["post","Concurrent::SimpleExecutorService","Concurrent/SimpleExecutorService.html#method-i-post","(*args, &task)","<p>@!macro executor_service_method_post\n"],["post","Concurrent::SimpleExecutorService","Concurrent/SimpleExecutorService.html#method-c-post","(*args)","<p>@!macro executor_service_method_post\n"],["post","Concurrent::TimerSet","Concurrent/TimerSet.html#method-i-post","(delay, *args, &task)","<p>Post a task to be execute run after a given delay (in seconds). If the delay is less than 1/100th of \n"],["post_task","Concurrent::TimerSet","Concurrent/TimerSet.html#method-i-post_task","(task)","<p>Post the task to the internal queue.\n<p>@note This is intended as a callback method from ScheduledTask\n\n<pre>only. ...</pre>\n"],["posts","Concurrent::SerializedExecution","Concurrent/SerializedExecution.html#method-i-posts","(posts)","<p>As {#post} but allows to submit multiple tasks at once, it&#39;s guaranteed that they will not be interleaved \n"],["pr_underscore","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-pr_underscore","(clazz)","<p>@!visibility private\n"],["process_on_blocker_resolution","Concurrent::Promises::BlockedPromise","Concurrent/Promises/BlockedPromise.html#method-i-process_on_blocker_resolution","(future, index)",""],["process_on_blocker_resolution","Concurrent::Promises::FlatEventPromise","Concurrent/Promises/FlatEventPromise.html#method-i-process_on_blocker_resolution","(future, index)",""],["process_on_blocker_resolution","Concurrent::Promises::FlatFuturePromise","Concurrent/Promises/FlatFuturePromise.html#method-i-process_on_blocker_resolution","(future, index)",""],["process_on_blocker_resolution","Concurrent::Promises::RunFuturePromise","Concurrent/Promises/RunFuturePromise.html#method-i-process_on_blocker_resolution","(future, index)",""],["process_on_blocker_resolution","Concurrent::Promises::ZipFutureEventPromise","Concurrent/Promises/ZipFutureEventPromise.html#method-i-process_on_blocker_resolution","(future, index)",""],["process_on_blocker_resolution","Concurrent::Promises::ZipFuturesPromise","Concurrent/Promises/ZipFuturesPromise.html#method-i-process_on_blocker_resolution","(future, index)",""],["process_task","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-process_task","()","<p>Execute the task.\n<p>@!visibility private\n"],["process_tasks","Concurrent::TimerSet","Concurrent/TimerSet.html#method-i-process_tasks","()","<p>Run a loop and execute tasks in the scheduled order and at the approximate scheduled time. If no tasks \n"],["processing?","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-processing-3F","()","<p>In the task execution in progress?\n<p>@return [Boolean] true if the task is in the given state else false \n"],["processor_count","Concurrent","Concurrent.html#method-c-processor_count","()",""],["processor_count","Concurrent::Utility::ProcessorCounter","Concurrent/Utility/ProcessorCounter.html#method-i-processor_count","()","<p>Number of processors seen by the OS and used for process scheduling. For performance reasons the calculated \n"],["promise","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-promise","()","<p>For inspection. @!visibility private\n"],["pure_hash","Concurrent::Collection::AtomicReferenceMapBackend::Node","Concurrent/Collection/AtomicReferenceMapBackend/Node.html#method-i-pure_hash","()",""],["push","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-push","(item)","<p>@!macro priority_queue_method_push\n"],["push","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-push","(item)","<p>@!macro priority_queue_method_push\n"],["push","Concurrent::LockFreeStack","Concurrent/LockFreeStack.html#method-i-push","(value)","<p>@param [Object] value @return [self]\n"],["put","Concurrent::MVar","Concurrent/MVar.html#method-i-put","(value, timeout = nil)","<p>Put a value into an `MVar`, blocking if there is already a value until it is empty. A timeout can be \n"],["put_if_absent","Concurrent::Map","Concurrent/Map.html#method-i-put_if_absent","(key, value)","<p>Insert value into map with key if key is absent in one atomic step. @param [Object] key @param [Object] \n"],["queue_length","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-i-queue_length","()","<p>@!macro thread_pool_executor_attr_reader_queue_length\n"],["queue_length","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-queue_length","()","<p>@!macro thread_pool_executor_attr_reader_queue_length\n"],["raise_fetch_no_key","Concurrent::Map","Concurrent/Map.html#method-i-raise_fetch_no_key","()",""],["read","Concurrent::Transaction","Concurrent/Transaction.html#method-i-read","(tvar)",""],["ready_worker","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ready_worker","(worker)","<p>@!visibility private\n"],["realize","Concurrent::Promise","Concurrent/Promise.html#method-i-realize","(task)","<p>@!visibility private\n"],["realized?","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-realized-3F","()",""],["reason","Concurrent::Agent","Concurrent/Agent.html#method-i-reason","()",""],["reason","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-reason","()","<p>If an exception was raised during processing this will return the exception object. Will return `nil` \n"],["reason","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-reason","(timeout = nil, timeout_value = nil)","<p>Returns reason of future&#39;s rejection. @!macro promises.touches\n<p>@!macro promises.warn.blocks @!macro \n"],["reason","Concurrent::Promises::InternalStates::Fulfilled","Concurrent/Promises/InternalStates/Fulfilled.html#method-i-reason","()",""],["reason","Concurrent::Promises::InternalStates::PartiallyRejected","Concurrent/Promises/InternalStates/PartiallyRejected.html#method-i-reason","()",""],["reason","Concurrent::Promises::InternalStates::Rejected","Concurrent/Promises/InternalStates/Rejected.html#method-i-reason","()",""],["reason","Concurrent::Promises::InternalStates::ResolvedWithResult","Concurrent/Promises/InternalStates/ResolvedWithResult.html#method-i-reason","()",""],["reason","Concurrent::Promises::ResolvableFuture","Concurrent/Promises/ResolvableFuture.html#method-i-reason","(timeout = nil, timeout_value = nil, resolve_on_timeout = nil)","<p>Behaves as {Future#reason} but has one additional optional argument resolve_on_timeout.\n<p>@!macro promises.resolvable.resolve_on_timeout \n"],["rebuild","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-rebuild","(table)","<p>Moves and/or copies the nodes in each bin to new table. See above for explanation.\n"],["reconfigure","Concurrent::Delay","Concurrent/Delay.html#method-i-reconfigure","(&block)","<p>Reconfigures the block returning the value if still `#incomplete?`\n<p>@yield the delayed operation to perform \n"],["reduce_permits","Concurrent::MutexSemaphore","Concurrent/MutexSemaphore.html#method-i-reduce_permits","(reduction)","<p>Shrinks the number of available permits by the indicated reduction.\n<p>@param [Fixnum] reduction Number of \n"],["reject","Concurrent::Promise","Concurrent/Promise.html#method-c-reject","(reason, opts = {})","<p>Create a new `Promise` and reject it immediately.\n<p>@!macro executor_and_deref_options\n<p>@!macro promise_init_options \n"],["reject","Concurrent::Promises::ResolvableFuture","Concurrent/Promises/ResolvableFuture.html#method-i-reject","(reason, raise_on_reassign = true, reserved = false)","<p>Makes the future rejected with `reason`, which triggers all dependent futures.\n<p>@param [Object] reason \n"],["rejected?","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-rejected-3F","()","<p>Has the obligation been rejected?\n<p>@return [Boolean]\n"],["rejected?","Concurrent::Maybe","Concurrent/Maybe.html#method-i-rejected-3F","()",""],["rejected?","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-rejected-3F","()","<p>Is it in rejected state? @return [Boolean]\n"],["rejected_future","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-rejected_future","(reason, default_executor = self.default_executor)","<p>Creates resolved future with will be rejected with the given reason.\n<p>@!macro promises.param.default_executor \n"],["rejected_resolution","Concurrent::Promises::Event","Concurrent/Promises/Event.html#method-i-rejected_resolution","(raise_on_reassign, state)",""],["rejected_resolution","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-rejected_resolution","(raise_on_reassign, state)",""],["release","Concurrent::MutexSemaphore","Concurrent/MutexSemaphore.html#method-i-release","(permits = 1)","<p>@!macro semaphore_method_release\n"],["release_read_lock","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-release_read_lock","()","<p>Release a previously acquired read lock.\n<p>@return [Boolean] true if the lock is successfully released\n"],["release_read_lock","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-release_read_lock","()","<p>Release a previously acquired read lock.\n<p>@return [Boolean] true if the lock is successfully released\n"],["release_write_lock","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-release_write_lock","()","<p>Release a previously acquired write lock.\n<p>@return [Boolean] true if the lock is successfully released \n"],["release_write_lock","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-release_write_lock","()","<p>Release a previously acquired write lock.\n<p>@return [Boolean] true if the lock is successfully released \n"],["remaining_capacity","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-i-remaining_capacity","()","<p>@!macro thread_pool_executor_attr_reader_remaining_capacity\n"],["remaining_capacity","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-remaining_capacity","()","<p>@!macro thread_pool_executor_attr_reader_remaining_capacity\n"],["remove_busy_worker","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-remove_busy_worker","(worker)","<p>@!visibility private\n"],["remove_task","Concurrent::TimerSet","Concurrent/TimerSet.html#method-i-remove_task","(task)","<p>Remove the given task from the queue.\n<p>@note This is intended as a callback method from `ScheduledTask` \n"],["replace_if","Concurrent::LockFreeStack","Concurrent/LockFreeStack.html#method-i-replace_if","(head, new_head)","<p>@param [Node] head @param [Node] new_head @return [true, false]\n"],["replace_if_exists","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-replace_if_exists","(key, new_value)",""],["replace_if_exists","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-i-replace_if_exists","(key, new_value)",""],["replace_if_exists","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-replace_if_exists","(key, new_value)",""],["replace_if_exists","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-replace_if_exists","(key, new_value)",""],["replace_pair","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-replace_pair","(key, old_value, new_value)",""],["replace_pair","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-i-replace_pair","(key, old_value, new_value)",""],["replace_pair","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-replace_pair","(key, old_value, new_value)",""],["replace_pair","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-replace_pair","(key, old_value, new_value)",""],["reschedule","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-reschedule","(delay)","<p>Reschedule the task using the given delay and the current time. A task can only be reset while it is \n"],["rescue","Concurrent::Promise","Concurrent/Promise.html#method-i-rescue","(&block)","<p>Chain onto this promise an action to be undertaken on failure (rejection).\n<p>@yield The block to execute \n"],["rescue","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-rescue","(*args, &task)","<p>@!macro promises.shortcut.on @return [Future]\n"],["rescue_on","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-rescue_on","(executor, *args, &task)","<p>Chains the task to be executed asynchronously on executor after it rejects. Does not run the task if \n"],["reset","Concurrent::Atom","Concurrent/Atom.html#method-i-reset","(new_value)","<p>Atomically sets the value of atom to the new value without regard for the current value so long as the \n"],["reset","Concurrent::CyclicBarrier","Concurrent/CyclicBarrier.html#method-i-reset","()","<p>resets the barrier to its initial state If there is at least one waiting thread, it will be woken up, \n"],["reset","Concurrent::Event","Concurrent/Event.html#method-i-reset","()","<p>Reset a previously set event back to the `unset` state. Has no effect if the `Event` has not yet been \n"],["reset","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-reset","()","<p>Reschedule the task using the original delay and the current time. A task can only be reset while it \n"],["reset","Concurrent::ThreadSafe::Util::Adder","Concurrent/ThreadSafe/Util/Adder.html#method-i-reset","()",""],["resolvable?","Concurrent::Promises::AbstractFlatPromise","Concurrent/Promises/AbstractFlatPromise.html#method-i-resolvable-3F","(countdown, future, index)",""],["resolvable?","Concurrent::Promises::AnyFulfilledFuturePromise","Concurrent/Promises/AnyFulfilledFuturePromise.html#method-i-resolvable-3F","(countdown, future, index)",""],["resolvable?","Concurrent::Promises::AnyResolvedEventPromise","Concurrent/Promises/AnyResolvedEventPromise.html#method-i-resolvable-3F","(countdown, future, index)",""],["resolvable?","Concurrent::Promises::AnyResolvedFuturePromise","Concurrent/Promises/AnyResolvedFuturePromise.html#method-i-resolvable-3F","(countdown, future, index)",""],["resolvable?","Concurrent::Promises::BlockedPromise","Concurrent/Promises/BlockedPromise.html#method-i-resolvable-3F","(countdown, future, index)","<p>@return [true,false] if resolvable\n"],["resolvable_event","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-resolvable_event","()","<p>@!macro promises.shortcut.on @return [ResolvableEvent]\n"],["resolvable_event_on","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-resolvable_event_on","(default_executor = self.default_executor)","<p>Created resolvable event, user is responsible for resolving the event once by {Promises::ResolvableEvent#resolve}. \n"],["resolvable_future","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-resolvable_future","()","<p>@!macro promises.shortcut.on @return [ResolvableFuture]\n"],["resolvable_future_on","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-resolvable_future_on","(default_executor = self.default_executor)","<p>Creates resolvable future, user is responsible for resolving the future once by {Promises::ResolvableFuture#resolve}, \n"],["resolve","Concurrent::Promises::ResolvableEvent","Concurrent/Promises/ResolvableEvent.html#method-i-resolve","(raise_on_reassign = true, reserved = false)","<p>Makes the event resolved, which triggers all dependent futures.\n<p>@!macro promise.param.raise_on_reassign \n"],["resolve","Concurrent::Promises::ResolvableFuture","Concurrent/Promises/ResolvableFuture.html#method-i-resolve","(fulfilled = true, value = nil, reason = nil, raise_on_reassign = true, reserved = false)","<p>Makes the future resolved with result of triplet `fulfilled?`, `value`, `reason`, which triggers all \n"],["resolve_with","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-resolve_with","(state, raise_on_reassign = true, reserved = false)","<p>@!visibility private\n"],["resolve_with","Concurrent::Promises::AbstractPromise","Concurrent/Promises/AbstractPromise.html#method-i-resolve_with","(new_state, raise_on_reassign = true)",""],["resolved?","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-resolved-3F","()","<p>Is it in resolved state? @return [Boolean]\n"],["resolved?","Concurrent::Promises::InternalStates::Pending","Concurrent/Promises/InternalStates/Pending.html#method-i-resolved-3F","()",""],["resolved?","Concurrent::Promises::InternalStates::ResolvedWithResult","Concurrent/Promises/InternalStates/ResolvedWithResult.html#method-i-resolved-3F","()",""],["resolved?","Concurrent::Promises::InternalStates::State","Concurrent/Promises/InternalStates/State.html#method-i-resolved-3F","()",""],["resolved_event","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-resolved_event","(default_executor = self.default_executor)","<p>Creates resolved event.\n<p>@!macro promises.param.default_executor @return [Event]\n"],["resolved_future","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-resolved_future","(fulfilled, value, reason, default_executor = self.default_executor)","<p>Creates resolved future with will be either fulfilled with the given value or rejection with the given \n"],["respond_to_missing?","Concurrent::Async::AsyncDelegator","Concurrent/Async/AsyncDelegator.html#method-i-respond_to_missing-3F","(method, include_private = false)","<p>Check whether the method is responsive\n<p>@param [Symbol] method the method being called\n"],["respond_to_missing?","Concurrent::Async::AwaitDelegator","Concurrent/Async/AwaitDelegator.html#method-i-respond_to_missing-3F","(method, include_private = false)","<p>Check whether the method is responsive\n<p>@param [Symbol] method the method being called\n"],["restart","Concurrent::Agent","Concurrent/Agent.html#method-i-restart","(new_value, opts = {})","<p>When an Agent is {#failed?}, changes the Agent {#value} to `new_value` then un-fails the Agent so that \n"],["result","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-result","(timeout = nil)","<p>Returns triplet fulfilled?, value, reason. @!macro promises.touches\n<p>@!macro promises.warn.blocks @!macro \n"],["result","Concurrent::Promises::InternalStates::ResolvedWithResult","Concurrent/Promises/InternalStates/ResolvedWithResult.html#method-i-result","()",""],["result","Concurrent::Promises::ResolvableFuture","Concurrent/Promises/ResolvableFuture.html#method-i-result","(timeout = nil, resolve_on_timeout = nil)","<p>Behaves as {Future#result} but has one additional optional argument resolve_on_timeout.\n<p>@!macro promises.resolvable.resolve_on_timeout \n"],["retry_update","Concurrent::ThreadSafe::Util::Striped64","Concurrent/ThreadSafe/Util/Striped64.html#method-i-retry_update","(x, hash_code, was_uncontended)","<p>Handles cases of updates involving initialization, resizing, creating new Cells, and/or contention.  \n"],["ruby_engine","Concurrent::Utility::EngineDetector","Concurrent/Utility/EngineDetector.html#method-i-ruby_engine","()",""],["ruby_version","Concurrent::Utility::EngineDetector","Concurrent/Utility/EngineDetector.html#method-i-ruby_version","(version = RUBY_VERSION, comparison, major, minor, patch)",""],["run","Concurrent::AtExitImplementation","Concurrent/AtExitImplementation.html#method-i-run","()","<p>run the handlers manually @return ids of the handlers\n"],["run","Concurrent::JavaExecutorService::Job","Concurrent/JavaExecutorService/Job.html#method-i-run","()",""],["run","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-run","(run_test = method(:run_test))","<p>Allows to use futures as green threads. The receiver has to evaluate to a future which represents what \n"],["run_task","Concurrent::RubyThreadPoolExecutor::Worker","Concurrent/RubyThreadPoolExecutor/Worker.html#method-i-run_task","(pool, task, args)",""],["run_test","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-run_test","(v)",""],["runner","Concurrent::AtExitImplementation","Concurrent/AtExitImplementation.html#method-i-runner","()",""],["running?","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-running-3F","()","<p>@!macro executor_service_method_running_question\n"],["running?","Concurrent::ImmediateExecutor","Concurrent/ImmediateExecutor.html#method-i-running-3F","()","<p>@!macro executor_service_method_running_question\n"],["running?","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-i-running-3F","()","<p>@!macro executor_service_method_running_question\n"],["running?","Concurrent::SimpleExecutorService","Concurrent/SimpleExecutorService.html#method-i-running-3F","()","<p>@!macro executor_service_method_running_question\n"],["running?","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-running-3F","()","<p>Is the executor running?\n<p>@return [Boolean] `true` when running, `false` when shutting down or shutdown \n"],["running_readers","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-running_readers","(c = @Counter.value)","<p>@!visibility private\n"],["running_readers","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-running_readers","(c = @Counter.value)","<p>@!visibility private\n"],["running_readers?","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-running_readers-3F","(c = @Counter.value)","<p>@!visibility private\n"],["running_readers?","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-running_readers-3F","(c = @Counter.value)","<p>@!visibility private\n"],["running_writer?","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-running_writer-3F","(c = @Counter.value)","<p>@!visibility private\n"],["running_writer?","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-running_writer-3F","(c = @Counter.value)","<p>@!visibility private\n"],["safe_execute","Concurrent::IVar","Concurrent/IVar.html#method-i-safe_execute","(task, args = [])","<p>@!visibility private\n"],["safe_initialization!","Concurrent::Synchronization::Object","Concurrent/Synchronization/Object.html#method-c-safe_initialization-21","()","<p>By calling this method on a class, it and all its children are marked to be constructed safely. Meaning \n"],["safe_initialization?","Concurrent::Synchronization::Object","Concurrent/Synchronization/Object.html#method-c-safe_initialization-3F","()","<p>@return [true, false] if this class is safely initialized.\n"],["schedule","Concurrent::Promises::Event","Concurrent/Promises/Event.html#method-i-schedule","(intended_time)","<p>@!macro promise.method.schedule\n\n<pre>Creates new event dependent on receiver scheduled to execute on/in intended_time. ...</pre>\n"],["schedule","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-schedule","(intended_time, *args, &task)","<p>@!macro promises.shortcut.on @return [Future, Event]\n"],["schedule","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-schedule","(intended_time)","<p>@!macro promise.method.schedule @return [Future]\n"],["schedule_next_task","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-schedule_next_task","(interval = execution_interval)","<p>@!visibility private\n"],["schedule_on","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-schedule_on","(default_executor, intended_time, *args, &task)","<p>Creates new event or future which is resolved in intended_time.\n<p>@!macro promises.param.default_executor \n"],["schedule_time","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-schedule_time","()","<p>The monotonic time at which the the task is scheduled to be executed.\n<p>@return [Float] the schedule time \n"],["scheduled_task_count","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-i-scheduled_task_count","()","<p>@!macro thread_pool_executor_attr_reader_scheduled_task_count\n"],["scheduled_task_count","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-scheduled_task_count","()","<p>@!macro thread_pool_executor_attr_reader_scheduled_task_count\n"],["select","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-select","(&block)","<p>@!macro struct_select\n"],["select","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-select","(&block)","<p>@!macro struct_select\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Yields</span> <span class=\"ruby-identifier\">each</span> <span class=\"ruby-identifier\">member</span> <span class=\"ruby-identifier\">value</span> <span class=\"ruby-identifier\">from</span> <span class=\"ruby-identifier\">the</span> <span class=\"ruby-identifier\">struct</span> <span class=\"ruby-identifier\">to</span> <span class=\"ruby-identifier\">the</span> <span class=\"ruby-identifier\">block</span> <span class=\"ruby-keyword\">and</span> <span class=\"ruby-identifier\">returns</span> <span class=\"ruby-identifier\">an</span> <span class=\"ruby-constant\">Array</span>\n<span class=\"ruby-identifier\">containing</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["select","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-select","(&block)","<p>@!macro struct_select\n"],["send","Concurrent::Agent","Concurrent/Agent.html#method-i-send","(*args, &action)","<p>@!macro agent_send\n\n<pre>Dispatches an action to the Agent and returns immediately. Subsequently,\nin a thread ...</pre>\n"],["send!","Concurrent::Agent","Concurrent/Agent.html#method-i-send-21","(*args, &action)","<p>@!macro agent_send\n<p>@!macro send_bang_return_and_raise\n\n<pre>@return [Boolean] true if the action is successfully ...</pre>\n"],["send_off","Concurrent::Agent","Concurrent/Agent.html#method-i-send_off","(*args, &action)","<p>@!macro agent_send @!macro send_return\n"],["send_off!","Concurrent::Agent","Concurrent/Agent.html#method-i-send_off-21","(*args, &action)","<p>@!macro agent_send @!macro send_bang_return_and_raise\n"],["send_via","Concurrent::Agent","Concurrent/Agent.html#method-i-send_via","(executor, *args, &action)","<p>@!macro agent_send @!macro send_return @param [Concurrent::ExecutorService] executor the executor on \n"],["send_via!","Concurrent::Agent","Concurrent/Agent.html#method-i-send_via-21","(executor, *args, &action)","<p>@!macro agent_send @!macro send_bang_return_and_raise @param [Concurrent::ExecutorService] executor the \n"],["serialized?","Concurrent::ExecutorService","Concurrent/ExecutorService.html#method-i-serialized-3F","()","<p>@!macro executor_service_method_serialized_question\n<p>@note Always returns `false`\n"],["serialized?","Concurrent::SerialExecutorService","Concurrent/SerialExecutorService.html#method-i-serialized-3F","()","<p>@!macro executor_service_method_serialized_question\n<p>@note Always returns `true`\n"],["set","Concurrent::AtomicMarkableReference","Concurrent/AtomicMarkableReference.html#method-i-set","(new_val, new_mark)","<p><em>Unconditionally</em> sets to the given value of both the reference and the mark.\n<p>@param [Object] new_val the \n"],["set","Concurrent::Event","Concurrent/Event.html#method-i-set","()","<p>Trigger the event, setting the state to `set` and releasing all threads waiting on the event. Has no \n"],["set","Concurrent::Future","Concurrent/Future.html#method-i-set","(value = NULL, &block)","<p>@!macro ivar_set_method\n"],["set","Concurrent::IVar","Concurrent/IVar.html#method-i-set","(value = NULL)","<p>@!macro ivar_set_method\n\n<pre>Set the `IVar` to a value and wake or notify all threads waiting on it.\n\n@!macro ...</pre>\n"],["set","Concurrent::MutexAtomicReference","Concurrent/MutexAtomicReference.html#method-i-set","(new_value)","<p>@!macro atomic_reference_method_set\n"],["set","Concurrent::Promise","Concurrent/Promise.html#method-i-set","(value = NULL, &block)","<p>@!macro ivar_set_method\n<p>@raise [Concurrent::PromiseExecutionError] if not the root promise\n"],["set","Concurrent::Tuple","Concurrent/Tuple.html#method-i-set","(i, value)","<p>Set the element at the given index to the given value\n<p>@param [Integer] i the index for the element to \n"],["set!","Concurrent::MVar","Concurrent/MVar.html#method-i-set-21","(value)","<p>Non-blocking version of `put` that will overwrite an existing value.\n"],["set?","Concurrent::Event","Concurrent/Event.html#method-i-set-3F","()","<p>Is the object in the set state?\n<p>@return [Boolean] indicating whether or not the `Event` has been set\n"],["set_c_extensions_loaded","Concurrent::Utility::NativeExtensionLoader","Concurrent/Utility/NativeExtensionLoader.html#method-i-set_c_extensions_loaded","()",""],["set_deref_options","Concurrent::Concern::Dereferenceable","Concurrent/Concern/Dereferenceable.html#method-i-set_deref_options","(opts = {})","<p>@!macro dereferenceable_set_deref_options\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Set</span> <span class=\"ruby-identifier\">the</span> <span class=\"ruby-identifier\">options</span> <span class=\"ruby-identifier\">which</span> <span class=\"ruby-identifier\">define</span> <span class=\"ruby-identifier\">the</span> <span class=\"ruby-identifier\">operations</span> <span class=\"ruby-comment\">#value performs ...</span>\n</pre>\n"],["set_java_extensions_loaded","Concurrent::Utility::NativeExtensionLoader","Concurrent/Utility/NativeExtensionLoader.html#method-i-set_java_extensions_loaded","()",""],["set_pending","Concurrent::Promise","Concurrent/Promise.html#method-i-set_pending","()","<p>@!visibility private\n"],["set_state","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-set_state","(success, value, reason)","<p>@!visibility private\n"],["set_state!","Concurrent::Promise","Concurrent/Promise.html#method-i-set_state-21","(success, value, reason)","<p>@!visibility private\n"],["set_threadlocal_array","Concurrent::RubyThreadLocalVar","Concurrent/RubyThreadLocalVar.html#method-i-set_threadlocal_array","(array, thread = Thread.current)",""],["setup","Concurrent::SynchronizedDelegator","Concurrent/SynchronizedDelegator.html#method-i-setup","()",""],["shift","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-shift","()",""],["shift","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-shift","()",""],["shutdown","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-shutdown","()","<p>@!macro executor_service_method_shutdown\n"],["shutdown","Concurrent::ImmediateExecutor","Concurrent/ImmediateExecutor.html#method-i-shutdown","()","<p>@!macro executor_service_method_shutdown\n"],["shutdown","Concurrent::JavaExecutorService","Concurrent/JavaExecutorService.html#method-i-shutdown","()",""],["shutdown","Concurrent::RubyExecutorService","Concurrent/RubyExecutorService.html#method-i-shutdown","()",""],["shutdown","Concurrent::SimpleExecutorService","Concurrent/SimpleExecutorService.html#method-i-shutdown","()","<p>@!macro executor_service_method_shutdown\n"],["shutdown?","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-shutdown-3F","()","<p>@!macro executor_service_method_shutdown_question\n"],["shutdown?","Concurrent::ImmediateExecutor","Concurrent/ImmediateExecutor.html#method-i-shutdown-3F","()","<p>@!macro executor_service_method_shutdown_question\n"],["shutdown?","Concurrent::SimpleExecutorService","Concurrent/SimpleExecutorService.html#method-i-shutdown-3F","()","<p>@!macro executor_service_method_shutdown_question\n"],["shuttingdown?","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-shuttingdown-3F","()","<p>@!macro executor_service_method_shuttingdown_question\n"],["shuttingdown?","Concurrent::ImmediateExecutor","Concurrent/ImmediateExecutor.html#method-i-shuttingdown-3F","()","<p>@!macro executor_service_method_shuttingdown_question\n"],["shuttingdown?","Concurrent::SimpleExecutorService","Concurrent/SimpleExecutorService.html#method-i-shuttingdown-3F","()","<p>@!macro executor_service_method_shuttingdown_question\n"],["signal","Concurrent::Synchronization::Condition","Concurrent/Synchronization/Condition.html#method-i-signal","()",""],["signal","Concurrent::Synchronization::Lock","Concurrent/Synchronization/Lock.html#method-i-signal","()",""],["sink","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-sink","(k)","<p>Percolate down to maintain heap invariant.\n<p>@param [Integer] k the index at which to start the percolation \n"],["size","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-size","()",""],["size","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-size","()",""],["size","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-size","()",""],["size","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-size","()",""],["size","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-size","()",""],["size","Concurrent::Map","Concurrent/Map.html#method-i-size","()","<p>The size of map. @return [Integer] size\n"],["size","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-size","()",""],["split_bin","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-split_bin","(new_table, i, node, node_hash)",""],["split_old_bin","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-split_old_bin","(table, new_table, i, node, node_hash, forwarder)","<p>Splits a normal bin with list headed by e into lo and hi parts; installs in given table.\n"],["state","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-state","()","<p>The current state of the obligation.\n<p>@return [Symbol] the current state\n"],["state","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-state","()","<p>Returns its state. @return [Symbol]\n<p>@overload an_event.state\n\n<pre class=\"ruby\"><span class=\"ruby-ivar\">@return</span> [<span class=\"ruby-value\">:pending</span>, <span class=\"ruby-value\">:resolved</span>]\n</pre>\n"],["state","Concurrent::Promises::AbstractPromise","Concurrent/Promises/AbstractPromise.html#method-i-state","()",""],["state=","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-state-3D","(value)","<p>@!visibility private\n"],["stop","Concurrent::RubyThreadPoolExecutor::Worker","Concurrent/RubyThreadPoolExecutor/Worker.html#method-i-stop","()",""],["stop_event","Concurrent::RubyExecutorService","Concurrent/RubyExecutorService.html#method-i-stop_event","()",""],["stopped?","Concurrent::Agent","Concurrent/Agent.html#method-i-stopped-3F","()",""],["stopped_event","Concurrent::RubyExecutorService","Concurrent/RubyExecutorService.html#method-i-stopped_event","()",""],["store_computed_value","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-store_computed_value","(key, new_value)",""],["sum","Concurrent::ThreadSafe::Util::Adder","Concurrent/ThreadSafe/Util/Adder.html#method-i-sum","()","<p>Returns the current sum.  The returned value is <em>NOT</em> an atomic snapshot: Invocation in the absence of \n"],["swap","Concurrent::Atom","Concurrent/Atom.html#method-i-swap","(*args)","<p>Atomically swaps the value of atom using the given block. The current value will be passed to the block, \n"],["swap","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-swap","(x, y)","<p>Exchange the values at the given indexes within the internal array.\n<p>@param [Integer] x the first index \n"],["swap","Concurrent::MutexAtomicReference","Concurrent/MutexAtomicReference.html#method-i-swap","(new_value)",""],["swim","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-swim","(k)","<p>Percolate up to maintain heap invariant.\n<p>@param [Integer] k the index at which to start the percolation \n"],["synchronize","Concurrent::MVar","Concurrent/MVar.html#method-i-synchronize","(&block)",""],["synchronize","Concurrent::Synchronization::AbstractLockableObject","Concurrent/Synchronization/AbstractLockableObject.html#method-i-synchronize","()","<p>@!macro synchronization_object_method_synchronize\n\n<pre>@yield runs the block synchronized against this object, ...</pre>\n"],["synchronize","Concurrent::Synchronization::MonitorLockableObject","Concurrent/Synchronization/MonitorLockableObject.html#method-i-synchronize","()",""],["synchronize","Concurrent::Synchronization::MutexLockableObject","Concurrent/Synchronization/MutexLockableObject.html#method-i-synchronize","()",""],["synchronize","Concurrent::Synchronization::RbxLockableObject","Concurrent/Synchronization/RbxLockableObject.html#method-i-synchronize","(&block)",""],["synchronized","TruffleRuby","TruffleRuby.html#method-c-synchronized","(object, &block)",""],["synchronized_set_state!","Concurrent::Promise","Concurrent/Promise.html#method-i-synchronized_set_state-21","(success, value, reason)","<p>@!visibility private\n"],["table_size_for","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-table_size_for","(entry_count)","<p>Returns a power of two table size for the given desired capacity.\n"],["take","Concurrent::MVar","Concurrent/MVar.html#method-i-take","(timeout = nil)","<p>Remove the value from an `MVar`, leaving it empty, and blocking if there isn&#39;t a value. A timeout \n"],["tangle","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-tangle","(resolvable)",""],["teardown","Concurrent::SynchronizedDelegator","Concurrent/SynchronizedDelegator.html#method-i-teardown","()",""],["terminate_at_exit","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-terminate_at_exit","()",""],["then","Concurrent::Promise","Concurrent/Promise.html#method-i-then","(*args, &block)","<p>Chain a new promise off the current promise.\n<p>@return [Promise] the new promise @yield The block operation \n"],["then","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-then","(*args, &task)","<p>@!macro promises.shortcut.on @return [Future]\n"],["then_on","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-then_on","(executor, *args, &task)","<p>Chains the task to be executed asynchronously on executor after it fulfills. Does not run the task if \n"],["thread_finalizer","Concurrent::RubyThreadLocalVar","Concurrent/RubyThreadLocalVar.html#method-c-thread_finalizer","(array)","<p>@!visibility private\n"],["threadlocal_finalizer","Concurrent::RubyThreadLocalVar","Concurrent/RubyThreadLocalVar.html#method-c-threadlocal_finalizer","(index)","<p>@!visibility private\n"],["timeout_interval","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-timeout_interval","()","<p>@!attribute [rw] timeout_interval @return [Fixnum] Number of seconds the task can run before it is\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">considered</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["timeout_interval=","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-timeout_interval-3D","(value)","<p>@!attribute [rw] timeout_interval @return [Fixnum] Number of seconds the task can run before it is\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">considered</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["timeout_task","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-timeout_task","(completion)","<p>@!visibility private\n"],["to_a","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-to_a","()",""],["to_a","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-to_a","()",""],["to_a","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-to_a","()",""],["to_event","Concurrent::Promises::Event","Concurrent/Promises/Event.html#method-i-to_event","()","<p>Returns self, since this is event @return [Event]\n"],["to_event","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-to_event","()","<p>Converts future to event which is resolved when future is resolved by fulfillment or rejection.\n<p>@return \n"],["to_future","Concurrent::Promises::Event","Concurrent/Promises/Event.html#method-i-to_future","()","<p>Converts event to a future. The future is fulfilled when the event is resolved, the future may never \n"],["to_future","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-to_future","()","<p>Returns self, since this is a future @return [Future]\n"],["to_h","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-to_h","()","<p>@!macro struct_to_h\n"],["to_h","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-to_h","()","<p>@!macro struct_to_h\n\n<pre>Returns a hash containing the names and values for the structs members.\n\n@return ...</pre>\n"],["to_h","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-to_h","()","<p>@!macro struct_to_h\n"],["to_s","AtomicReference","AtomicReference.html#method-i-to_s","()","<p>@return [String] Short string representation.\n"],["to_s","Concurrent::AtomicBoolean","Concurrent/AtomicBoolean.html#method-i-to_s","()","<p>@return [String] Short string representation.\n"],["to_s","Concurrent::AtomicFixnum","Concurrent/AtomicFixnum.html#method-i-to_s","()","<p>@return [String] Short string representation.\n"],["to_s","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-to_s","()",""],["to_s","Concurrent::LockFreeStack","Concurrent/LockFreeStack.html#method-i-to_s","()","<p>@return [String] Short string representation.\n"],["to_s","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-to_s","()",""],["to_s","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-to_s","()","<p>@return [String] Short string representation.\n"],["to_s","Concurrent::Promises::AbstractPromise","Concurrent/Promises/AbstractPromise.html#method-i-to_s","()",""],["to_s","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-to_s","()","<p>@return [String] Short string representation.\n"],["to_s","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-to_s","()",""],["to_sym","Concurrent::Promises::InternalStates::Fulfilled","Concurrent/Promises/InternalStates/Fulfilled.html#method-i-to_sym","()",""],["to_sym","Concurrent::Promises::InternalStates::PartiallyRejected","Concurrent/Promises/InternalStates/PartiallyRejected.html#method-i-to_sym","()",""],["to_sym","Concurrent::Promises::InternalStates::Pending","Concurrent/Promises/InternalStates/Pending.html#method-i-to_sym","()",""],["to_sym","Concurrent::Promises::InternalStates::Rejected","Concurrent/Promises/InternalStates/Rejected.html#method-i-to_sym","()",""],["to_sym","Concurrent::Promises::InternalStates::ResolvedWithResult","Concurrent/Promises/InternalStates/ResolvedWithResult.html#method-i-to_sym","()",""],["to_sym","Concurrent::Promises::InternalStates::State","Concurrent/Promises/InternalStates/State.html#method-i-to_sym","()",""],["touch","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-touch","()","<p>Propagates touch. Requests all the delayed futures, which it depends on, to be executed. This method \n"],["touch","Concurrent::Promises::AbstractFlatPromise","Concurrent/Promises/AbstractFlatPromise.html#method-i-touch","()",""],["touch","Concurrent::Promises::AbstractPromise","Concurrent/Promises/AbstractPromise.html#method-i-touch","()",""],["touch","Concurrent::Promises::BlockedPromise","Concurrent/Promises/BlockedPromise.html#method-i-touch","()",""],["touch","Concurrent::Promises::DelayPromise","Concurrent/Promises/DelayPromise.html#method-i-touch","()",""],["touched?","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-touched-3F","()","<p>For inspection. @!visibility private\n"],["touched?","Concurrent::Promises::AbstractFlatPromise","Concurrent/Promises/AbstractFlatPromise.html#method-i-touched-3F","()",""],["true?","Concurrent::MutexAtomicBoolean","Concurrent/MutexAtomicBoolean.html#method-i-true-3F","()","<p>@!macro atomic_boolean_method_true_question\n"],["try?","Concurrent::Event","Concurrent/Event.html#method-i-try-3F","()",""],["try_acquire","Concurrent::MutexSemaphore","Concurrent/MutexSemaphore.html#method-i-try_acquire","(permits = 1, timeout = nil)","<p>@!macro semaphore_method_try_acquire\n"],["try_acquire_now","Concurrent::MutexSemaphore","Concurrent/MutexSemaphore.html#method-i-try_acquire_now","(permits)","<p>@!visibility private\n"],["try_acquire_timed","Concurrent::MutexSemaphore","Concurrent/MutexSemaphore.html#method-i-try_acquire_timed","(permits, timeout)","<p>@!visibility private\n"],["try_await_lock","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-try_await_lock","(current_table, i, node)",""],["try_await_lock","Concurrent::Collection::AtomicReferenceMapBackend::Node","Concurrent/Collection/AtomicReferenceMapBackend/Node.html#method-i-try_await_lock","(table, i)","<p>Spins a while if <code>LOCKED</code> bit set and this node is the first of its bin, and then sets <code>WAITING</code> bits on \n"],["try_exchange","Concurrent::AbstractExchanger","Concurrent/AbstractExchanger.html#method-i-try_exchange","(value, timeout = nil)","<p>@!macro exchanger_method_do_exchange @!macro exchanger_method_try_exchange\n\n<pre>The return value will be a ...</pre>\n"],["try_in_busy","Concurrent::ThreadSafe::Util::Striped64","Concurrent/ThreadSafe/Util/Striped64.html#method-i-try_in_busy","()",""],["try_in_resize_lock","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-try_in_resize_lock","(current_table, size_ctrl)",""],["try_initialize_cells","Concurrent::ThreadSafe::Util::Striped64","Concurrent/ThreadSafe/Util/Striped64.html#method-i-try_initialize_cells","(x, hash)",""],["try_load_c_extension","Concurrent::Utility::NativeExtensionLoader","Concurrent/Utility/NativeExtensionLoader.html#method-i-try_load_c_extension","(path)",""],["try_lock_via_hash","Concurrent::Collection::AtomicReferenceMapBackend::Node","Concurrent/Collection/AtomicReferenceMapBackend/Node.html#method-i-try_lock_via_hash","(node_hash = hash)",""],["try_lock_via_hash","Concurrent::Collection::AtomicReferenceMapBackend::Table","Concurrent/Collection/AtomicReferenceMapBackend/Table.html#method-i-try_lock_via_hash","(i, node, node_hash)",""],["try_put!","Concurrent::MVar","Concurrent/MVar.html#method-i-try_put-21","(value)","<p>Non-blocking version of `put`, that returns whether or not it was successful.\n"],["try_read_lock","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-try_read_lock","()","<p>Try to acquire a read lock and return true if we succeed. If it cannot be acquired immediately, return \n"],["try_set","Concurrent::IVar","Concurrent/IVar.html#method-i-try_set","(value = NULL, &block)","<p>Attempt to set the `IVar` with the given value or block. Return a boolean indicating the success or failure \n"],["try_take!","Concurrent::MVar","Concurrent/MVar.html#method-i-try_take-21","()","<p>Non-blocking version of `take`, that returns `EMPTY` instead of blocking.\n"],["try_to_cas_in_computed","Concurrent::Collection::AtomicReferenceMapBackend::Table","Concurrent/Collection/AtomicReferenceMapBackend/Table.html#method-i-try_to_cas_in_computed","(i, hash, key)",""],["try_to_install_new_cell","Concurrent::ThreadSafe::Util::Striped64","Concurrent/ThreadSafe/Util/Striped64.html#method-i-try_to_install_new_cell","(new_cell, hash)",""],["try_update","Concurrent::AtomicDirectUpdate","Concurrent/AtomicDirectUpdate.html#method-i-try_update","()","<p>@!macro atomic_reference_method_try_update\n\n<pre>Pass the current value to the given block, replacing it\nwith ...</pre>\n"],["try_update","Concurrent::AtomicMarkableReference","Concurrent/AtomicMarkableReference.html#method-i-try_update","()","<p>Pass the current value to the given block, replacing it with the block&#39;s result. Simply return nil \n"],["try_update!","Concurrent::AtomicDirectUpdate","Concurrent/AtomicDirectUpdate.html#method-i-try_update-21","()","<p>@!macro atomic_reference_method_try_update!\n\n<pre>Pass the current value to the given block, replacing it\nwith ...</pre>\n"],["try_update!","Concurrent::AtomicMarkableReference","Concurrent/AtomicMarkableReference.html#method-i-try_update-21","()","<p>Pass the current value to the given block, replacing it with the block&#39;s result. Raise an exception \n"],["try_write_lock","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-try_write_lock","()","<p>Try to acquire a write lock and return true if we succeed. If it cannot be acquired immediately, return \n"],["unlock","Concurrent::Transaction","Concurrent/Transaction.html#method-i-unlock","()",""],["unlock_via_hash","Concurrent::Collection::AtomicReferenceMapBackend::Node","Concurrent/Collection/AtomicReferenceMapBackend/Node.html#method-i-unlock_via_hash","(locked_hash, node_hash)",""],["unlocked_empty?","Concurrent::MVar","Concurrent/MVar.html#method-i-unlocked_empty-3F","()",""],["unlocked_full?","Concurrent::MVar","Concurrent/MVar.html#method-i-unlocked_full-3F","()",""],["unscheduled?","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-unscheduled-3F","()","<p>Is the obligation still unscheduled?\n<p>@return [Boolean]\n"],["up","Concurrent::MutexAtomicFixnum","Concurrent/MutexAtomicFixnum.html#method-i-up","(delta = 1)",""],["update","Concurrent::AtomicDirectUpdate","Concurrent/AtomicDirectUpdate.html#method-i-update","()","<p>@!macro atomic_reference_method_update\n\n<pre>Pass the current value to the given block, replacing it\nwith the ...</pre>\n"],["update","Concurrent::AtomicMarkableReference","Concurrent/AtomicMarkableReference.html#method-i-update","()","<p>Pass the current value and marked state to the given block, replacing it with the block&#39;s results. \n"],["update","Concurrent::MutexAtomicFixnum","Concurrent/MutexAtomicFixnum.html#method-i-update","()","<p>@!macro atomic_fixnum_method_update\n"],["use_simple_logger","Concurrent","Concurrent.html#method-c-use_simple_logger","(level = Logger::FATAL, output = $stderr)","<p>Use logger created by #create_simple_logger to log concurrent-ruby messages.\n"],["use_stdlib_logger","Concurrent","Concurrent.html#method-c-use_stdlib_logger","(level = Logger::FATAL, output = $stderr)","<p>Use logger created by #create_stdlib_logger to log concurrent-ruby messages. @deprecated\n"],["valid?","Concurrent::Atom","Concurrent/Atom.html#method-i-valid-3F","(new_value)","<p>Is the new value valid?\n<p>@param [Object] new_value The intended new value. @return [Boolean] false if the \n"],["valid?","Concurrent::Transaction","Concurrent/Transaction.html#method-i-valid-3F","()",""],["validate_argc","Concurrent::Async","Concurrent/Async.html#method-c-validate_argc","(obj, method, *args)","<p>Check for the presence of a method on an object and determine if a given set of arguments matches the \n"],["validate_options_hash!","Concurrent::Map","Concurrent/Map.html#method-i-validate_options_hash-21","(options)",""],["value","Concurrent::AbstractThreadLocalVar","Concurrent/AbstractThreadLocalVar.html#method-i-value","()","<p>@!macro thread_local_var_method_get\n"],["value","Concurrent::Agent","Concurrent/Agent.html#method-i-value","()","<p>The current value (state) of the Agent, irrespective of any pending or in-progress actions. The value \n"],["value","Concurrent::AtomicMarkableReference","Concurrent/AtomicMarkableReference.html#method-i-value","()","<p>Gets the current value of the reference\n<p>@return [Object] the current value of the reference\n"],["value","Concurrent::Concern::Dereferenceable","Concurrent/Concern/Dereferenceable.html#method-i-value","()","<p>Return the value this object represents after applying the options specified by the `#set_deref_options` \n"],["value","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-value","(timeout = nil)","<p>The current value of the obligation. Will be `nil` while the state is pending or the operation has been \n"],["value","Concurrent::Delay","Concurrent/Delay.html#method-i-value","(timeout = nil)","<p>Return the value this object represents after applying the options specified by the `#set_deref_options` \n"],["value","Concurrent::JavaThreadLocalVar","Concurrent/JavaThreadLocalVar.html#method-i-value","()","<p>@!macro thread_local_var_method_get\n"],["value","Concurrent::MutexAtomicBoolean","Concurrent/MutexAtomicBoolean.html#method-i-value","()","<p>@!macro atomic_boolean_method_value_get\n"],["value","Concurrent::MutexAtomicFixnum","Concurrent/MutexAtomicFixnum.html#method-i-value","()","<p>@!macro atomic_fixnum_method_value_get\n"],["value","Concurrent::MutexAtomicReference","Concurrent/MutexAtomicReference.html#method-i-value","()",""],["value","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-value","(timeout = nil, timeout_value = nil)","<p>@!macro promises.method.value\n\n<pre>Return value of the future.\n@!macro promises.touches\n\n@!macro promises.warn.blocks ...</pre>\n"],["value","Concurrent::Promises::InternalStates::Fulfilled","Concurrent/Promises/InternalStates/Fulfilled.html#method-i-value","()",""],["value","Concurrent::Promises::InternalStates::PartiallyRejected","Concurrent/Promises/InternalStates/PartiallyRejected.html#method-i-value","()",""],["value","Concurrent::Promises::InternalStates::Rejected","Concurrent/Promises/InternalStates/Rejected.html#method-i-value","()",""],["value","Concurrent::Promises::InternalStates::ResolvedWithResult","Concurrent/Promises/InternalStates/ResolvedWithResult.html#method-i-value","()",""],["value","Concurrent::Promises::ResolvableFuture","Concurrent/Promises/ResolvableFuture.html#method-i-value","(timeout = nil, timeout_value = nil, resolve_on_timeout = nil)","<p>Behaves as {Future#value} but has one additional optional argument resolve_on_timeout.\n<p>@!macro promises.resolvable.resolve_on_timeout \n"],["value","Concurrent::RubyThreadLocalVar","Concurrent/RubyThreadLocalVar.html#method-i-value","()","<p>@!macro thread_local_var_method_get\n"],["value","Concurrent::TVar","Concurrent/TVar.html#method-i-value","()","<p>Get the value of a `TVar`.\n"],["value!","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-value-21","(timeout = nil)","<p>The current value of the obligation. Will be `nil` while the state is pending or the operation has been \n"],["value!","Concurrent::Delay","Concurrent/Delay.html#method-i-value-21","(timeout = nil)","<p>Return the value this object represents after applying the options specified by the `#set_deref_options` \n"],["value!","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-value-21","(timeout = nil, timeout_value = nil)","<p>@!macro promises.method.value @return [Object, nil, timeout_value] the value of the Future when fulfilled, \n"],["value!","Concurrent::Promises::ResolvableFuture","Concurrent/Promises/ResolvableFuture.html#method-i-value-21","(timeout = nil, timeout_value = nil, resolve_on_timeout = nil)","<p>Behaves as {Future#value!} but has one additional optional argument resolve_on_timeout.\n<p>@!macro promises.resolvable.resolve_on_timeout \n"],["value=","Concurrent::AbstractThreadLocalVar","Concurrent/AbstractThreadLocalVar.html#method-i-value-3D","(value)","<p>@!macro thread_local_var_method_set\n"],["value=","Concurrent::Concern::Dereferenceable","Concurrent/Concern/Dereferenceable.html#method-i-value-3D","(value)","<p>Set the internal value of this object\n<p>@param [Object] value the new value\n"],["value=","Concurrent::JavaThreadLocalVar","Concurrent/JavaThreadLocalVar.html#method-i-value-3D","(value)","<p>@!macro thread_local_var_method_set\n"],["value=","Concurrent::MutexAtomicBoolean","Concurrent/MutexAtomicBoolean.html#method-i-value-3D","(value)","<p>@!macro atomic_boolean_method_value_set\n"],["value=","Concurrent::MutexAtomicFixnum","Concurrent/MutexAtomicFixnum.html#method-i-value-3D","(value)","<p>@!macro atomic_fixnum_method_value_set\n"],["value=","Concurrent::MutexAtomicReference","Concurrent/MutexAtomicReference.html#method-i-value-3D","(new_value)",""],["value=","Concurrent::RubyThreadLocalVar","Concurrent/RubyThreadLocalVar.html#method-i-value-3D","(value)","<p>@!macro thread_local_var_method_set\n"],["value=","Concurrent::TVar","Concurrent/TVar.html#method-i-value-3D","(value)","<p>Set the value of a `TVar`.\n"],["value?","Concurrent::Map","Concurrent/Map.html#method-i-value-3F","(value)","<p>Is the value stored in the map. Iterates over all values. @param [Object] value @return [true, false] \n"],["value_for","Concurrent::RubyThreadLocalVar","Concurrent/RubyThreadLocalVar.html#method-i-value_for","(thread)","<p>This exists only for use in testing @!visibility private\n"],["values","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-values","()","<p>@!macro struct_values\n"],["values","Concurrent::Map","Concurrent/Map.html#method-i-values","()","<p>All values @return [::Array&lt;Object&gt;] values\n"],["values","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-values","()","<p>@!macro struct_values\n\n<pre>Returns the values for this struct as an Array.\n\n@return [Array] the values for ...</pre>\n"],["values","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-values","()","<p>@!macro struct_values\n"],["values_at","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-values_at","(*indexes)","<p>@!macro struct_values_at\n"],["values_at","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-values_at","(*indexes)","<p>@!macro struct_values_at\n\n<pre>Returns the struct member values for each selector as an Array.\n\nA selector may ...</pre>\n"],["values_at","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-values_at","(*indexes)","<p>@!macro struct_values_at\n"],["volatile_get","Concurrent::Tuple","Concurrent/Tuple.html#method-i-volatile_get","(i)",""],["volatile_get_by_hash","Concurrent::ThreadSafe::Util::PowerOfTwoTuple","Concurrent/ThreadSafe/Util/PowerOfTwoTuple.html#method-i-volatile_get_by_hash","(hash)",""],["volatile_set","Concurrent::Tuple","Concurrent/Tuple.html#method-i-volatile_set","(i, value)",""],["volatile_set_by_hash","Concurrent::ThreadSafe::Util::PowerOfTwoTuple","Concurrent/ThreadSafe/Util/PowerOfTwoTuple.html#method-i-volatile_set_by_hash","(hash, value)",""],["wait","Concurrent::Agent","Concurrent/Agent.html#method-i-wait","(timeout = nil)","<p>Blocks the current thread until all actions dispatched thus far, from this thread or nested by the Agent \n"],["wait","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-wait","(timeout = nil)","<p>Wait until obligation is complete or the timeout has been reached.\n<p>@param [Numeric] timeout the maximum \n"],["wait","Concurrent::CyclicBarrier","Concurrent/CyclicBarrier.html#method-i-wait","(timeout = nil)","<p>Blocks on the barrier until the number of waiting threads is equal to `parties` or until `timeout` is \n"],["wait","Concurrent::Delay","Concurrent/Delay.html#method-i-wait","(timeout = nil)","<p>Return the value this object represents after applying the options specified by the `#set_deref_options` \n"],["wait","Concurrent::Event","Concurrent/Event.html#method-i-wait","(timeout = nil)","<p>Wait a given number of seconds for the `Event` to be set by another thread. Will wait forever when no \n"],["wait","Concurrent::JavaCountDownLatch","Concurrent/JavaCountDownLatch.html#method-i-wait","(timeout = nil)","<p>@!macro count_down_latch_method_wait\n"],["wait","Concurrent::MutexCountDownLatch","Concurrent/MutexCountDownLatch.html#method-i-wait","(timeout = nil)","<p>@!macro count_down_latch_method_wait\n"],["wait","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-wait","(timeout = nil)","<p>@!macro promises.method.wait\n\n<pre>Wait (block the Thread) until receiver is {#resolved?}.\n@!macro promises.touches ...</pre>\n"],["wait","Concurrent::Promises::ResolvableEvent","Concurrent/Promises/ResolvableEvent.html#method-i-wait","(timeout = nil, resolve_on_timeout = false)","<p>Behaves as {AbstractEventFuture#wait} but has one additional optional argument resolve_on_timeout.\n<p>@param \n"],["wait","Concurrent::Promises::ResolvableFuture","Concurrent/Promises/ResolvableFuture.html#method-i-wait","(timeout = nil, resolve_on_timeout = nil)","<p>Behaves as {AbstractEventFuture#wait} but has one additional optional argument resolve_on_timeout.\n<p>@!macro \n"],["wait","Concurrent::Synchronization::Condition","Concurrent/Synchronization/Condition.html#method-i-wait","(timeout = nil)",""],["wait","Concurrent::Synchronization::Lock","Concurrent/Synchronization/Lock.html#method-i-wait","(timeout = nil)","<p>TODO use JavaReentrantLock on JRuby\n"],["wait!","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-wait-21","(timeout = nil)","<p>Wait until obligation is complete or the timeout is reached. Will re-raise any exceptions raised during \n"],["wait!","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-wait-21","(timeout = nil)","<p>@!macro promises.method.wait @raise [Exception] {#reason} on rejection\n"],["wait!","Concurrent::Promises::ResolvableFuture","Concurrent/Promises/ResolvableFuture.html#method-i-wait-21","(timeout = nil, resolve_on_timeout = nil)","<p>Behaves as {Future#wait!} but has one additional optional argument resolve_on_timeout.\n<p>@!macro promises.resolvable.resolve_on_timeout \n"],["wait_for_empty","Concurrent::MVar","Concurrent/MVar.html#method-i-wait_for_empty","(timeout)",""],["wait_for_full","Concurrent::MVar","Concurrent/MVar.html#method-i-wait_for_full","(timeout)",""],["wait_for_termination","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-wait_for_termination","(timeout = nil)","<p>@!macro executor_service_method_wait_for_termination\n"],["wait_for_termination","Concurrent::ImmediateExecutor","Concurrent/ImmediateExecutor.html#method-i-wait_for_termination","(timeout = nil)","<p>@!macro executor_service_method_wait_for_termination\n"],["wait_for_termination","Concurrent::JavaExecutorService","Concurrent/JavaExecutorService.html#method-i-wait_for_termination","(timeout = nil)",""],["wait_for_termination","Concurrent::RubyExecutorService","Concurrent/RubyExecutorService.html#method-i-wait_for_termination","(timeout = nil)",""],["wait_for_termination","Concurrent::SimpleExecutorService","Concurrent/SimpleExecutorService.html#method-i-wait_for_termination","(timeout = nil)","<p>@!macro executor_service_method_wait_for_termination\n"],["wait_or_cancel","Concurrent::Future","Concurrent/Future.html#method-i-wait_or_cancel","(timeout)","<p>Wait the given number of seconds for the operation to complete. On timeout attempt to cancel the operation. \n"],["wait_until","Concurrent::Synchronization::Condition","Concurrent/Synchronization/Condition.html#method-i-wait_until","(timeout = nil, &condition)",""],["wait_until","Concurrent::Synchronization::Lock","Concurrent/Synchronization/Lock.html#method-i-wait_until","(timeout = nil, &condition)",""],["wait_until_resolved","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-wait_until_resolved","(timeout)","<p>@return [Boolean]\n"],["wait_until_resolved!","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-wait_until_resolved-21","(timeout = nil)",""],["wait_while","Concurrent::MVar","Concurrent/MVar.html#method-i-wait_while","(condition, timeout)",""],["waiting_or_running_writer?","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-waiting_or_running_writer-3F","(c = @Counter.value)","<p>@!visibility private\n"],["waiting_threads","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-waiting_threads","()","<p>For inspection. @!visibility private\n"],["waiting_writer?","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-waiting_writer-3F","(c = @Counter.value)","<p>@!visibility private\n"],["waiting_writers","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-waiting_writers","(c = @Counter.value)","<p>@!visibility private\n"],["waiting_writers","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-waiting_writers","(c = @Counter.value)","<p>@!visibility private\n"],["with_async","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-with_async","(executor, *args, &block)",""],["with_default_executor","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-with_default_executor","(executor)","<p>@!macro promises.method.with_default_executor\n\n<pre>Crates new object with same class with the executor set ...</pre>\n"],["with_default_executor","Concurrent::Promises::Event","Concurrent/Promises/Event.html#method-i-with_default_executor","(executor)","<p>@!macro promises.method.with_default_executor @return [Event]\n"],["with_default_executor","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-with_default_executor","(executor)","<p>@!macro promises.method.with_default_executor @return [Future]\n"],["with_hidden_resolvable","Concurrent::Promises::AbstractEventFuture","Concurrent/Promises/AbstractEventFuture.html#method-i-with_hidden_resolvable","()","<p>@!visibility private\n"],["with_hidden_resolvable","Concurrent::Promises::ResolvableEvent","Concurrent/Promises/ResolvableEvent.html#method-i-with_hidden_resolvable","()","<p>Creates new event wrapping receiver, effectively hiding the resolve method.\n<p>@return [Event]\n"],["with_hidden_resolvable","Concurrent::Promises::ResolvableFuture","Concurrent/Promises/ResolvableFuture.html#method-i-with_hidden_resolvable","()","<p>Creates new future wrapping receiver, effectively hiding the resolve method and similar.\n<p>@return [Future] \n"],["with_observer","Concurrent::Concern::Observable","Concurrent/Concern/Observable.html#method-i-with_observer","(observer = nil, func = :update, &block)","<p>As `#add_observer` but can be used for chaining.\n<p>@param [Object] observer the observer to add @param [Symbol] \n"],["with_read_lock","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-with_read_lock","()","<p>Execute a block operation within a read lock.\n<p>@yield the task to be performed within the lock.\n<p>@return \n"],["with_read_lock","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-with_read_lock","()","<p>Execute a block operation within a read lock.\n<p>@yield the task to be performed within the lock.\n<p>@return \n"],["with_write_lock","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-with_write_lock","()","<p>Execute a block operation within a write lock.\n<p>@yield the task to be performed within the lock.\n<p>@return \n"],["with_write_lock","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-with_write_lock","()","<p>Execute a block operation within a write lock.\n<p>@yield the task to be performed within the lock.\n<p>@return \n"],["work","Concurrent::SerializedExecution","Concurrent/SerializedExecution.html#method-i-work","(job)","<p>ensures next job is executed if any is stashed\n"],["worker_died","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-worker_died","(worker)","<p>@!visibility private\n"],["worker_not_old_enough","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-worker_not_old_enough","(worker)","<p>@!visibility private\n"],["worker_task_completed","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-worker_task_completed","()","<p>@!visibility private\n"],["write","Concurrent::Transaction","Concurrent/Transaction.html#method-i-write","(tvar, value)",""],["write_locked?","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-write_locked-3F","()","<p>Queries if the write lock is held by any thread.\n<p>@return [Boolean] true if the write lock is held else \n"],["xorshift","Concurrent::ThreadSafe::Util::XorShiftRandom","Concurrent/ThreadSafe/Util/XorShiftRandom.html#method-i-xorshift","(x)","<p>using the y=y&gt;&gt;a; y=y&lt;&lt;b; y=y&gt;&gt;c; transform with the (a,b,c) tuple with \n"],["zip","Concurrent::Promise","Concurrent/Promise.html#method-i-zip","(*others)","<p>Builds a promise that produces the result of self and others in an Array and fails if any of them fails. \n"],["zip","Concurrent::Promise","Concurrent/Promise.html#method-c-zip","(*promises)","<p>Builds a promise that produces the result of promises in an Array and fails if any of them fails.\n<p>@overload \n"],["zip","Concurrent::Promises::Event","Concurrent/Promises/Event.html#method-i-zip","(other)","<p>@!macro promises.method.zip\n\n<pre>Creates a new event or a future which will be resolved when receiver and other ...</pre>\n"],["zip","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-zip","(*futures_and_or_events)",""],["zip","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-zip","(other)","<p>@!macro promises.method.zip @return [Future]\n"],["zip_events","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-zip_events","(*futures_and_or_events)","<p>@!macro promises.shortcut.on @return [Event]\n"],["zip_events_on","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-zip_events_on","(default_executor, *futures_and_or_events)","<p>Creates new event which is resolved after all futures_and_or_events are resolved. (Future is resolved \n"],["zip_futures","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-zip_futures","(*futures_and_or_events)","<p>@!macro promises.shortcut.on @return [Future]\n"],["zip_futures_on","Concurrent::Promises::FactoryMethods","Concurrent/Promises/FactoryMethods.html#method-i-zip_futures_on","(default_executor, *futures_and_or_events)","<p>Creates new future which is resolved after all futures_and_or_events are resolved. Its value is array \n"],["|","Concurrent::Promises::Event","Concurrent/Promises/Event.html#method-i-7C","(event_or_future)",""],["|","Concurrent::Promises::Future","Concurrent/Promises/Future.html#method-i-7C","(event_or_future)",""],["CHANGELOG","","CHANGELOG_md.html","","<p>Current\n<p>Release v1.1.5, edge v0.5.0 (10 mar 2019)\n<p>concurrent-ruby:\n"],["LICENSE","","LICENSE_md.html","","\n<pre>Copyright (c) Jerry D&#39;Antonio -- released under the MIT license.\n\nhttp://www.opensource.org/licenses/mit-license.php ...</pre>\n"],["README","","README_md.html","","<p>Concurrent Ruby\n<p><img src=\"https://badge.fury.io/rb/concurrent-ruby.svg\">\n<img src=\"https://travis-ci.org/ruby-concurrency/concurrent-ruby.svg?branch=master\"> ...\n"]]}}